<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Linux 虚拟内存文件系统以及共享内存 | Memos</title>
<meta name=keywords content><meta name=description content="最近看了《Understanding the Linux® Virtual Memory Manager》里面的第十二章 SHARED MEMORY VIRTUAL FILESYSTEM ，对文件系统以及内存文件管理有了更加深入的了解，下面是看了这一章节之后对其中一些概念的理解以及拓展，要是想了解这一章，建议读原文，配合这篇博客辅助理解
Linux 哲学

在 Linux 里面，一切皆文件，所有的东西都可以看作一个文件，而凡是文件，都应该支持或者接近POSIX文件操作（比如 read() ，write() ，open()）
每一块内存对象，都可以被看作一个文件，一旦赋予这块内存对象相对应的文件描述，就可以使用像使用普通文件那样子操作内存对象
而这也正是 VFS（虚拟文件系统 virtual file system ，包括内存文件系统以及共享内存管理系统）的设计理念以及实现方向

VMA（virtual memory area）


Linux 内核用vm_area_struct结构体描述某一段连续的虚拟内存区域 VMA（virtual memory area），每个虚拟内存区域 VMA 都有自己的vm_area_struct 结构体


内存描述符 mm_struct 指向进程的整个地址空间，vm_area_struct 只是指向了虚拟空间的一段，这块虚拟内存区域VMA的地址范围为 [vm_start, vm_end) ，左开右闭



vm_area_struct 是由双向链表链接起来的，它们是按照虚拟地址降序排序的，每个这样的结构都对应描述一个地址空间范围


为了快速根据地址找到对应的 VMA，内核对其建立了红黑树索引，红黑树的每个叶子结点就是一个VMA区域，引入红黑树的好处是可以提高查找VMA的效率（即便VMA的数量翻倍，VMA的查找次数也只增加一次）

    
    
    
        
    




之所以通过 VMA 分隔内存区域是因为每个虚拟区间可能来源不同，有的可能来自可执行映像，有的可能来自共享库，而有的可能是动态内存分配的内存区，所以对于每个由 vm_area_struct 结构所描述的区间的处理操作和它前后范围的处理操作不同，因此 linux 把虚拟内存分割管理，并利用了虚拟内存处理例程 vm_ops 来抽象对不同来源虚拟内存的处理方法


不同的虚拟区间其处理操作可能不同，linux 在这里利用了面向对象的思想，即把一个虚拟区间看成是一个对象，用 vm_area_struct 描述这个对象的属性，其中的 vm_operation 结构描述了在这个对象上的操作

    
    
    
        
    




虚拟内存空间管理概括图

    
    
    
        
    

"><meta name=author content="HCY"><link rel=canonical href=https://hcy-asleep.github.io/Linux-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%BB%A5%E5%8F%8A%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bf546705000388ff8f0176e72d11be7c3d4efd591a0430f9c62915164a160ae2.css integrity="sha256-v1RnBQADiP+PAXbnLRG+fD1O/VkaBDD5xikVFkoWCuI=" rel="preload stylesheet" as=style><link rel=icon href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><link rel=apple-touch-icon href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><link rel=mask-icon href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://hcy-asleep.github.io/Linux-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%BB%A5%E5%8F%8A%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><style>@media screen and (min-width:1px){.post-content input[type=checkbox]:checked~label>img{transform:scale(1.6);cursor:zoom-out;position:relative;z-index:999}.post-content img.zoomCheck{transition:transform .15s ease;z-index:999;cursor:zoom-in}}</style><meta property="og:title" content="Linux 虚拟内存文件系统以及共享内存"><meta property="og:description" content="最近看了《Understanding the Linux® Virtual Memory Manager》里面的第十二章 SHARED MEMORY VIRTUAL FILESYSTEM ，对文件系统以及内存文件管理有了更加深入的了解，下面是看了这一章节之后对其中一些概念的理解以及拓展，要是想了解这一章，建议读原文，配合这篇博客辅助理解
Linux 哲学

在 Linux 里面，一切皆文件，所有的东西都可以看作一个文件，而凡是文件，都应该支持或者接近POSIX文件操作（比如 read() ，write() ，open()）
每一块内存对象，都可以被看作一个文件，一旦赋予这块内存对象相对应的文件描述，就可以使用像使用普通文件那样子操作内存对象
而这也正是 VFS（虚拟文件系统 virtual file system ，包括内存文件系统以及共享内存管理系统）的设计理念以及实现方向

VMA（virtual memory area）


Linux 内核用vm_area_struct结构体描述某一段连续的虚拟内存区域 VMA（virtual memory area），每个虚拟内存区域 VMA 都有自己的vm_area_struct 结构体


内存描述符 mm_struct 指向进程的整个地址空间，vm_area_struct 只是指向了虚拟空间的一段，这块虚拟内存区域VMA的地址范围为 [vm_start, vm_end) ，左开右闭



vm_area_struct 是由双向链表链接起来的，它们是按照虚拟地址降序排序的，每个这样的结构都对应描述一个地址空间范围


为了快速根据地址找到对应的 VMA，内核对其建立了红黑树索引，红黑树的每个叶子结点就是一个VMA区域，引入红黑树的好处是可以提高查找VMA的效率（即便VMA的数量翻倍，VMA的查找次数也只增加一次）

    
    
    
        
    




之所以通过 VMA 分隔内存区域是因为每个虚拟区间可能来源不同，有的可能来自可执行映像，有的可能来自共享库，而有的可能是动态内存分配的内存区，所以对于每个由 vm_area_struct 结构所描述的区间的处理操作和它前后范围的处理操作不同，因此 linux 把虚拟内存分割管理，并利用了虚拟内存处理例程 vm_ops 来抽象对不同来源虚拟内存的处理方法


不同的虚拟区间其处理操作可能不同，linux 在这里利用了面向对象的思想，即把一个虚拟区间看成是一个对象，用 vm_area_struct 描述这个对象的属性，其中的 vm_operation 结构描述了在这个对象上的操作

    
    
    
        
    




虚拟内存空间管理概括图

    
    
    
        
    

"><meta property="og:type" content="article"><meta property="og:url" content="https://hcy-asleep.github.io/Linux-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%BB%A5%E5%8F%8A%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"><meta property="og:image" content="https://hcy-asleep.github.io/"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-11-30T19:35:39+00:00"><meta property="article:modified_time" content="2024-11-30T19:35:39+00:00"><meta property="og:site_name" content="HCY-BLOGS"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hcy-asleep.github.io/"><meta name=twitter:title content="Linux 虚拟内存文件系统以及共享内存"><meta name=twitter:description content="最近看了《Understanding the Linux® Virtual Memory Manager》里面的第十二章 SHARED MEMORY VIRTUAL FILESYSTEM ，对文件系统以及内存文件管理有了更加深入的了解，下面是看了这一章节之后对其中一些概念的理解以及拓展，要是想了解这一章，建议读原文，配合这篇博客辅助理解
Linux 哲学

在 Linux 里面，一切皆文件，所有的东西都可以看作一个文件，而凡是文件，都应该支持或者接近POSIX文件操作（比如 read() ，write() ，open()）
每一块内存对象，都可以被看作一个文件，一旦赋予这块内存对象相对应的文件描述，就可以使用像使用普通文件那样子操作内存对象
而这也正是 VFS（虚拟文件系统 virtual file system ，包括内存文件系统以及共享内存管理系统）的设计理念以及实现方向

VMA（virtual memory area）


Linux 内核用vm_area_struct结构体描述某一段连续的虚拟内存区域 VMA（virtual memory area），每个虚拟内存区域 VMA 都有自己的vm_area_struct 结构体


内存描述符 mm_struct 指向进程的整个地址空间，vm_area_struct 只是指向了虚拟空间的一段，这块虚拟内存区域VMA的地址范围为 [vm_start, vm_end) ，左开右闭



vm_area_struct 是由双向链表链接起来的，它们是按照虚拟地址降序排序的，每个这样的结构都对应描述一个地址空间范围


为了快速根据地址找到对应的 VMA，内核对其建立了红黑树索引，红黑树的每个叶子结点就是一个VMA区域，引入红黑树的好处是可以提高查找VMA的效率（即便VMA的数量翻倍，VMA的查找次数也只增加一次）

    
    
    
        
    




之所以通过 VMA 分隔内存区域是因为每个虚拟区间可能来源不同，有的可能来自可执行映像，有的可能来自共享库，而有的可能是动态内存分配的内存区，所以对于每个由 vm_area_struct 结构所描述的区间的处理操作和它前后范围的处理操作不同，因此 linux 把虚拟内存分割管理，并利用了虚拟内存处理例程 vm_ops 来抽象对不同来源虚拟内存的处理方法


不同的虚拟区间其处理操作可能不同，linux 在这里利用了面向对象的思想，即把一个虚拟区间看成是一个对象，用 vm_area_struct 描述这个对象的属性，其中的 vm_operation 结构描述了在这个对象上的操作

    
    
    
        
    




虚拟内存空间管理概括图

    
    
    
        
    

"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hcy-asleep.github.io/post/"},{"@type":"ListItem","position":2,"name":"Linux 虚拟内存文件系统以及共享内存","item":"https://hcy-asleep.github.io/Linux-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%BB%A5%E5%8F%8A%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Linux 虚拟内存文件系统以及共享内存","name":"Linux 虚拟内存文件系统以及共享内存","description":"最近看了《Understanding the Linux® Virtual Memory Manager》里面的第十二章 SHARED MEMORY VIRTUAL FILESYSTEM ，对文件系统以及内存文件管理有了更加深入的了解，下面是看了这一章节之后对其中一些概念的理解以及拓展，要是想了解这一章，建议读原文，配合这篇博客辅助理解\nLinux 哲学 在 Linux 里面，一切皆文件，所有的东西都可以看作一个文件，而凡是文件，都应该支持或者接近POSIX文件操作（比如 read() ，write() ，open()） 每一块内存对象，都可以被看作一个文件，一旦赋予这块内存对象相对应的文件描述，就可以使用像使用普通文件那样子操作内存对象 而这也正是 VFS（虚拟文件系统 virtual file system ，包括内存文件系统以及共享内存管理系统）的设计理念以及实现方向 VMA（virtual memory area） Linux 内核用vm_area_struct结构体描述某一段连续的虚拟内存区域 VMA（virtual memory area），每个虚拟内存区域 VMA 都有自己的vm_area_struct 结构体\n内存描述符 mm_struct 指向进程的整个地址空间，vm_area_struct 只是指向了虚拟空间的一段，这块虚拟内存区域VMA的地址范围为 [vm_start, vm_end) ，左开右闭 vm_area_struct 是由双向链表链接起来的，它们是按照虚拟地址降序排序的，每个这样的结构都对应描述一个地址空间范围\n为了快速根据地址找到对应的 VMA，内核对其建立了红黑树索引，红黑树的每个叶子结点就是一个VMA区域，引入红黑树的好处是可以提高查找VMA的效率（即便VMA的数量翻倍，VMA的查找次数也只增加一次） 之所以通过 VMA 分隔内存区域是因为每个虚拟区间可能来源不同，有的可能来自可执行映像，有的可能来自共享库，而有的可能是动态内存分配的内存区，所以对于每个由 vm_area_struct 结构所描述的区间的处理操作和它前后范围的处理操作不同，因此 linux 把虚拟内存分割管理，并利用了虚拟内存处理例程 vm_ops 来抽象对不同来源虚拟内存的处理方法\n不同的虚拟区间其处理操作可能不同，linux 在这里利用了面向对象的思想，即把一个虚拟区间看成是一个对象，用 vm_area_struct 描述这个对象的属性，其中的 vm_operation 结构描述了在这个对象上的操作 虚拟内存空间管理概括图 ","keywords":[],"articleBody":"最近看了《Understanding the Linux® Virtual Memory Manager》里面的第十二章 SHARED MEMORY VIRTUAL FILESYSTEM ，对文件系统以及内存文件管理有了更加深入的了解，下面是看了这一章节之后对其中一些概念的理解以及拓展，要是想了解这一章，建议读原文，配合这篇博客辅助理解\nLinux 哲学 在 Linux 里面，一切皆文件，所有的东西都可以看作一个文件，而凡是文件，都应该支持或者接近POSIX文件操作（比如 read() ，write() ，open()） 每一块内存对象，都可以被看作一个文件，一旦赋予这块内存对象相对应的文件描述，就可以使用像使用普通文件那样子操作内存对象 而这也正是 VFS（虚拟文件系统 virtual file system ，包括内存文件系统以及共享内存管理系统）的设计理念以及实现方向 VMA（virtual memory area） Linux 内核用vm_area_struct结构体描述某一段连续的虚拟内存区域 VMA（virtual memory area），每个虚拟内存区域 VMA 都有自己的vm_area_struct 结构体\n内存描述符 mm_struct 指向进程的整个地址空间，vm_area_struct 只是指向了虚拟空间的一段，这块虚拟内存区域VMA的地址范围为 [vm_start, vm_end) ，左开右闭 vm_area_struct 是由双向链表链接起来的，它们是按照虚拟地址降序排序的，每个这样的结构都对应描述一个地址空间范围\n为了快速根据地址找到对应的 VMA，内核对其建立了红黑树索引，红黑树的每个叶子结点就是一个VMA区域，引入红黑树的好处是可以提高查找VMA的效率（即便VMA的数量翻倍，VMA的查找次数也只增加一次） 之所以通过 VMA 分隔内存区域是因为每个虚拟区间可能来源不同，有的可能来自可执行映像，有的可能来自共享库，而有的可能是动态内存分配的内存区，所以对于每个由 vm_area_struct 结构所描述的区间的处理操作和它前后范围的处理操作不同，因此 linux 把虚拟内存分割管理，并利用了虚拟内存处理例程 vm_ops 来抽象对不同来源虚拟内存的处理方法\n不同的虚拟区间其处理操作可能不同，linux 在这里利用了面向对象的思想，即把一个虚拟区间看成是一个对象，用 vm_area_struct 描述这个对象的属性，其中的 vm_operation 结构描述了在这个对象上的操作 虚拟内存空间管理概括图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # https://elixir.bootlin.com/linux/v2.6.0/source/include/linux/mm.h#L51 struct vm_area_struct { struct mm_struct * vm_mm;\t/* The address space we belong to. */ unsigned long vm_start;\t/* Our start address within vm_mm. */ unsigned long vm_end;\t/* The first byte after our end address within vm_mm. */ /* linked list of VM areas per task, sorted by address */ struct vm_area_struct *vm_next; pgprot_t vm_page_prot;\t/* Access permissions of this VMA. */ unsigned long vm_flags;\t/* Flags, listed below. */ struct rb_node vm_rb; /* * For areas with an address space and backing store, * one of the address_space-\u003ei_mmap{,shared} lists, * for shm areas, the list of attaches, otherwise unused. */ struct list_head shared; /* Function pointers to deal with this struct. */ struct vm_operations_struct * vm_ops; /* Information about our backing store: */ unsigned long vm_pgoff;\t/* Offset (within vm_file) in PAGE_SIZE units, *not* PAGE_CACHE_SIZE */ struct file * vm_file;\t/* File we map to (can be NULL). */ void * vm_private_data;\t/* was vm_pte (shared mem) */ }; struct address_space 看 linux 内核很容易被 struct address_space 这个结构迷惑，它是代表某个地址空间吗？实际上不是的，它是用于管理文件 struct inode 映射到内存的页面 struct page 的，其实就是每个读入内存的 file 都有这么一个结构，将文件系统中这个 file 对应的数据与这个 file 的磁盘数据与内存页对应起来 与之对应，address_space_operations 就是用来操作该文件映射到内存的页面，比如把内存中的修改写回文件、从文件中读入数据到页面缓冲等 一个具体的文件在打开后，内核会在内存中为之建立一个 struct inode 结构（该 inode 结构也会在对应的 file 结构体中引用），其中的 i_mapping 域指向一个 address_space 结构 一个文件就对应一个 address_space 结构，一个 address_space 与一个偏移量能够确定一个 page cache 或 swap cache 中的一个页面，当要寻址某个数据时，很容易根据给定的文件及数据在文件内的偏移量而找到相应的页面 struct file 和 struct inode 结构体中都有一个 struct address_space 指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # https://elixir.bootlin.com/linux/v2.6.0/source/include/linux/fs.h#L319 struct address_space { struct inode\t*host;\t/* owner: inode, block_device */ struct radix_tree_root\tpage_tree;\t/* radix tree of all pages */ spinlock_t\tpage_lock;\t/* and spinlock protecting it */ struct list_head\tclean_pages;\t/* list of clean pages */ struct list_head\tdirty_pages;\t/* list of dirty pages */ struct list_head\tlocked_pages;\t/* list of locked pages */ struct list_head\tio_pages;\t/* being prepared for I/O */ unsigned long\tnrpages;\t/* number of total pages */ struct address_space_operations *a_ops;\t/* methods */ struct list_head\ti_mmap;\t/* list of private mappings */ struct list_head\ti_mmap_shared;\t/* list of shared mappings */ struct semaphore\ti_shared_sem;\t/* protect both above lists */ atomic_t\ttruncate_count;\t/* Cover race condition with truncate */ unsigned long\tdirtied_when;\t/* jiffies of first page dirtying */ unsigned long\tflags;\t/* error bits/gfp mask */ struct backing_dev_info *backing_dev_info; /* device readahead, etc */ spinlock_t\tprivate_lock;\t/* for use by the address_space */ struct list_head\tprivate_list;\t/* ditto */ struct address_space\t*assoc_mapping;\t/* ditto */ }; 文件系统、文件类型、page 的划分 为了方便理解，在此将文件系统划分为内存文件系统（虚拟文件系统）与硬盘文件系统（物理文件系统），在书的这一章节里面，也将广义上的文件分为 virtual file 和 physical file 在书的这一章节里面，将内存页面 page 划分为 anonymous pages （没有物理文件支持的内存页面）与 pages backed by a file（由物理文件映射到内存的某些 pages） page cache 与 swap cache page cache 是与文件映射对应的，而 swap cache 是与匿名页对应的 如果一个内存页面不是文件映射，则在换入换出的时候加入到 swap cache ，如果是文件映射，则不需要交换缓冲 这两个的相同点就是它们都是 address_space ，都有相对应的文件操作：一个被访问的文件的物理页面都驻留在 page cache 或 swap cache 中，一个页面的所有信息由 struct page 来描述 page cache 作用 当文件被读取时，操作系统会把文件内容加载到内存的 page cache 中 如果同一个文件被再次访问，操作系统会直接从 page cache 中读取，而不是再次从磁盘读取，从而减少磁盘访问次数，提高性能 swap cache 作用 swap cache 缓存的是已经交换到磁盘的数据，它是为了提高交换操作的效率，优化虚拟内存的交换操作 如果内存中再次需要使用这些页面，操作系统会从 swap cache 里面寻找，然后再从 swap 里面查找 同时对于那些刚刚从物理内存里面换出来的 page 以及从 swap 空间读取的 page 也会放在 swap cache 里面 一般情况下用户进程调用 mmap() 时，只是在进程空间内新增了一块相应大小的缓冲区，并设置了相应的访问标识，但并没有建立进程空间到物理页面的映射 因此，第一次访问该空间时，会引发一个缺页异常 对于共享内存映射情况 缺页异常处理程序首先在 swap cache 中寻找目标页（符合 address_space 以及偏移量的物理页） 如果找到，则直接返回地址 如果没有找到，则判断该页是否在交换区 (swap area)，如果在，则执行一个换入操作 如果上述两种情况都不满足，处理程序将分配新的物理页面，并把它插入到 page cache 中，最终将更新进程页表 对于映射普通文件情况（非共享映射） 缺页异常处理程序首先会在 page cache 中根据 address_space 以及数据偏移量寻找相应的页面 如果没有找到，则说明文件数据还没有读入内存，处理程序会从磁盘读入相应的页面，并返回相应地址，同时进程页表也会更新 硬盘（物理）文件系统 在 Linux 文件系统中，dentry（目录项）和 inode（索引节点）是两个核心概念，它们是文件系统内部用于表示和管理文件、目录及其属性的数据结构\ndentry（目录项） dentry 是一个 目录项 的数据结构，它表示文件路径名与文件在文件系统中的位置之间的映射关系 每个 dentry 关联了一个路径组件（如文件夹或文件名），并指向文件系统中的 inode，内核通过逐级解析路径来查找文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct dentry { ...... struct inode * d_inode;\t/* Where the name belongs to - NULL is negative */ ...... struct list_head d_child;\t/* child of parent list */ struct list_head d_subdirs;\t/* our children */ ...... struct qstr d_name; /* file name */ ...... }; struct qstr { const unsigned char * name; unsigned int len; unsigned int hash; char name_str[0]; }; inode（索引节点） inode 是文件系统中用于描述文件或目录的元数据的数据结构，是文件的唯一标识符，除了文件名之外，它包含了文件的所有信息，例如： 文件类型（普通文件、目录、符号链接等） 文件权限（读、写、执行权限） 文件所有者和用户组 文件大小 文件的时间戳（创建时间、修改时间、访问时间） 文件数据块的位置（指向数据块的指针），包括直接块指针 i_direct 与间接块指针 i_indirect inode 指向文件在磁盘上的物理位置，帮助操作系统定位文件数据块，从而实现文件的读取和写入 i_nlink i_nlink 是一个存储在 inode 结构中的字段，表示指向该 inode 的硬链接数量 对于普通文件 i_nlink 记录的是指向该文件的硬链接数，也就是说，文件的 i_nlink 是表示有多少个目录项指向该文件的 inode 每当创建一个新文件时，系统会为该文件分配一个 inode,而文件的 i_nlink 初始值为 1，这个 1 代表着自己 对于目录 i_nlink 记录的是指向该目录的硬链接数，它的值还与子目录的存在有关 每创建一个子目录，父目录的 i_nlink 会增加 每个子目录的 inode 被创建时，父目录的 nlink 会增加 1，因为子目录会有一个指向父目录的硬链接（即 .. 链接） dentry 和 inode 的关系 关联性 每个 dentry 对应一个路径组件（例如某个文件或目录的名称），并且每个 dentry 都指向一个 inode 通过 inode，操作系统可以找到文件的实际数据，而 dentry 则是通过文件名来指向 inode 换句话说，dentry 提供了文件路径到文件数据位置（即 inode）的映射关系 路径解析 当一个路径被访问时，内核会逐步解析路径中的每个目录项（dentry），通过目录项找到对应的 inode 每个目录项（dentry）都存储了一个指向对应 inode 的指针 当最终解析到文件名时，内核通过该 inode 获取文件的元数据并定位文件数据块 缓存机制 为了提高性能，内核会缓存路径名和 inode 之间的映射关系，这样在访问同一个文件或目录时，可以避免重复解析路径 用 dentry 构建“多叉树”文件系统 在 Linux 内核中只需要用到 struct list_head d_child 和 struct list_head d_subdirs 这两个两个关键双向链表就可以实现目录树结构\n1 2 3 4 5 6 7 8 9 10 struct dentry { ...... struct list_head d_child;\t/* child of parent list */ struct list_head d_subdirs;\t/* our children */ ...... }; struct list_head { struct list_head *next, *prev; }; d_child\n表示当前目录项在父目录的子项链表中的位置 它连接到父目录的 d_subdirs 链表，用于形成目录树中的父子关系 d_child -\u003e prev 为父目录或者兄弟 d_child -\u003e next 为兄弟或者 NULL d_subdirs\n表示当前目录的子目录和文件列表 用于遍历当前目录下的所有子项 当前目录下的每个子项（文件或子目录）的 d_child 都会被挂接到 d_subdirs 链表中 d_subdirs -\u003e prev 为 NULL d_subdirs -\u003e next 为当前目录下第一个孩子或者 NULL 在当前目录新建文件时，创建的文件会以头插法插到 d_subdirs -\u003e next d_subdirs 与 d_child 配合\nd_subdirs 维护子项列表，d_child 链接到父目录的子项链表，形成一个双向链表结构的目录树 假设文件系统目录结构如下：\n1 2 3 4 5 6 / ├── home/ │ ├── user/ │ │ ├── file1 │ │ └── documents/ └── etc/ 那么它们之间的链表关系图应该是这样子的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 (root /) d_child d_subdirs + | +--\u003e (home) d_child | d_subdirs | + | | | +--\u003e (user) d_child | d_subdirs | + | | | +--\u003e (file1) d_child | | | +--\u003e (documents) d_child | +--\u003e (etc) d_child 现在还剩下最后一个问题，d_subdirs 是 list_head 类型的数据结构，它本身只包含两个指针：next 和 prev，应该如何通过 list_head 找到包含它的 struct dentry 呢？\n在内核里面，实现这个目标需要依赖嵌套结构和偏移量计算\n而这一步的关键函数是 contianer_of\n1 2 #define container_of(ptr, type, member) \\ ((type *)((char *)(ptr) - offsetof(type, member))) 在 dentry 这个场景下，container_of 里面的各个参数可以这样子理解\nptr ：list_head 指针，例如 \u0026dir-\u003ed_subdirs type：包含 list_head 的结构体类型（这里是 struct dentry） member：list_head 字段在结构体中的名字（这里是 d_subdirs） offsetof(type, member)：获取 member 在 type 中的偏移量，通过 ptr 减去 member 的偏移量，计算出结构体的起始地址 删除目录 在文件系统中，删除一个目录时，内核会使用深度优先算法递归地删除该目录下的所有文件和子目录 tmpfs 与 shm 联系 shm introduction shm 是 Linux 内核内部实现匿名内存共享的机制，主要为内核服务，不对用户直接可见 shm 最初设计是为支持 POSIX 共享内存（如 shm_open）和 System V 共享内存（如 shmget），共享内存需要一个临时的、内存驻留的文件系统来存储共享的内存页 shm 为匿名页面提供统一的文件支持接口，使内核可以用文件操作函数（如 readpage 或 writepage）管理这些页面，实现匿名共享内存（如通过 mmap 创建的 MAP_ANONYMOUS | MAP_SHARED 区域）和 System V 共享内存（shmget） shm 对虚拟文件的描述都是使用 shmem_inode_info （ shmem_inode_info 可以看作 inode 的继承，在内存文件系统里面如果要创建一个文件，要先向系统申请一个 inode ，然后才是将这个 inode 传给 shmem_inode_info ，有点类似 C++ 里面的当一个子类要实例化的时候需要先实例化父类） 1 2 3 4 5 6 7 8 9 10 11 12 // https://elixir.bootlin.com/linux/v2.6.0/source/include/linux/shmem_fs.h#L10 struct shmem_inode_info { spinlock_t\tlock; unsigned long\tnext_index; swp_entry_t\ti_direct[SHMEM_NR_DIRECT]; /* for the first blocks */ struct page\t*i_indirect; /* indirect blocks */ unsigned long\talloced; /* data pages allocated to file */ unsigned long\tswapped; /* subtotal assigned to swap */ unsigned long\tflags; struct list_head\tlist; struct inode\tvfs_inode; }; tmpfs introduction tmpfs 是面向用户的、通用的基于内存的文件系统，使用 RAM 作为存储媒介，用于提供临时存储和共享内存功能，能够通过挂载点提供更多功能 tmpfs 的核心实现文件在内核的 shm.c，tmpfs 的许多功能，包括内存页的管理、inode 的创建和操作等，都在这个文件中实现 tmpfs 的核心实现源自于 shm shm 在通常语境下确实是共享内存（shared memory）的缩写，但在 Linux 内核中，shmem 指的是一个更通用的机制，既用于共享内存，也为 tmpfs 提供支持，这源于 Linux 内核设计中对内存管理的统一抽象 shm 这个名字更多反映了其历史背景，由最初支持共享内存机制的主要目标，到后来逐渐扩展到支持 tmpfs 随着 tmpfs 的引入，Linux 直接复用了 shmem 的基础设施，因为它们的核心需求一致：一种无持久存储后端、基于内存的文件系统 因此 shm 这种命名并不是严格意义上的“共享内存”限定，而是一个历史遗留的名字 当使用 tmpfs 或共享内存时，内核实际上都在调用 shmem 相关的功能，换句话说，tmpfs 和共享内存是同一个机制在不同场景下的两个应用实例 shmem 和 tmpfs 核心需求一致： 动态分配页（在需要时为文件或共享内存段分配内存页） 支持按需增长（tmpfs 文件或共享内存段会随内容增长） 内存页面可以被回收或写入交换分区（swapping） shmem 是底层机制，最初服务于共享内存需求 tmpfs 是基于 shmem 的一个文件系统实现，扩展了其使用场景，支持临时文件存储 tmpfs 的诞生得益于 shmem 的存在，是共享内存技术的一次成功复用 shm 使用 System V 共享内存\n1 2 3 4 5 // 使用 `shmget` 和 `shmat` 创建的共享内存段，通过 `shm` 提供底层支持 int shmid = shmget(IPC_PRIVATE, 1024, IPC_CREAT | 0666); char *data = shmat(shmid, NULL, 0); strcpy(data, \"Hello, shm!\"); printf(\"Data in shared memory: %s\\n\", data); 匿名共享内存\n1 2 3 4 5 6 7 8 9 10 // 当进程调用 `mmap` 并指定 `MAP_ANONYMOUS | MAP_SHARED` 时，`shm` 会为这些匿名页面创建支持 size_t size = 4096; // 分配一个4KB的内存区域 void *addr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0); if (addr == MAP_FAILED) { perror(\"mmap failed\"); return 1; } // 通过指针访问并修改匿名共享内存 int *data = (int *)addr; 使用 POSIX 文件接口与 shm 结合\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 const char *shm_name = \"/my_shm\"; // 共享内存对象的名称 size_t size = 4096; // 共享内存的大小 // 创建或打开共享内存对象 // 使用 shm_open() 创建或打开共享内存对象后，返回的文件描述符可以通过 open() 进行访问 int shm_fd = shm_open(shm_name, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR); if (shm_fd == -1) { perror(\"shm_open\"); return 1; } // 设置共享内存的大小 if (ftruncate(shm_fd, size) == -1) { perror(\"ftruncate\"); return 1; } // 将共享内存映射到进程的地址空间 void *shm_ptr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0); if (shm_ptr == MAP_FAILED) { perror(\"mmap\"); return 1; } // 使用共享内存 // 写入数据到共享内存 snprintf((char *)shm_ptr, size, \"Hello from shared memory!\"); // 解除映射 if (munmap(shm_ptr, size) == -1) { perror(\"munmap\"); return 1; } // 关闭共享内存对象 close(shm_fd); tmpfs 使用 tmpfs 默认挂载到 /tmp，为用户提供快速的、基于 RAM 的临时文件存储空间，读写速度快，它也可以手动挂载到其他地方 1 2 3 4 5 6 7 8 9 # 在 /mnt/tmpfs 挂载一个 tmpfs 文件系统 sudo mount -t tmpfs -o size=128M tmpfs /mnt/tmpfs # 在 tmpfs 上创建文件 echo \"Hello, tmpfs!\" \u003e /mnt/tmpfs/testfile cat /mnt/tmpfs/testfile # 卸载 tmpfs sudo umount /mnt/tmpfs tmpfs 也可以使用多进程 open 或者多进程 mmap 到一个共同的 tmpfs 文件达到进程间通信的效果 1 2 3 int fd = open(\"example.txt\", O_RDONLY); char *mapped = mmap(NULL, 4096, PROT_READ, MAP_PRIVATE, fd, 0); close(fd); 观察真实机器上的 tmpfs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 hcy@debian:~$ df -h 文件系统 大小 已用 可用 已用% 挂载点 udev 32G 0 32G 0% /dev tmpfs 6.3G 1.9M 6.3G 1% /run /dev/sdb1 119G 29G 91G 25% / tmpfs 32G 550M 31G 2% /dev/shm tmpfs 5.0M 12K 5.0M 1% /run/lock tmpfs 32G 96M 32G 1% /tmp /dev/sdb2 300M 5.9M 294M 2% /boot/efi /dev/sda2 900G 218G 682G 25% /mnt/146bf4b9-b9ad-486d-811c-dcbb31aa3324 tmpfs 6.3G 256K 6.3G 1% /run/user/1000 hcy@debian:~$ id hcy uid=1000(hcy) gid=1000(hcy) 组=1000(hcy), ... 在上面的 df -h 输出中，列出了多个 tmpfs 挂载点 /run: tmpfs 被挂载在 /run 目录。它是一个动态的、短期的文件系统，用于存储系统运行时的数据（如进程 ID 文件、锁文件等）\n/dev/shm: tmpfs 被挂载在 /dev/shm 目录，它是共享内存的挂载点，供进程间通信使用\n/run/lock: tmpfs 被挂载在 /run/lock 目录，用于存放进程间锁文件\n/tmp: tmpfs 被挂载在 /tmp 目录，用于存放临时文件\n/run/user/1000: 该 tmpfs 是为用户 ID 为 1000 的用户（也就是用户 hcy ）提供的临时文件系统，用于存储用户的运行时数据，如程序缓存、临时文件等\n这些 tmpfs 挂载点的数据在机器重启之后都不会存在 观察容器里面的 tmpfs 在 Docker 中，容器的文件系统是基于 UnionFS（联合文件系统）的，通常采用的是 aufs、overlay 或 overlay2 等文件系统，而UnionFS 并不直接使用 tmpfs，除非明确将某些目录挂载为 tmpfs Docker 容器的文件系统是持久化的，在容器中文件存储在镜像层 read-only layer 和容器层 read-write layer 上 默认情况下，当容器重启时，容器层会保持不变，即使写入到 /tmp 目录的文件，都会保存在容器层中，而不是丢失 只有在宿主机层面在容器创建时，通过 --tmpfs 参数来指定将 /tmp 挂载为 tmpfs，才有可能让容器里面的 /tmp 的表现和常规的一样 1 docker run --tmpfs /tmp 全局共享的零页（global zero page） Linux 内核中有一个全局共享的零页，所有字节都被初始化为零，这块内存页被全局所有进程共享，通常是只读的，多进程可以同时访问 当一个进程需要访问大量的全零数据（如未初始化的内存、扩展文件的空白部分），可以直接映射到全局零页，而无需实际分配和初始化物理内存，避免为每个进程单独分配一块全零的内存页 例如当文件通过 truncate() 扩展时，新增加的部分需要初始化为零。如果直接写零到磁盘或内存，会消耗资源 通过全局零页，文件系统可以将新增加的部分映射到这块零页，而不需要实际分配和初始化 又例如进程分配内存时，未使用的部分（例如通过 mmap 映射的匿名内存）通常被映射为零页，直到实际写入数据为止 由于零页是只读的，如果进程试图写入零页，会触发页错误 page fault，内核会复制一块新的物理页供进程使用，这叫做“写时复制” Copy-on-Write, COW ","wordCount":"1682","inLanguage":"zh","image":"https://hcy-asleep.github.io/","datePublished":"2024-11-30T19:35:39Z","dateModified":"2024-11-30T19:35:39Z","author":{"@type":"Person","name":"HCY"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://hcy-asleep.github.io/Linux-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%BB%A5%E5%8F%8A%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"},"publisher":{"@type":"Organization","name":"Memos","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://hcy-asleep.github.io/ accesskey=h title="主页 (Alt + H)">主页</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://hcy-asleep.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://hcy-asleep.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://hcy-asleep.github.io/categories/ title=目录><span>目录</span></a></li><li><a href=https://hcy-asleep.github.io/friends/ title=友链><span>友链</span></a></li><li><a href=https://hcy-asleep.github.io/todo/ title=TODO><span>TODO</span></a></li><li><a href=https://hcy-asleep.github.io/about/ title=关于><span>关于</span></a></li><li><a href=https://hcy-asleep.github.io/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://hcy-asleep.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://hcy-asleep.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Linux 虚拟内存文件系统以及共享内存</h1><div class=post-meta><span title='2024-11-30 19:35:39 +0000 UTC'>十一月 30, 2024</span>&nbsp;·&nbsp;8 分钟&nbsp;·&nbsp;1682 字&nbsp;·&nbsp;HCY&nbsp;|&nbsp;<a href=https://github.com/HCY-ASLEEP rel="noopener noreferrer" target=_blank> Follow me</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#linux-哲学>Linux 哲学</a></li><li><a href=#vmavirtual-memory-area>VMA（virtual memory area）</a></li><li><a href=#struct-address_space><code>struct address_space</code></a></li><li><a href=#文件系统文件类型page-的划分>文件系统、文件类型、<code>page</code> 的划分</a></li><li><a href=#page-cache-与-swap-cache><code>page cache</code> 与 <code>swap cache</code></a></li><li><a href=#硬盘物理文件系统>硬盘（物理）文件系统</a><ul><li><a href=#dentry目录项><code>dentry</code>（目录项）</a></li><li><a href=#inode索引节点><code>inode</code>（索引节点）</a></li><li><a href=#i_nlink><code>i_nlink</code></a></li><li><a href=#dentry-和-inode-的关系><code>dentry</code> 和 <code>inode</code> 的关系</a></li><li><a href=#用-dentry-构建多叉树文件系统>用 <code>dentry</code> 构建“多叉树”文件系统</a></li><li><a href=#删除目录>删除目录</a></li></ul></li><li><a href=#tmpfs-与-shm-联系><code>tmpfs</code> 与 <code>shm</code> 联系</a><ul><li><a href=#shm-introduction><code>shm</code> introduction</a></li><li><a href=#tmpfs-introduction><code>tmpfs</code> introduction</a></li><li><a href=#tmpfs-的核心实现源自于-shm><code>tmpfs</code> 的核心实现源自于 <code>shm</code></a></li></ul></li><li><a href=#shm-使用><code>shm</code> 使用</a></li><li><a href=#tmpfs-使用><code>tmpfs</code> 使用</a><ul><li><a href=#观察真实机器上的-tmpfs>观察真实机器上的 <code>tmpfs</code></a></li><li><a href=#观察容器里面的-tmpfs>观察容器里面的 <code>tmpfs</code></a></li></ul></li><li><a href=#全局共享的零页global-zero-page>全局共享的零页（global zero page）</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>最近看了<a href=https://pdos.csail.mit.edu/~sbw/links/gorman_book.pdf>《Understanding the Linux® Virtual Memory Manager》</a>里面的第十二章 <strong>SHARED MEMORY VIRTUAL FILESYSTEM</strong> ，对文件系统以及内存文件管理有了更加深入的了解，下面是看了这一章节之后对其中一些概念的理解以及拓展，要是想了解这一章，<a href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/gordan-book-linux-vmm12-chap.pdf>建议读原文</a>，配合这篇博客辅助理解</p><h2 id=linux-哲学>Linux 哲学<a hidden class=anchor aria-hidden=true href=#linux-哲学>#</a></h2><ul><li>在 Linux 里面，一切皆文件，所有的东西都可以看作一个文件，而凡是文件，都应该支持或者接近<code>POSIX</code>文件操作（比如 <code>read()</code> ，<code>write()</code> ，<code>open()</code>）</li><li>每一块内存对象，都可以被看作一个文件，一旦赋予这块内存对象相对应的文件描述，就可以使用像使用普通文件那样子操作内存对象</li><li>而这也正是 <code>VFS</code>（虚拟文件系统 <code>virtual file system</code> ，包括内存文件系统以及共享内存管理系统）的设计理念以及实现方向</li></ul><h2 id=vmavirtual-memory-area>VMA（virtual memory area）<a hidden class=anchor aria-hidden=true href=#vmavirtual-memory-area>#</a></h2><ul><li><p>Linux 内核用<code>vm_area_struct</code>结构体描述某一段连续的虚拟内存区域 <code>VMA（virtual memory area）</code>，每个虚拟内存区域 <code>VMA</code> 都有自己的<code>vm_area_struct</code> 结构体</p></li><li><p>内存描述符 <code>mm_struct</code> 指向进程的整个地址空间，<code>vm_area_struct</code> 只是指向了虚拟空间的一段，这块虚拟内存区域VMA的地址范围为 <code>[vm_start, vm_end)</code> ，左开右闭
<img src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/v2-426557bb4eb1e7044bd649483942c2ad_r.jpg width=55%></p></li><li><p><code>vm_area_struct</code> 是由双向链表链接起来的，它们是按照虚拟地址降序排序的，每个这样的结构都对应描述一个地址空间范围</p></li><li><p>为了快速根据地址找到对应的 <code>VMA</code>，内核对其建立了红黑树索引，红黑树的每个叶子结点就是一个VMA区域，引入红黑树的好处是可以提高查找VMA的效率（即便VMA的数量翻倍，VMA的查找次数也只增加一次）
<input type=checkbox id=zoomCheck-b4749 hidden>
<label for=zoomCheck-b4749><img class=zoomCheck loading=lazy decoding=async src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/v2-82dec5bde95009f934d3978c15412626_1440w.jpg alt></label></p></li><li><p>之所以通过 <code>VMA</code> 分隔内存区域是因为每个虚拟区间可能来源不同，有的可能来自可执行映像，有的可能来自共享库，而有的可能是动态内存分配的内存区，所以对于每个由 <code>vm_area_struct</code> 结构所描述的区间的处理操作和它前后范围的处理操作不同，因此 linux 把虚拟内存分割管理，并利用了虚拟内存处理例程 <code>vm_ops</code> 来抽象对不同来源虚拟内存的处理方法</p></li><li><p>不同的虚拟区间其处理操作可能不同，<code>linux</code> 在这里利用了面向对象的思想，即把一个虚拟区间看成是一个对象，用 <code>vm_area_struct</code> 描述这个对象的属性，其中的 <code>vm_operation</code> 结构描述了在这个对象上的操作
<input type=checkbox id=zoomCheck-53ba1 hidden>
<label for=zoomCheck-53ba1><img class=zoomCheck loading=lazy decoding=async src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/v2-ce0aa70282615def188d51d5ee745e14_1440w.jpg alt></label></p></li><li><p>虚拟内存空间管理概括图
<input type=checkbox id=zoomCheck-a1d4d hidden>
<label for=zoomCheck-a1d4d><img class=zoomCheck loading=lazy decoding=async src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/v2-410e447557fe925077f0580463875666_r.jpg alt></label></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp># https:</span><span class=c1>//elixir.bootlin.com/linux/v2.6.0/source/include/linux/mm.h#L51
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>vm_area_struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=nc>mm_struct</span> <span class=o>*</span> <span class=n>vm_mm</span><span class=p>;</span>	<span class=cm>/* The address space we belong to. */</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>vm_start</span><span class=p>;</span>		<span class=cm>/* Our start address within vm_mm. */</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>vm_end</span><span class=p>;</span>		<span class=cm>/* The first byte after our end address
</span></span></span><span class=line><span class=cl><span class=cm>					   within vm_mm. */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/* linked list of VM areas per task, sorted by address */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=nc>vm_area_struct</span> <span class=o>*</span><span class=n>vm_next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>pgprot_t</span> <span class=n>vm_page_prot</span><span class=p>;</span>		<span class=cm>/* Access permissions of this VMA. */</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>vm_flags</span><span class=p>;</span>		<span class=cm>/* Flags, listed below. */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=nc>rb_node</span> <span class=n>vm_rb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>	 * For areas with an address space and backing store,
</span></span></span><span class=line><span class=cl><span class=cm>	 * one of the address_space-&gt;i_mmap{,shared} lists,
</span></span></span><span class=line><span class=cl><span class=cm>	 * for shm areas, the list of attaches, otherwise unused.
</span></span></span><span class=line><span class=cl><span class=cm>	 */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=nc>list_head</span> <span class=n>shared</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/* Function pointers to deal with this struct. */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=nc>vm_operations_struct</span> <span class=o>*</span> <span class=n>vm_ops</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/* Information about our backing store: */</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>vm_pgoff</span><span class=p>;</span>		<span class=cm>/* Offset (within vm_file) in PAGE_SIZE
</span></span></span><span class=line><span class=cl><span class=cm>					   units, *not* PAGE_CACHE_SIZE */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=nc>file</span> <span class=o>*</span> <span class=n>vm_file</span><span class=p>;</span>		<span class=cm>/* File we map to (can be NULL). */</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=o>*</span> <span class=n>vm_private_data</span><span class=p>;</span>		<span class=cm>/* was vm_pte (shared mem) */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h2 id=struct-address_space><code>struct address_space</code><a hidden class=anchor aria-hidden=true href=#struct-address_space>#</a></h2><ul><li>看 <code>linux</code> 内核很容易被 <code>struct address_space</code> 这个结构迷惑，它是代表某个地址空间吗？实际上不是的，它是用于管理文件 <code>struct inode</code> 映射到内存的页面 <code>struct page</code> 的，其实就是每个读入内存的 <code>file</code> 都有这么一个结构，将文件系统中这个 <code>file</code> 对应的数据与这个 <code>file</code> 的磁盘数据与内存页对应起来</li><li>与之对应，<code>address_space_operations</code> 就是用来操作该文件映射到内存的页面，比如把内存中的修改写回文件、从文件中读入数据到页面缓冲等
<input type=checkbox id=zoomCheck-40bbb hidden>
<label for=zoomCheck-40bbb><img class=zoomCheck loading=lazy decoding=async src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/v2-ea46cfd3a0c3770c593db4e4f4dfc597_1440w.jpg alt></label></li><li>一个具体的文件在打开后，内核会在内存中为之建立一个 <code>struct inode</code> 结构（该 <code>inode</code> 结构也会在对应的 <code>file</code> 结构体中引用），其中的 <code>i_mapping</code> 域指向一个 <code>address_space</code> 结构</li><li>一个文件就对应一个 <code>address_space</code> 结构，一个 <code>address_space</code> 与一个偏移量能够确定一个 <code>page cache</code> 或 <code>swap cache</code> 中的一个页面，当要寻址某个数据时，很容易根据给定的文件及数据在文件内的偏移量而找到相应的页面</li><li><code>struct file</code> 和 <code>struct inode</code> 结构体中都有一个 <code>struct address_space</code> 指针<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp># https:</span><span class=c1>//elixir.bootlin.com/linux/v2.6.0/source/include/linux/fs.h#L319
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>address_space</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=nc>inode</span>		<span class=o>*</span><span class=n>host</span><span class=p>;</span>		<span class=cm>/* owner: inode, block_device */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=nc>radix_tree_root</span>	<span class=n>page_tree</span><span class=p>;</span>	<span class=cm>/* radix tree of all pages */</span>
</span></span><span class=line><span class=cl>	<span class=n>spinlock_t</span>		<span class=n>page_lock</span><span class=p>;</span>	<span class=cm>/* and spinlock protecting it */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=nc>list_head</span>	<span class=n>clean_pages</span><span class=p>;</span>	<span class=cm>/* list of clean pages */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=nc>list_head</span>	<span class=n>dirty_pages</span><span class=p>;</span>	<span class=cm>/* list of dirty pages */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=nc>list_head</span>	<span class=n>locked_pages</span><span class=p>;</span>	<span class=cm>/* list of locked pages */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=nc>list_head</span>	<span class=n>io_pages</span><span class=p>;</span>	<span class=cm>/* being prepared for I/O */</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span>		<span class=n>nrpages</span><span class=p>;</span>	<span class=cm>/* number of total pages */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=nc>address_space_operations</span> <span class=o>*</span><span class=n>a_ops</span><span class=p>;</span>	<span class=cm>/* methods */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=nc>list_head</span>	<span class=n>i_mmap</span><span class=p>;</span>		<span class=cm>/* list of private mappings */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=nc>list_head</span>	<span class=n>i_mmap_shared</span><span class=p>;</span>	<span class=cm>/* list of shared mappings */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=nc>semaphore</span>	<span class=n>i_shared_sem</span><span class=p>;</span>	<span class=cm>/* protect both above lists */</span>
</span></span><span class=line><span class=cl>	<span class=n>atomic_t</span>		<span class=n>truncate_count</span><span class=p>;</span>	<span class=cm>/* Cover race condition with truncate */</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span>		<span class=n>dirtied_when</span><span class=p>;</span>	<span class=cm>/* jiffies of first page dirtying */</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span>		<span class=n>flags</span><span class=p>;</span>		<span class=cm>/* error bits/gfp mask */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=nc>backing_dev_info</span> <span class=o>*</span><span class=n>backing_dev_info</span><span class=p>;</span> <span class=cm>/* device readahead, etc */</span>
</span></span><span class=line><span class=cl>	<span class=n>spinlock_t</span>		<span class=n>private_lock</span><span class=p>;</span>	<span class=cm>/* for use by the address_space */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=nc>list_head</span>	<span class=n>private_list</span><span class=p>;</span>	<span class=cm>/* ditto */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=nc>address_space</span>	<span class=o>*</span><span class=n>assoc_mapping</span><span class=p>;</span>	<span class=cm>/* ditto */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h2 id=文件系统文件类型page-的划分>文件系统、文件类型、<code>page</code> 的划分<a hidden class=anchor aria-hidden=true href=#文件系统文件类型page-的划分>#</a></h2><ul><li>为了方便理解，在此将文件系统划分为内存文件系统（虚拟文件系统）与硬盘文件系统（物理文件系统），在书的这一章节里面，也将广义上的文件分为 <code>virtual file</code> 和 <code>physical file</code></li><li>在书的这一章节里面，将内存页面 <code>page</code> 划分为 <code>anonymous pages</code> （没有物理文件支持的内存页面）与 <code>pages backed by a file</code>（由物理文件映射到内存的某些 <code>pages</code>）</li></ul><h2 id=page-cache-与-swap-cache><code>page cache</code> 与 <code>swap cache</code><a hidden class=anchor aria-hidden=true href=#page-cache-与-swap-cache>#</a></h2><ul><li><code>page cache</code> 是与文件映射对应的，而 <code>swap cache</code> 是与匿名页对应的</li><li>如果一个内存页面不是文件映射，则在换入换出的时候加入到 <code>swap cache</code> ，如果是文件映射，则不需要交换缓冲</li><li>这两个的相同点就是它们都是 <code>address_space</code> ，都有相对应的文件操作：一个被访问的文件的物理页面都驻留在 <code>page cache</code> 或 <code>swap cache</code> 中，一个页面的所有信息由 <code>struct page</code> 来描述</li><li><code>page cache</code> 作用<ul><li>当文件被读取时，操作系统会把文件内容加载到内存的 <code>page cache</code> 中</li><li>如果同一个文件被再次访问，操作系统会直接从 <code>page cache</code> 中读取，而不是再次从磁盘读取，从而减少磁盘访问次数，提高性能</li></ul></li><li><code>swap cache</code> 作用<ul><li><code>swap cache</code> 缓存的是已经交换到磁盘的数据，它是为了提高交换操作的效率，优化虚拟内存的交换操作</li><li>如果内存中再次需要使用这些页面，操作系统会从 <code>swap cache</code> 里面寻找，然后再从 <code>swap</code> 里面查找</li><li>同时对于那些刚刚从物理内存里面换出来的 <code>page</code> 以及从 <code>swap</code> 空间读取的 <code>page</code> 也会放在 <code>swap cache</code> 里面</li></ul></li><li>一般情况下用户进程调用 <code>mmap()</code> 时，只是在进程空间内新增了一块相应大小的缓冲区，并设置了相应的访问标识，但并没有建立进程空间到物理页面的映射</li><li>因此，第一次访问该空间时，会引发一个缺页异常</li><li>对于共享内存映射情况<ul><li>缺页异常处理程序首先在 <code>swap cache</code> 中寻找目标页（符合 <code>address_space</code> 以及偏移量的物理页）</li><li>如果找到，则直接返回地址</li><li>如果没有找到，则判断该页是否在交换区 (<code>swap area</code>)，如果在，则执行一个换入操作</li><li>如果上述两种情况都不满足，处理程序将分配新的物理页面，并把它插入到 <code>page cache</code> 中，最终将更新进程页表</li></ul></li><li>对于映射普通文件情况（非共享映射）<ul><li>缺页异常处理程序首先会在 <code>page cache</code> 中根据 <code>address_space</code> 以及数据偏移量寻找相应的页面</li><li>如果没有找到，则说明文件数据还没有读入内存，处理程序会从磁盘读入相应的页面，并返回相应地址，同时进程页表也会更新</li></ul></li></ul><h2 id=硬盘物理文件系统>硬盘（物理）文件系统<a hidden class=anchor aria-hidden=true href=#硬盘物理文件系统>#</a></h2><p>在 Linux 文件系统中，<code>dentry</code>（目录项）和 <code>inode</code>（索引节点）是两个核心概念，它们是文件系统内部用于表示和管理文件、目录及其属性的数据结构</p><h3 id=dentry目录项><code>dentry</code>（目录项）<a hidden class=anchor aria-hidden=true href=#dentry目录项>#</a></h3><ul><li><code>dentry</code> 是一个 <code>目录项</code> 的数据结构，它表示文件<code>路径名</code>与文件在文件系统中的<code>位置</code>之间的映射关系</li><li>每个 <code>dentry</code> 关联了一个路径组件（如文件夹或文件名），并指向文件系统中的 <code>inode</code>，内核通过逐级解析路径来查找文件<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>dentry</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  	<span class=p>......</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>inode</span>  <span class=o>*</span> <span class=n>d_inode</span><span class=p>;</span>	<span class=cm>/* Where the name belongs to - NULL is negative */</span>
</span></span><span class=line><span class=cl>  	<span class=p>......</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>list_head</span> <span class=n>d_child</span><span class=p>;</span>	<span class=cm>/* child of parent list */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>list_head</span> <span class=n>d_subdirs</span><span class=p>;</span>	<span class=cm>/* our children */</span>
</span></span><span class=line><span class=cl>  	<span class=p>......</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>qstr</span> <span class=n>d_name</span><span class=p>;</span> <span class=cm>/* file name */</span>
</span></span><span class=line><span class=cl>  	<span class=p>......</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>qstr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>hash</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>name_str</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=inode索引节点><code>inode</code>（索引节点）<a hidden class=anchor aria-hidden=true href=#inode索引节点>#</a></h3><ul><li><code>inode</code> 是文件系统中用于描述文件或目录的元数据的数据结构，是文件的唯一标识符，除了文件名之外，它包含了文件的所有信息，例如：<ul><li>文件类型（普通文件、目录、符号链接等）</li><li>文件权限（读、写、执行权限）</li><li>文件所有者和用户组</li><li>文件大小</li><li>文件的时间戳（创建时间、修改时间、访问时间）</li><li>文件数据块的位置（指向数据块的指针），包括直接块指针 <code>i_direct</code> 与间接块指针 <code>i_indirect</code>
<input type=checkbox id=zoomCheck-9e829 hidden>
<label for=zoomCheck-9e829><img class=zoomCheck loading=lazy decoding=async src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/474a5adb633c970271b49623e4cad41b.png alt></label></li></ul></li><li><code>inode</code> 指向文件在磁盘上的物理位置，帮助操作系统定位文件数据块，从而实现文件的读取和写入</li></ul><h3 id=i_nlink><code>i_nlink</code><a hidden class=anchor aria-hidden=true href=#i_nlink>#</a></h3><ul><li><code>i_nlink</code> 是一个存储在 <code>inode</code> 结构中的字段，表示指向该 <code>inode</code> 的硬链接数量</li><li>对于普通文件<ul><li><code>i_nlink</code> 记录的是指向该文件的硬链接数，也就是说，文件的 <code>i_nlink</code> 是表示有多少个目录项指向该文件的 <code>inode</code></li><li>每当创建一个新文件时，系统会为该文件分配一个 <code>inode</code>,而文件的 <code>i_nlink</code> 初始值为 1，这个 <code>1</code> 代表着自己</li></ul></li><li>对于目录<ul><li><code>i_nlink</code> 记录的是指向该目录的硬链接数，它的值还与子目录的存在有关</li><li>每创建一个子目录，父目录的 <code>i_nlink</code> 会增加</li><li>每个子目录的 <code>inode</code> 被创建时，父目录的 <code>nlink</code> 会增加 1，因为子目录会有一个指向父目录的硬链接（即 <code>..</code> 链接）</li></ul></li></ul><h3 id=dentry-和-inode-的关系><code>dentry</code> 和 <code>inode</code> 的关系<a hidden class=anchor aria-hidden=true href=#dentry-和-inode-的关系>#</a></h3><ul><li>关联性<ul><li>每个 <code>dentry</code> 对应一个路径组件（例如某个文件或目录的名称），并且每个 <code>dentry</code> 都指向一个 <code>inode</code></li><li>通过 <code>inode</code>，操作系统可以找到文件的实际数据，而 <code>dentry</code> 则是通过文件名来指向 <code>inode</code></li><li>换句话说，<code>dentry</code> 提供了文件路径到文件数据位置（即 <code>inode</code>）的映射关系</li></ul></li><li>路径解析<ul><li>当一个路径被访问时，内核会逐步解析路径中的每个目录项（<code>dentry</code>），通过目录项找到对应的 <code>inode</code></li><li>每个目录项（<code>dentry</code>）都存储了一个指向对应 <code>inode</code> 的指针</li><li>当最终解析到文件名时，内核通过该 <code>inode</code> 获取文件的元数据并定位文件数据块</li></ul></li><li>缓存机制<ul><li>为了提高性能，内核会缓存路径名和 <code>inode</code> 之间的映射关系，这样在访问同一个文件或目录时，可以避免重复解析路径</li></ul></li></ul><h3 id=用-dentry-构建多叉树文件系统>用 <code>dentry</code> 构建“多叉树”文件系统<a hidden class=anchor aria-hidden=true href=#用-dentry-构建多叉树文件系统>#</a></h3><ul><li><p>在 Linux 内核中只需要用到 <code>struct list_head d_child</code> 和 <code>struct list_head d_subdirs</code> 这两个两个关键双向链表就可以实现目录树结构</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>dentry</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=p>......</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>list_head</span> <span class=n>d_child</span><span class=p>;</span>	<span class=cm>/* child of parent list */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>list_head</span> <span class=n>d_subdirs</span><span class=p>;</span>	<span class=cm>/* our children */</span>
</span></span><span class=line><span class=cl>	<span class=p>......</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>list_head</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>list_head</span> <span class=o>*</span><span class=n>next</span><span class=p>,</span> <span class=o>*</span><span class=n>prev</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><code>d_child</code></p><ul><li>表示当前目录项在父目录的子项链表中的位置</li><li>它连接到父目录的 <code>d_subdirs</code> 链表，用于形成目录树中的父子关系</li><li><code>d_child -> prev</code> 为父目录或者兄弟</li><li><code>d_child -> next</code> 为兄弟或者 <code>NULL</code></li></ul></li><li><p><code>d_subdirs</code></p><ul><li>表示当前目录的子目录和文件列表</li><li>用于遍历当前目录下的所有子项</li><li>当前目录下的每个子项（文件或子目录）的 <code>d_child</code> 都会被挂接到 <code>d_subdirs</code> 链表中</li><li><code>d_subdirs -> prev</code> 为 <code>NULL</code></li><li><code>d_subdirs -> next</code> 为当前目录下第一个孩子或者 <code>NULL</code></li><li>在当前目录新建文件时，创建的文件会以头插法插到 <code>d_subdirs -> next</code></li></ul></li><li><p><code>d_subdirs</code> 与 <code>d_child</code> 配合</p><ul><li><code>d_subdirs</code> 维护子项列表，<code>d_child</code> 链接到父目录的子项链表，形成一个双向链表结构的目录树</li></ul></li><li><p>假设文件系统目录结构如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>/
</span></span><span class=line><span class=cl>├── home/
</span></span><span class=line><span class=cl>│   ├── user/
</span></span><span class=line><span class=cl>│   │   ├── file1
</span></span><span class=line><span class=cl>│   │   └── documents/
</span></span><span class=line><span class=cl>└── etc/
</span></span></code></pre></td></tr></table></div></div></li><li><p>那么它们之间的链表关系图应该是这样子的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>(root /) d_child
</span></span><span class=line><span class=cl>         d_subdirs
</span></span><span class=line><span class=cl>              +
</span></span><span class=line><span class=cl>              |
</span></span><span class=line><span class=cl>              +--&gt; (home) d_child
</span></span><span class=line><span class=cl>              |           d_subdirs
</span></span><span class=line><span class=cl>              |                +
</span></span><span class=line><span class=cl>              |                |
</span></span><span class=line><span class=cl>              |                +--&gt; (user) d_child
</span></span><span class=line><span class=cl>              |                            d_subdirs
</span></span><span class=line><span class=cl>              |                                 +
</span></span><span class=line><span class=cl>              |                                 |
</span></span><span class=line><span class=cl>              |                                 +--&gt; (file1) d_child
</span></span><span class=line><span class=cl>              |                                 |
</span></span><span class=line><span class=cl>              |                                 +--&gt; (documents) d_child
</span></span><span class=line><span class=cl>              |
</span></span><span class=line><span class=cl>              +--&gt; (etc) d_child
</span></span></code></pre></td></tr></table></div></div></li><li><p>现在还剩下最后一个问题，<code>d_subdirs</code> 是 <code>list_head</code> 类型的数据结构，它本身只包含两个指针：<code>next</code> 和 <code>prev</code>，应该如何通过 <code>list_head</code> 找到包含它的 <code>struct dentry</code> 呢？</p></li><li><p>在内核里面，实现这个目标需要依赖嵌套结构和偏移量计算</p></li><li><p>而这一步的关键函数是 <code>contianer_of</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define container_of(ptr, type, member) \
</span></span></span><span class=line><span class=cl><span class=cp>  ((type *)((char *)(ptr) - offsetof(type, member)))
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>在 <code>dentry</code> 这个场景下，<code>container_of</code> 里面的各个参数可以这样子理解</p><ul><li><code>ptr</code> ：<code>list_head</code> 指针，例如 <code>&amp;dir->d_subdirs</code></li><li><code>type</code>：包含 <code>list_head</code> 的结构体类型（这里是 <code>struct dentry</code>）</li><li><code>member</code>：<code>list_head</code> 字段在结构体中的名字（这里是 <code>d_subdirs</code>）</li><li><code>offsetof(type, member)</code>：获取 <code>member</code> 在 <code>type</code> 中的偏移量，通过 <code>ptr</code> 减去 <code>member</code> 的偏移量，计算出结构体的起始地址</li></ul></li></ul><h3 id=删除目录>删除目录<a hidden class=anchor aria-hidden=true href=#删除目录>#</a></h3><ul><li>在文件系统中，删除一个目录时，内核会使用深度优先算法递归地删除该目录下的所有文件和子目录</li></ul><h2 id=tmpfs-与-shm-联系><code>tmpfs</code> 与 <code>shm</code> 联系<a hidden class=anchor aria-hidden=true href=#tmpfs-与-shm-联系>#</a></h2><h3 id=shm-introduction><code>shm</code> introduction<a hidden class=anchor aria-hidden=true href=#shm-introduction>#</a></h3><ul><li><code>shm</code> 是 Linux 内核内部实现匿名内存共享的机制，主要为内核服务，不对用户直接可见</li><li><code>shm</code> 最初设计是为支持 <code>POSIX</code> 共享内存（如 <code>shm_open</code>）和 System V 共享内存（如 <code>shmget</code>），共享内存需要一个临时的、内存驻留的文件系统来存储共享的内存页</li><li><code>shm</code> 为匿名页面提供统一的文件支持接口，使内核可以用文件操作函数（如 <code>readpage</code> 或 <code>writepage</code>）管理这些页面，实现匿名共享内存（如通过 <code>mmap</code> 创建的 <code>MAP_ANONYMOUS | MAP_SHARED</code> 区域）和 System V 共享内存（<code>shmget</code>）</li><li><code>shm</code> 对虚拟文件的描述都是使用 <code>shmem_inode_info</code> （ <code>shmem_inode_info</code> 可以看作 <code>inode</code> 的继承，在内存文件系统里面如果要创建一个文件，要先向系统申请一个 <code>inode</code> ，然后才是将这个 <code>inode</code> 传给 <code>shmem_inode_info</code> ，有点类似 C++ 里面的当一个子类要实例化的时候需要先实例化父类）<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// https://elixir.bootlin.com/linux/v2.6.0/source/include/linux/shmem_fs.h#L10
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>shmem_inode_info</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>spinlock_t</span>		<span class=n>lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span>		<span class=n>next_index</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>swp_entry_t</span>		<span class=n>i_direct</span><span class=p>[</span><span class=n>SHMEM_NR_DIRECT</span><span class=p>];</span> <span class=cm>/* for the first blocks */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=nc>page</span>	       <span class=o>*</span><span class=n>i_indirect</span><span class=p>;</span> <span class=cm>/* indirect blocks */</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span>		<span class=n>alloced</span><span class=p>;</span>    <span class=cm>/* data pages allocated to file */</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span>		<span class=n>swapped</span><span class=p>;</span>    <span class=cm>/* subtotal assigned to swap */</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span>		<span class=n>flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=nc>list_head</span>	<span class=n>list</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=nc>inode</span>		<span class=n>vfs_inode</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=tmpfs-introduction><code>tmpfs</code> introduction<a hidden class=anchor aria-hidden=true href=#tmpfs-introduction>#</a></h3><ul><li><code>tmpfs</code> 是面向用户的、通用的基于内存的文件系统，使用 RAM 作为存储媒介，用于提供临时存储和共享内存功能，能够通过挂载点提供更多功能</li><li><code>tmpfs</code> 的核心实现文件在内核的 <code>shm.c</code>，<code>tmpfs</code> 的许多功能，包括内存页的管理、<code>inode</code> 的创建和操作等，都在这个文件中实现</li></ul><h3 id=tmpfs-的核心实现源自于-shm><code>tmpfs</code> 的核心实现源自于 <code>shm</code><a hidden class=anchor aria-hidden=true href=#tmpfs-的核心实现源自于-shm>#</a></h3><ul><li><code>shm</code> 在通常语境下确实是共享内存（shared memory）的缩写，但在 Linux 内核中，<code>shmem</code> 指的是一个更通用的机制，既用于共享内存，也为 <code>tmpfs</code> 提供支持，这源于 Linux 内核设计中对内存管理的统一抽象</li><li><code>shm</code> 这个名字更多反映了其历史背景，由最初支持共享内存机制的主要目标，到后来逐渐扩展到支持 <code>tmpfs</code></li><li>随着 <code>tmpfs</code> 的引入，Linux 直接复用了 <code>shmem</code> 的基础设施，因为它们的核心需求一致：一种无持久存储后端、基于内存的文件系统</li><li>因此 <code>shm</code> 这种命名并不是严格意义上的“共享内存”限定，而是一个历史遗留的名字</li><li>当使用 <code>tmpfs</code> 或共享内存时，内核实际上都在调用 <code>shmem</code> 相关的功能，换句话说，<code>tmpfs</code> 和共享内存是同一个机制在不同场景下的两个应用实例</li><li><code>shmem</code> 和 <code>tmpfs</code> 核心需求一致：<ul><li>动态分配页（在需要时为文件或共享内存段分配内存页）</li><li>支持按需增长（<code>tmpfs</code> 文件或共享内存段会随内容增长）</li><li>内存页面可以被回收或写入交换分区（swapping）</li></ul></li><li><code>shmem</code> 是底层机制，最初服务于共享内存需求</li><li><code>tmpfs</code> 是基于 <code>shmem</code> 的一个文件系统实现，扩展了其使用场景，支持临时文件存储</li><li><code>tmpfs</code> 的诞生得益于 <code>shmem</code> 的存在，是共享内存技术的一次成功复用</li></ul><h2 id=shm-使用><code>shm</code> 使用<a hidden class=anchor aria-hidden=true href=#shm-使用>#</a></h2><ul><li><p>System V 共享内存</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 使用 `shmget` 和 `shmat` 创建的共享内存段，通过 `shm` 提供底层支持
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>shmid</span> <span class=o>=</span> <span class=nf>shmget</span><span class=p>(</span><span class=n>IPC_PRIVATE</span><span class=p>,</span> <span class=mi>1024</span><span class=p>,</span> <span class=n>IPC_CREAT</span> <span class=o>|</span> <span class=mo>0666</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=n>data</span> <span class=o>=</span> <span class=nf>shmat</span><span class=p>(</span><span class=n>shmid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>strcpy</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=s>&#34;Hello, shm!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Data in shared memory: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>data</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>匿名共享内存</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 当进程调用 `mmap` 并指定 `MAP_ANONYMOUS | MAP_SHARED` 时，`shm` 会为这些匿名页面创建支持
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>size_t</span> <span class=n>size</span> <span class=o>=</span> <span class=mi>4096</span><span class=p>;</span>  <span class=c1>// 分配一个4KB的内存区域
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=o>*</span><span class=n>addr</span> <span class=o>=</span> <span class=nf>mmap</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span> <span class=n>PROT_READ</span> <span class=o>|</span> <span class=n>PROT_WRITE</span><span class=p>,</span> <span class=n>MAP_SHARED</span> <span class=o>|</span> <span class=n>MAP_ANONYMOUS</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>addr</span> <span class=o>==</span> <span class=n>MAP_FAILED</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;mmap failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 通过指针访问并修改匿名共享内存
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*</span><span class=n>data</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=p>)</span><span class=n>addr</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>使用 <code>POSIX</code> 文件接口与 <code>shm</code> 结合</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>shm_name</span> <span class=o>=</span> <span class=s>&#34;/my_shm&#34;</span><span class=p>;</span>  <span class=c1>// 共享内存对象的名称
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>size_t</span> <span class=n>size</span> <span class=o>=</span> <span class=mi>4096</span><span class=p>;</span>                <span class=c1>// 共享内存的大小
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 创建或打开共享内存对象
</span></span></span><span class=line><span class=cl><span class=c1>// 使用 shm_open() 创建或打开共享内存对象后，返回的文件描述符可以通过 open() 进行访问
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>shm_fd</span> <span class=o>=</span> <span class=nf>shm_open</span><span class=p>(</span><span class=n>shm_name</span><span class=p>,</span> <span class=n>O_CREAT</span> <span class=o>|</span> <span class=n>O_RDWR</span><span class=p>,</span> <span class=n>S_IRUSR</span> <span class=o>|</span> <span class=n>S_IWUSR</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>shm_fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;shm_open&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 设置共享内存的大小
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=nf>ftruncate</span><span class=p>(</span><span class=n>shm_fd</span><span class=p>,</span> <span class=n>size</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;ftruncate&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 将共享内存映射到进程的地址空间
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=o>*</span><span class=n>shm_ptr</span> <span class=o>=</span> <span class=nf>mmap</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span> <span class=n>PROT_READ</span> <span class=o>|</span> <span class=n>PROT_WRITE</span><span class=p>,</span> <span class=n>MAP_SHARED</span><span class=p>,</span> <span class=n>shm_fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>shm_ptr</span> <span class=o>==</span> <span class=n>MAP_FAILED</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;mmap&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 使用共享内存
</span></span></span><span class=line><span class=cl><span class=c1>// 写入数据到共享内存
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>snprintf</span><span class=p>((</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>shm_ptr</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span> <span class=s>&#34;Hello from shared memory!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 解除映射
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=nf>munmap</span><span class=p>(</span><span class=n>shm_ptr</span><span class=p>,</span> <span class=n>size</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;munmap&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 关闭共享内存对象
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>close</span><span class=p>(</span><span class=n>shm_fd</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h2 id=tmpfs-使用><code>tmpfs</code> 使用<a hidden class=anchor aria-hidden=true href=#tmpfs-使用>#</a></h2><ul><li><code>tmpfs</code> 默认挂载到 <code>/tmp</code>，为用户提供快速的、基于 RAM 的临时文件存储空间，读写速度快，它也可以手动挂载到其他地方<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 在 /mnt/tmpfs 挂载一个 tmpfs 文件系统</span>
</span></span><span class=line><span class=cl>sudo mount -t tmpfs -o <span class=nv>size</span><span class=o>=</span>128M tmpfs /mnt/tmpfs
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 在 tmpfs 上创建文件</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;Hello, tmpfs!&#34;</span> &gt; /mnt/tmpfs/testfile
</span></span><span class=line><span class=cl>cat /mnt/tmpfs/testfile
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 卸载 tmpfs</span>
</span></span><span class=line><span class=cl>sudo umount /mnt/tmpfs
</span></span></code></pre></td></tr></table></div></div></li><li><code>tmpfs</code> 也可以使用多进程 <code>open</code> 或者多进程 <code>mmap</code> 到一个共同的 <code>tmpfs</code> 文件达到进程间通信的效果<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=s>&#34;example.txt&#34;</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=n>mapped</span> <span class=o>=</span> <span class=nf>mmap</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=mi>4096</span><span class=p>,</span> <span class=n>PROT_READ</span><span class=p>,</span> <span class=n>MAP_PRIVATE</span><span class=p>,</span> <span class=n>fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>close</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=观察真实机器上的-tmpfs>观察真实机器上的 <code>tmpfs</code><a hidden class=anchor aria-hidden=true href=#观察真实机器上的-tmpfs>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>hcy@debian:~$ df -h
</span></span><span class=line><span class=cl>文件系统        大小  已用  可用 已用% 挂载点
</span></span><span class=line><span class=cl>udev             32G     <span class=m>0</span>   32G    0% /dev
</span></span><span class=line><span class=cl>tmpfs           6.3G  1.9M  6.3G    1% /run
</span></span><span class=line><span class=cl>/dev/sdb1       119G   29G   91G   25% /
</span></span><span class=line><span class=cl>tmpfs            32G  550M   31G    2% /dev/shm
</span></span><span class=line><span class=cl>tmpfs           5.0M   12K  5.0M    1% /run/lock
</span></span><span class=line><span class=cl>tmpfs            32G   96M   32G    1% /tmp
</span></span><span class=line><span class=cl>/dev/sdb2       300M  5.9M  294M    2% /boot/efi
</span></span><span class=line><span class=cl>/dev/sda2       900G  218G  682G   25% /mnt/146bf4b9-b9ad-486d-811c-dcbb31aa3324
</span></span><span class=line><span class=cl>tmpfs           6.3G  256K  6.3G    1% /run/user/1000
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>hcy@debian:~$ id hcy
</span></span><span class=line><span class=cl><span class=nv>uid</span><span class=o>=</span>1000<span class=o>(</span>hcy<span class=o>)</span> <span class=nv>gid</span><span class=o>=</span>1000<span class=o>(</span>hcy<span class=o>)</span> <span class=nv>组</span><span class=o>=</span>1000<span class=o>(</span>hcy<span class=o>)</span>, ...
</span></span></code></pre></td></tr></table></div></div><ul><li>在上面的 <code>df -h</code> 输出中，列出了多个 <code>tmpfs</code> 挂载点<ul><li><p><code>/run</code>: <code>tmpfs</code> 被挂载在 <code>/run</code> 目录。它是一个动态的、短期的文件系统，用于存储系统运行时的数据（如进程 ID 文件、锁文件等）</p></li><li><p><code>/dev/shm</code>: <code>tmpfs</code> 被挂载在 <code>/dev/shm</code> 目录，它是共享内存的挂载点，供进程间通信使用</p></li><li><p><code>/run/lock</code>: <code>tmpfs</code> 被挂载在 <code>/run/lock</code> 目录，用于存放进程间锁文件</p></li><li><p><code>/tmp</code>: <code>tmpfs</code> 被挂载在 <code>/tmp</code> 目录，用于存放临时文件</p></li><li><p><code>/run/user/1000</code>: 该 <code>tmpfs</code> 是为用户 ID 为 1000 的用户（也就是用户 <code>hcy</code> ）提供的临时文件系统，用于存储用户的运行时数据，如程序缓存、临时文件等</p></li></ul></li><li>这些 <code>tmpfs</code> 挂载点的数据在机器重启之后都不会存在</li></ul><h3 id=观察容器里面的-tmpfs>观察容器里面的 <code>tmpfs</code><a hidden class=anchor aria-hidden=true href=#观察容器里面的-tmpfs>#</a></h3><ul><li>在 <code>Docker</code> 中，容器的文件系统是基于 <code>UnionFS</code>（联合文件系统）的，通常采用的是 <code>aufs</code>、<code>overlay</code> 或 <code>overlay2</code> 等文件系统，而<code>UnionFS</code> 并不直接使用 <code>tmpfs</code>，除非明确将某些目录挂载为 <code>tmpfs</code></li><li>Docker 容器的文件系统是持久化的，在容器中文件存储在镜像层 <code>read-only layer</code> 和容器层 <code>read-write layer</code> 上</li><li>默认情况下，当容器重启时，容器层会保持不变，即使写入到 <code>/tmp</code> 目录的文件，都会保存在容器层中，而不是丢失</li><li>只有在宿主机层面在容器创建时，通过 <code>--tmpfs</code> 参数来指定将 <code>/tmp</code> 挂载为 tmpfs，才有可能让容器里面的 <code>/tmp</code> 的表现和常规的一样<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run --tmpfs /tmp &lt;image_id&gt;
</span></span></code></pre></td></tr></table></div></div></li></ul><h2 id=全局共享的零页global-zero-page>全局共享的零页（global zero page）<a hidden class=anchor aria-hidden=true href=#全局共享的零页global-zero-page>#</a></h2><ul><li>Linux 内核中有一个全局共享的零页，所有字节都被初始化为零，这块内存页被全局所有进程共享，通常是只读的，多进程可以同时访问</li><li>当一个进程需要访问大量的全零数据（如未初始化的内存、扩展文件的空白部分），可以直接映射到全局零页，而无需实际分配和初始化物理内存，避免为每个进程单独分配一块全零的内存页</li><li>例如当文件通过 <code>truncate()</code> 扩展时，新增加的部分需要初始化为零。如果直接写零到磁盘或内存，会消耗资源</li><li>通过全局零页，文件系统可以将新增加的部分映射到这块零页，而不需要实际分配和初始化</li><li>又例如进程分配内存时，未使用的部分（例如通过 <code>mmap</code> 映射的匿名内存）通常被映射为零页，直到实际写入数据为止</li><li>由于零页是只读的，如果进程试图写入零页，会触发页错误 <code>page fault</code>，内核会复制一块新的物理页供进程使用，这叫做“写时复制” <code>Copy-on-Write, COW</code></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://hcy-asleep.github.io/Linux%E7%A3%81%E7%9B%98%E5%8D%A0%E7%94%A8%E5%88%86%E6%9E%90/><span class=title>下一页 »</span><br><span>Linux磁盘占用分析</span></a></nav></footer></br></br><script src=https://giscus.app/client.js data-repo=HCY-ASLEEP/HCY-ASLEEP.github.io data-repo-id=R_kgDOISFjNg data-category=Announcements data-category-id=DIC_kwDOISFjNs4CUJyb data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://hcy-asleep.github.io/>Memos</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>