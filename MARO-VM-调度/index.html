<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MARO VM 调度 | Memos</title>
<meta name=keywords content="MARO"><meta name=description content="背景"><meta name=author content="HCY"><link rel=canonical href=https://hcy-asleep.github.io/MARO-VM-%E8%B0%83%E5%BA%A6/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.200d491792ec08e3464c8e3d622ce4ab28a70554393e83d0d97e4648019c027d.css integrity="sha256-IA1JF5LsCONGTI49YizkqyinBVQ5PoPQ2X5GSAGcAn0=" rel="preload stylesheet" as=style><link rel=icon href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><link rel=apple-touch-icon href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><link rel=mask-icon href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><style>@media screen and (min-width:1px){.post-content input[type=checkbox]:checked~label>img{transform:scale(1.6);cursor:zoom-out;position:relative;z-index:999}.post-content img.zoomCheck{transition:transform .15s ease;z-index:999;cursor:zoom-in}}</style><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="MARO VM 调度"><meta property="og:description" content="背景"><meta property="og:type" content="article"><meta property="og:url" content="https://hcy-asleep.github.io/MARO-VM-%E8%B0%83%E5%BA%A6/"><meta property="og:image" content="https://hcy-asleep.github.io/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-10-27T11:01:57+00:00"><meta property="article:modified_time" content="2022-10-27T11:01:57+00:00"><meta property="og:site_name" content="HCY-BLOGS"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hcy-asleep.github.io/"><meta name=twitter:title content="MARO VM 调度"><meta name=twitter:description content="背景"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hcy-asleep.github.io/post/"},{"@type":"ListItem","position":2,"name":"MARO VM 调度","item":"https://hcy-asleep.github.io/MARO-VM-%E8%B0%83%E5%BA%A6/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MARO VM 调度","name":"MARO VM 调度","description":"背景","keywords":["MARO"],"articleBody":"背景 在云服务期间，用户请求具有一定数量资源的 虚拟机（VM）（Virtual Mechine），例如中央处理器、内存等 假设一个特定的时间，VM 请求的数量和到达模式是固定的，给定一个物理资源有限的 物理机（PM）（Physical Mechine） 集群 不同的 VM 分配策略导致数据中心的成功完成量不同，运营成本也不同 对于云提供商，一个好的 VM 分配策略可以最大限度地提高资源利用率，从而可以通过向用户提供更多的 VM 来增加利润 对于云用户，良好的 VM 分配策略可以最大程度地缩短 VM 响应时间，并提供更好的使用体验 资源供需 每个 PM 中的物理资源是中心资源，包括 物理内核 和 内存\nVM 请求需要一定数量的 物理资源 ，资源要求因不同的 VM 请求而异 只要指定的 PM 的剩余资源足够，模拟器 就会将 VM 分配到指定 PM ，VM 会在指定 PM 中创建 VM 的资源利用率动态变化，PM 的实时能耗将在 Runtime-Simulation（模拟器） 中被模拟出来 VM 执行一段时间后完成其任务，模拟器 将释放分配给此 VM 的资源，并从 PM 中解除分配此 VM ，物理资源被释放，可以处理下一个 VM 请求 VM Request MARO 和机器学习算法原理类似，需要 样本数据 训练出 模型（找出当前场景的规律），再通过模型去 预测 怎样的行为更加正确符合实际 VM scheduling 场景里面，样本数据 是 VM Requests ，样本数据从实际工作负荷中统一采样 只要原始数据集足够大，采样率不太小，采样的 VM Requests**（复数名词）** 就可以被认为遵循与原始请求类似的分布 一个 VM Request 包含 VM 信息（如 订阅 ID、部署 ID 和 VM 类别）、VM 的所需资源（包括所需的 CPU 核心数和内存）以及 剩余缓冲时间（remaining buffer time） VM 类型 交互式\n交互式 VM 通常需要较低的响应时间，因此设置此类 VM 只能分配给不可超额订阅的 PM 服务器 延迟不敏感\n不区分延迟的 VM 通常用于批处理任务或开发工作负荷，可以将此类 VM 分配给可过度订阅的 PM 服务器 VM 分配 根据 有效的 PM 列表 ，模拟器记录的历史信息 以及 VM 的详细所需资源 ，VM 调度器（决策代理） 将根据其分配策略做出决策\n两种有意义的操作\n将 有效的 PM ID 传送到模拟器 推迟如果 剩余缓冲区时间 足够，则可以稍后将处理的 VM Request Oversubscription 超额订阅 考虑到各种服务级别，将物理机分为可超额订阅和非超额订阅的\n所谓超额，就比如 10 个 VM 实际上只使用 7 个 PM （就是厂商为了省钱）\n对于超额订阅，可以在 config.yml 中设置参数\n在此场景，有两个资源可能被超额订阅，CPU 和 内存，因可以设置这两个的最大超额订阅率\nMAX_CPU_OVERSUBSCRIPTION_RATE ，CPU 的超额订阅率，默认设置为 1.15 ，意味着每个 PM 最多可以分配其资源容量的 1.15 倍\nMAX_MEM_OVERSUBSCRIPTION_RATE ，内存的超额订阅率，与 CPU 的类似\n为了保护 PM 免受过载的影响，需要考虑 CPU 利用率 ，MAX_UTILIZATION_RATE 被用作安全机制\nMAX_UTILIZATION_RATE ，默认设置为 1，这意味着在筛选有效 PM 时，允许的最大物理 CPU 使用率为 100% Runtime Simulation 动态利用率 为了使模拟环境最接近真实情况，MARO 模拟每个 VM 的资源利用率（当前仅为 CPU 利用率） 模拟的 VM CPU 利用率根据实际的 VM 工作负载读数而变化 MARO 还将根据每个 PM 中的实时 VM 定期更新实时资源利用率 实时能耗 不同的 VM 分配会导致 PM 集群的能耗不同，MARO 还根据 CPU 利用率模拟（计算）能耗\n能耗曲线\n这个非线性曲线反映了 CPU 利用率 与 能耗 的关系，用于模拟（计算）能耗 Overload 由于 VM 的 CPU 使用率随时间而变化，因此在启用超额订阅时，VM 的 CPU 使用率之和可能会超过物理资源的容量，这种情况称为过载\n目前对于过载的情况，MARO 只支持静默（杀死）所有虚拟机 或 仅记录过载时间，在 config.yml 里面设置\nKILL_ALL_VMS_IF_OVERLOAD\n如果启用此操作，则一旦发生重载，将解除分配位于重载 PM 的所有 VM 考虑到过载的影响，MARO 仍然会计算高利用率的能耗，静默行动对 PM 利用率的影响将反映在下一次 tick 中 无论是否启用终止所有 VM，过载 PM 的数量和过载 VM 的数量都会被计算 这两个指标是累积值，将被记录为环境指标 VM 解除分配 MARO 模拟器会定期检查每次 tick 中完成任务的虚拟机 完成的 VM 意味着它经历了一个完整的生命周期，已准备好终止，它所占用的资源最终将再次可用 然后，模拟器将释放已完成的 VM 的资源，并最终从 PM 中删除 VM Quick Start 准备两个 csv 文件 vm_table 和 cpu_readings_file\nvm_table\nvm_id: int, 每个 vm 的id\nsub_id: int, subscription id（每个 vm 的订阅 id）\ndeploy_id: int, 每个 vm 的部署 id\ntimestamp: int, 每个 vm 的创建时间\nvm_deleted: int. 每个 vm 的删除时间\nvm_lifetime: int, 每个 vm 的生存时间，Lifetime = deletion time - creation time (timestamp) + 1\nvm_category: int, 目前有三种类型\nDelay-Insensitive\n可能延迟的 VM 工作负荷，例如批处理任务或测试工作负荷 可以将此类 VM 分配给可过度订阅的 PM Interactive\n交互式 VM 工作负荷，需要用户及时响应 此类 VM 只能分配给不可超额订阅的 PM Unknown\n未知类型 为避免过载，此类 VM 被视为交互式 VM，只能分配给不可超额订阅的 PM cpu_readings_file\ntimestamp: int, 与 vm_table 中的 timestamp 匹配 vm_id: int, 与 vm_table 中的 vm_id 匹配 cpu_utilization: float, VM CPU 的利用率，以百分比单位 （%）存储 构建命令 将 CSV 数据集构建为 MARO 模拟器可以使用的二进制文件\n1 2 # maro data build --meta $PATH_TO_META_FILE --file $PATH_TO_CSV_FILE --output $PATH_TO_OUTPUT_FILE maro data build --meta ~/.maro/data/vm_scheduling/meta/vmtable.yml --file ~/.maro/data/vm_scheduling/.build/azure.2019.10k/vmtable.bin --output $PWD/vmtable.bin –meta：必需，用于指定 meta file 的路径。默认情况下，meta file 位于\n1 ~/.maro/data/vm_scheduling/meta/ –file：必需，用于指定源 CSV 数据文件的路径，如果需要多个源 CSV 数据文件，则可以在特定文件中列出源文件的所有完整路径，并使用 @ 符号指定这个特定文件\n–output：必需，用于指定目标二进制文件的路径\n生成二进制文件之后，在 topologies 目录下的 config.yml 中指定 VM_TABLE 和 CPU_READINGS 的直接路径\nEnvironment Interface DecisionPayload\n一旦环境需要代理的响应来促进模拟，它就会抛出一个带有 DecisionPayload 的 PendingDecision 事件\nDecisionPayload 包含以下信息\nvalid_pms (List[int]) ：被视为有效的 PM ID 列表（其 CPU 和内存资源足以满足传入的 VM 请求） vm_id (int) ：传入的 VM Request（正在等待分配的 VM Request）的 vm_id ， vm_cpu_cores_requirement (int) ：传入的 VM Request 的 CPU 内核数量 vm_memory_requirement (int) ：传入的 VM Request 请求的内存资源大小 remaining_buffer_time（int） ：当使用 remaining_buffer_time 时，VM Request 将被视为失败，可以在 config.yml 里面设置 Action\n从环境中获取 PendingDecisionAction 事件后，代理应使用 Action 进行响应，以下是有效的 Action\nNone：除了忽略此 VM Request 之外什么都不执行\nAllocateAction：VM 的创建时间将固定在它收到这个 Request 的 tick 处，模拟器将更新目标 PM 的工作负载（CPU 核心数量，内存和能耗），这个 Action 包括:\nvm_id(int)：等待分配资源的 VM 的 ID pm_id(int)：计划将 VM 分配到的 PM 的 ID PostponeAction：计算 remaining buffer time，这个 Action 包括：\nvm_id (int) ：等待分配的 VM 的 ID postpone_step（int）：分配要推迟的次数，单位是 DELAY_DURATION ，1 表示延迟 1 DELAY_DURATION ，可以在 config.yml 中设置 如果时间仍然足够，模拟器将重新生成一个新的请求事件，新需求事件的 仅在剩余缓冲时间上与旧事件不同 如果时间用完，模拟器会将其记录为失败的分配 Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import random from maro.simulator import Env from maro.simulator.scenarios.vm_scheduling import AllocateAction, DecisionPayload, PostponeAction # Initialize an Env for vm_scheduling scenario # 初始化环境 env = Env( scenario=\"vm_scheduling\", topology=\"azure.2019.10k\", start_tick=0, durations=8638, snapshot_resolution=1 ) # 初始化变量，声明类型，\":\"用于声明类型 metrics: object = None decision_event: DecisionPayload = None is_done: bool = False action: AllocateAction = None # Start the env with a None Action # 开始模拟 metrics, decision_event, is_done = env.step(None) while not is_done: valid_pm_num: int = len(decision_event.valid_pms) # 作出决策 if valid_pm_num \u003c= 0: # No valid PM now, postpone. # 没有可用的 PM ，推迟分配 action: PostponeAction = PostponeAction( vm_id=decision_event.vm_id, postpone_step=1 ) else: # Randomly choose an available PM. # 有可用的 PM ，随机选一个 PM 与 VM 绑定 random_idx = random.randint(0, valid_pm_num - 1) pm_id = decision_event.valid_pms[random_idx] action: AllocateAction = AllocateAction( vm_id=decision_event.vm_id, pm_id=pm_id ) # 采取行动 metrics, decision_event, is_done = env.step(action) print(f\"[Random] Topology: azure.2019.10k. Total ticks: 8638. Start tick: 0\") print(metrics) ","wordCount":"722","inLanguage":"zh","datePublished":"2022-10-27T11:01:57Z","dateModified":"2022-10-27T11:01:57Z","author":{"@type":"Person","name":"HCY"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://hcy-asleep.github.io/MARO-VM-%E8%B0%83%E5%BA%A6/"},"publisher":{"@type":"Organization","name":"Memos","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://hcy-asleep.github.io/ accesskey=h title="主页 (Alt + H)">主页</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://hcy-asleep.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://hcy-asleep.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://hcy-asleep.github.io/categories/ title=目录><span>目录</span></a></li><li><a href=https://hcy-asleep.github.io/friends/ title=友链><span>友链</span></a></li><li><a href=https://hcy-asleep.github.io/about/ title=关于><span>关于</span></a></li><li><a href=https://hcy-asleep.github.io/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://hcy-asleep.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://hcy-asleep.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">MARO VM 调度</h1><div class=post-meta><span title='2022-10-27 11:01:57 +0000 UTC'>十月 27, 2022</span>&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;722 字&nbsp;·&nbsp;HCY&nbsp;|&nbsp;<a href=https://github.com/HCY-ASLEEP rel="noopener noreferrer" target=_blank> Follow me</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#背景>背景</a><ul><li><ul><li><ul><li><a href=#heading></a></li></ul></li></ul></li></ul></li><li><a href=#资源供需>资源供需</a><ul><li><ul><li><ul><li><a href=#heading-1></a></li></ul></li></ul></li></ul></li><li><a href=#vm-request>VM Request</a><ul><li><ul><li><ul><li><a href=#heading-2></a></li></ul></li></ul></li></ul></li><li><a href=#vm-类型>VM 类型</a><ul><li><ul><li><ul><li><a href=#heading-3></a></li><li><a href=#heading-4></a></li></ul></li></ul></li></ul></li><li><a href=#vm-分配>VM 分配</a><ul><li><ul><li><ul><li><a href=#heading-5></a></li></ul></li></ul></li></ul></li><li><a href=#oversubscription-超额订阅>Oversubscription 超额订阅</a><ul><li><ul><li><ul><li><a href=#heading-6></a></li></ul></li></ul></li></ul></li><li><a href=#runtime-simulation>Runtime Simulation</a><ul><li><a href=#动态利用率>动态利用率</a></li><li><a href=#实时能耗>实时能耗</a><ul><li><ul><li><a href=#heading-7></a></li></ul></li></ul></li></ul></li><li><a href=#overload>Overload</a><ul><li><ul><li><ul><li><a href=#heading-8></a></li><li><a href=#heading-9></a></li></ul></li></ul></li></ul></li><li><a href=#vm-解除分配>VM 解除分配</a><ul><li><ul><li><ul><li><a href=#heading-10></a></li></ul></li></ul></li></ul></li><li><a href=#quick-start>Quick Start</a><ul><li><ul><li><ul><li><a href=#heading-11></a></li></ul></li></ul></li></ul></li><li><a href=#构建命令>构建命令</a><ul><li><ul><li><ul><li><a href=#heading-12></a></li></ul></li></ul></li></ul></li><li><a href=#environment-interface>Environment Interface</a><ul><li><ul><li><ul><li><a href=#heading-13></a></li></ul></li></ul></li></ul></li><li><a href=#example>Example</a></li></ul></li></ul></li></ul></nav></div></details></div><div class=post-content><h3 id=背景>背景<a hidden class=anchor aria-hidden=true href=#背景>#</a></h3><ul><li>在云服务期间，用户请求具有一定数量资源的 <strong>虚拟机（VM）（Virtual Mechine）</strong>，例如中央处理器、内存等</li><li>假设一个特定的时间，VM 请求的数量和到达模式是固定的，给定一个物理资源有限的 <strong>物理机（PM）（Physical Mechine）</strong> 集群</li><li>不同的 VM 分配策略导致数据中心的成功完成量不同，运营成本也不同</li><li>对于云提供商，一个好的 VM 分配策略可以最大限度地提高资源利用率，从而可以通过向用户提供更多的 VM 来增加利润</li><li>对于云用户，良好的 VM 分配策略可以最大程度地缩短 VM 响应时间，并提供更好的使用体验</li></ul><h6 id=heading><a hidden class=anchor aria-hidden=true href=#heading>#</a></h6><h3 id=资源供需>资源供需<a hidden class=anchor aria-hidden=true href=#资源供需>#</a></h3><p><input type=checkbox id=zoomCheck-37f59 hidden>
<label for=zoomCheck-37f59><img class=zoomCheck loading=lazy decoding=async src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/2022.10.27.20.00.43.png alt></label></p><ul><li><p>每个 <strong>PM</strong> 中的物理资源是中心资源，包括 <strong>物理内核</strong> 和 <strong>内存</strong></p><ul><li>VM 请求需要一定数量的 <strong>物理资源</strong> ，资源要求因不同的 VM 请求而异</li><li>只要指定的 PM 的剩余资源足够，<strong>模拟器</strong> 就会将 VM 分配到指定 PM ，VM 会在指定 PM 中创建</li><li>VM 的资源利用率动态变化，PM 的实时能耗将在 <strong>Runtime-Simulation（模拟器）</strong> 中被模拟出来</li><li>VM 执行一段时间后完成其任务，<strong>模拟器</strong> 将释放分配给此 VM 的资源，并从 PM 中解除分配此 VM ，物理资源被释放，可以处理下一个 VM 请求</li></ul></li></ul><p><input type=checkbox id=zoomCheck-a3117 hidden>
<label for=zoomCheck-a3117><img class=zoomCheck loading=lazy decoding=async src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/2022.10.28.15.14.52.png alt></label></p><h6 id=heading-1><a hidden class=anchor aria-hidden=true href=#heading-1>#</a></h6><h3 id=vm-request>VM Request<a hidden class=anchor aria-hidden=true href=#vm-request>#</a></h3><ul><li>MARO 和机器学习算法原理类似，需要 <strong>样本数据</strong> 训练出 <strong>模型（找出当前场景的规律）</strong>，再通过模型去 <strong>预测</strong> 怎样的行为更加正确符合实际</li><li>VM scheduling 场景里面，<strong>样本数据</strong> 是 VM Request<strong>s</strong> ，样本数据从实际工作负荷中统一采样</li><li>只要原始数据集足够大，采样率不太小，采样的 VM Requests**（复数名词）** 就可以被认为遵循与原始请求类似的分布</li><li>一个 VM Request 包含 <strong>VM 信息</strong>（如 订阅 ID、部署 ID 和 VM 类别）、<strong>VM 的所需资源</strong>（包括所需的 CPU 核心数和内存）以及 <strong>剩余缓冲时间（remaining buffer time）</strong></li></ul><h6 id=heading-2><a hidden class=anchor aria-hidden=true href=#heading-2>#</a></h6><h3 id=vm-类型>VM 类型<a hidden class=anchor aria-hidden=true href=#vm-类型>#</a></h3><ul><li><p>交互式</p><ul><li>交互式 VM 通常需要较低的响应时间，因此设置此类 VM 只能分配给不可超额订阅的 PM 服务器</li></ul></li></ul><h6 id=heading-3><a hidden class=anchor aria-hidden=true href=#heading-3>#</a></h6><ul><li><p>延迟不敏感</p><ul><li>不区分延迟的 VM 通常用于批处理任务或开发工作负荷，可以将此类 VM 分配给可过度订阅的 PM 服务器</li></ul></li></ul><h6 id=heading-4><a hidden class=anchor aria-hidden=true href=#heading-4>#</a></h6><h3 id=vm-分配>VM 分配<a hidden class=anchor aria-hidden=true href=#vm-分配>#</a></h3><ul><li><p>根据 <strong>有效的 PM 列表</strong> ，<strong>模拟器记录的历史信息</strong> 以及 <strong>VM 的详细所需资源</strong> ，<strong>VM 调度器（决策代理）</strong> 将根据其分配策略做出决策</p></li><li><p>两种有意义的操作</p><ul><li>将 <strong>有效的 PM ID</strong> 传送到模拟器</li><li>推迟如果 <strong>剩余缓冲区时间</strong> 足够，则可以稍后将处理的 VM Request</li></ul></li></ul><h6 id=heading-5><a hidden class=anchor aria-hidden=true href=#heading-5>#</a></h6><h3 id=oversubscription-超额订阅>Oversubscription 超额订阅<a hidden class=anchor aria-hidden=true href=#oversubscription-超额订阅>#</a></h3><ul><li><p>考虑到各种服务级别，将物理机分为可超额订阅和非超额订阅的</p></li><li><p>所谓超额，就比如 10 个 VM 实际上只使用 7 个 PM （就是厂商为了省钱）</p></li><li><p>对于超额订阅，可以在 <strong>config.yml</strong> 中设置参数</p></li><li><p>在此场景，有两个资源可能被超额订阅，CPU 和 内存，因可以设置这两个的最大超额订阅率</p><ul><li><p><strong>MAX_CPU_OVERSUBSCRIPTION_RATE</strong> ，CPU 的超额订阅率，默认设置为 1.15 ，意味着每个 PM 最多可以分配其资源容量的 1.15 倍</p></li><li><p><strong>MAX_MEM_OVERSUBSCRIPTION_RATE</strong> ，内存的超额订阅率，与 CPU 的类似</p></li></ul></li><li><p>为了保护 PM 免受过载的影响，需要考虑 CPU 利用率 ，MAX_UTILIZATION_RATE 被用作安全机制</p><ul><li><strong>MAX_UTILIZATION_RATE</strong> ，默认设置为 1，这意味着在筛选有效 PM 时，允许的最大物理 CPU 使用率为 100%</li></ul></li></ul><h6 id=heading-6><a hidden class=anchor aria-hidden=true href=#heading-6>#</a></h6><h3 id=runtime-simulation>Runtime Simulation<a hidden class=anchor aria-hidden=true href=#runtime-simulation>#</a></h3><ul><li><h4 id=动态利用率>动态利用率<a hidden class=anchor aria-hidden=true href=#动态利用率>#</a></h4><ul><li>为了使模拟环境最接近真实情况，MARO 模拟每个 VM 的资源利用率（当前仅为 CPU 利用率）</li><li><strong>模拟的</strong> VM CPU 利用率根据<strong>实际的</strong> VM 工作负载读数而变化</li><li>MARO 还将根据每个 PM 中的<strong>实时</strong> VM 定期更新<strong>实时</strong>资源利用率</li></ul></li><li><h4 id=实时能耗>实时能耗<a hidden class=anchor aria-hidden=true href=#实时能耗>#</a></h4><ul><li><p>不同的 VM 分配会导致 PM 集群的能耗不同，MARO 还根据 CPU 利用率模拟（计算）能耗</p><ul><li><p>能耗曲线</p><ul><li>这个非线性曲线反映了 CPU 利用率 与 能耗 的关系，用于模拟（计算）能耗
<input type=checkbox id=zoomCheck-9778e hidden>
<label for=zoomCheck-9778e><img class=zoomCheck loading=lazy decoding=async src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/vm.energy_curve.svg alt></label></li></ul></li></ul></li></ul></li></ul><h6 id=heading-7><a hidden class=anchor aria-hidden=true href=#heading-7>#</a></h6><h3 id=overload>Overload<a hidden class=anchor aria-hidden=true href=#overload>#</a></h3><ul><li><p>由于 VM 的 CPU 使用率随时间而变化，因此在启用超额订阅时，VM 的 CPU 使用率之和可能会超过物理资源的容量，这种情况称为过载</p><ul><li><p>目前对于过载的情况，MARO 只支持<strong>静默（杀死）所有虚拟机</strong> 或 <strong>仅记录过载时间</strong>，在 config.yml 里面设置</p><ul><li><p><strong>KILL_ALL_VMS_IF_OVERLOAD</strong></p><ul><li>如果启用此操作，则一旦发生重载，将解除分配位于重载 PM 的<strong>所有</strong> VM</li><li>考虑到过载的影响，MARO 仍然会计算高利用率的能耗，静默行动对 PM 利用率的影响将反映在下一次 tick 中</li></ul></li></ul></li></ul></li></ul><h6 id=heading-8><a hidden class=anchor aria-hidden=true href=#heading-8>#</a></h6><ul><li>无论是否启用终止所有 VM，过载 PM 的数量和过载 VM 的数量都会被计算</li><li>这两个指标是累积值，将被记录为环境指标</li></ul><h6 id=heading-9><a hidden class=anchor aria-hidden=true href=#heading-9>#</a></h6><h3 id=vm-解除分配>VM 解除分配<a hidden class=anchor aria-hidden=true href=#vm-解除分配>#</a></h3><ul><li>MARO 模拟器会定期检查每次 tick 中完成任务的虚拟机</li><li>完成的 VM 意味着它经历了一个完整的生命周期，已准备好终止，它所占用的资源最终将再次可用</li><li>然后，模拟器将释放已完成的 VM 的资源，并最终从 PM 中删除 VM</li></ul><h6 id=heading-10><a hidden class=anchor aria-hidden=true href=#heading-10>#</a></h6><h3 id=quick-start>Quick Start<a hidden class=anchor aria-hidden=true href=#quick-start>#</a></h3><ul><li><p>准备两个 csv 文件 vm_table 和 cpu_readings_file</p><ul><li><p>vm_table</p><ul><li><p><strong>vm_id</strong>: int, 每个 vm 的id</p></li><li><p><strong>sub_id</strong>: int, subscription id（每个 vm 的订阅 id）</p></li><li><p><strong>deploy_id</strong>: int, 每个 vm 的部署 id</p></li><li><p><strong>timestamp</strong>: int, 每个 vm 的创建时间</p></li><li><p><strong>vm_deleted</strong>: int. 每个 vm 的删除时间</p></li><li><p><strong>vm_lifetime</strong>: int, 每个 vm 的生存时间，Lifetime = deletion time - creation time (timestamp) + 1</p></li><li><p><strong>vm_category</strong>: int, 目前有三种类型</p><ul><li><p>Delay-Insensitive</p><ul><li>可能延迟的 VM 工作负荷，例如批处理任务或测试工作负荷</li><li>可以将此类 VM 分配给可过度订阅的 PM</li></ul></li><li><p>Interactive</p><ul><li>交互式 VM 工作负荷，需要用户及时响应</li><li>此类 VM 只能分配给不可超额订阅的 PM</li></ul></li><li><p>Unknown</p><ul><li>未知类型</li><li>为避免过载，此类 VM 被视为交互式 VM，只能分配给不可超额订阅的 PM</li></ul></li></ul></li></ul></li><li><p>cpu_readings_file</p><ul><li><strong>timestamp</strong>: int, 与 vm_table 中的 timestamp 匹配</li><li><strong>vm_id</strong>: int, 与 vm_table 中的 vm_id 匹配</li><li><strong>cpu_utilization</strong>: float, VM CPU 的利用率，以百分比单位 （%）存储</li></ul></li></ul></li></ul><h6 id=heading-11><a hidden class=anchor aria-hidden=true href=#heading-11>#</a></h6><h3 id=构建命令>构建命令<a hidden class=anchor aria-hidden=true href=#构建命令>#</a></h3><ul><li><p>将 CSV 数据集构建为 MARO 模拟器可以使用的二进制文件</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># maro data build --meta $PATH_TO_META_FILE --file $PATH_TO_CSV_FILE  --output $PATH_TO_OUTPUT_FILE
</span></span><span class=line><span class=cl>maro data build --meta ~/.maro/data/vm_scheduling/meta/vmtable.yml  --file ~/.maro/data/vm_scheduling/.build/azure.2019.10k/vmtable.bin --output $PWD/vmtable.bin
</span></span></code></pre></td></tr></table></div></div><ul><li><p>&ndash;meta：必需，用于指定 meta file 的路径。默认情况下，meta file 位于</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>~/.maro/data/vm_scheduling/meta/
</span></span></code></pre></td></tr></table></div></div></li><li><p>&ndash;file：必需，用于指定源 CSV 数据文件的路径，如果需要多个源 CSV 数据文件，则可以在特定文件中列出源文件的所有完整路径，并使用 @ 符号指定这个特定文件</p></li><li><p>&ndash;output：必需，用于指定目标二进制文件的路径</p></li></ul></li><li><p>生成二进制文件之后，在 topologies 目录下的 config.yml 中指定 VM_TABLE 和 CPU_READINGS 的直接路径</p></li></ul><h6 id=heading-12><a hidden class=anchor aria-hidden=true href=#heading-12>#</a></h6><h3 id=environment-interface>Environment Interface<a hidden class=anchor aria-hidden=true href=#environment-interface>#</a></h3><ul><li><p><strong>DecisionPayload</strong></p><ul><li><p>一旦环境需要代理的响应来促进模拟，它就会抛出一个带有 DecisionPayload 的 PendingDecision 事件</p></li><li><p>DecisionPayload 包含以下信息</p><ul><li><strong>valid_pms (List[int])</strong> ：被视为有效的 PM ID 列表（其 CPU 和内存资源足以满足传入的 VM 请求）</li><li><strong>vm_id (int)</strong> ：传入的 VM Request（正在等待分配的 VM Request）的 vm_id ，</li><li><strong>vm_cpu_cores_requirement (int)</strong> ：传入的 VM Request 的 CPU 内核数量</li><li><strong>vm_memory_requirement (int)</strong> ：传入的 VM Request 请求的内存资源大小</li><li><strong>remaining_buffer_time（int）</strong> ：当使用 remaining_buffer_time 时，VM Request 将被视为失败，可以在 config.yml 里面设置</li></ul></li></ul></li><li><p><strong>Action</strong></p><ul><li><p>从环境中获取 PendingDecisionAction 事件后，代理应使用 Action 进行响应，以下是有效的 Action</p><ul><li><p><strong>None</strong>：除了忽略此 VM Request 之外什么都不执行</p></li><li><p><strong>AllocateAction</strong>：VM 的创建时间将固定在它收到这个 Request 的 tick 处，模拟器将更新目标 PM 的工作负载（CPU 核心数量，内存和能耗），这个 Action 包括:</p><ul><li><strong>vm_id(int)</strong>：等待分配资源的 VM 的 ID</li><li><strong>pm_id(int)</strong>：计划将 VM 分配到的 PM 的 ID</li></ul></li><li><p><strong>PostponeAction</strong>：计算 remaining buffer time，这个 Action 包括：</p><ul><li><strong>vm_id (int)</strong> ：等待分配的 VM 的 ID</li><li><strong>postpone_step（int）</strong>：分配要推迟的次数，单位是 DELAY_DURATION ，1 表示延迟 1 DELAY_DURATION ，可以在 config.yml 中设置</li><li>如果时间仍然足够，模拟器将重新生成一个新的请求事件，新需求事件的 仅在剩余缓冲时间上与旧事件不同</li><li>如果时间用完，模拟器会将其记录为失败的分配</li></ul></li></ul></li></ul></li></ul><h6 id=heading-13><a hidden class=anchor aria-hidden=true href=#heading-13>#</a></h6><h3 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>random</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>maro.simulator</span> <span class=kn>import</span> <span class=n>Env</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>maro.simulator.scenarios.vm_scheduling</span> <span class=kn>import</span> <span class=n>AllocateAction</span><span class=p>,</span> <span class=n>DecisionPayload</span><span class=p>,</span> <span class=n>PostponeAction</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Initialize an Env for vm_scheduling scenario</span>
</span></span><span class=line><span class=cl><span class=c1># 初始化环境</span>
</span></span><span class=line><span class=cl><span class=n>env</span> <span class=o>=</span> <span class=n>Env</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>scenario</span><span class=o>=</span><span class=s2>&#34;vm_scheduling&#34;</span><span class=p>,</span>     
</span></span><span class=line><span class=cl>  <span class=n>topology</span><span class=o>=</span><span class=s2>&#34;azure.2019.10k&#34;</span><span class=p>,</span>    
</span></span><span class=line><span class=cl>  <span class=n>start_tick</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span>                
</span></span><span class=line><span class=cl>  <span class=n>durations</span><span class=o>=</span><span class=mi>8638</span><span class=p>,</span>              
</span></span><span class=line><span class=cl>  <span class=n>snapshot_resolution</span><span class=o>=</span><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 初始化变量，声明类型，&#34;:&#34;用于声明类型</span>
</span></span><span class=line><span class=cl><span class=n>metrics</span><span class=p>:</span> <span class=nb>object</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl><span class=n>decision_event</span><span class=p>:</span> <span class=n>DecisionPayload</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl><span class=n>is_done</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl><span class=n>action</span><span class=p>:</span> <span class=n>AllocateAction</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Start the env with a None Action</span>
</span></span><span class=line><span class=cl><span class=c1># 开始模拟</span>
</span></span><span class=line><span class=cl><span class=n>metrics</span><span class=p>,</span> <span class=n>decision_event</span><span class=p>,</span> <span class=n>is_done</span> <span class=o>=</span> <span class=n>env</span><span class=o>.</span><span class=n>step</span><span class=p>(</span><span class=kc>None</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=ow>not</span> <span class=n>is_done</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>valid_pm_num</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>decision_event</span><span class=o>.</span><span class=n>valid_pms</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1># 作出决策</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>valid_pm_num</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># No valid PM now, postpone.</span>
</span></span><span class=line><span class=cl>		<span class=c1># 没有可用的 PM ，推迟分配</span>
</span></span><span class=line><span class=cl>        <span class=n>action</span><span class=p>:</span> <span class=n>PostponeAction</span> <span class=o>=</span> <span class=n>PostponeAction</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>vm_id</span><span class=o>=</span><span class=n>decision_event</span><span class=o>.</span><span class=n>vm_id</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>postpone_step</span><span class=o>=</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># Randomly choose an available PM.</span>
</span></span><span class=line><span class=cl>		<span class=c1># 有可用的 PM ，随机选一个 PM 与 VM 绑定</span>
</span></span><span class=line><span class=cl>        <span class=n>random_idx</span> <span class=o>=</span> <span class=n>random</span><span class=o>.</span><span class=n>randint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>valid_pm_num</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>pm_id</span> <span class=o>=</span> <span class=n>decision_event</span><span class=o>.</span><span class=n>valid_pms</span><span class=p>[</span><span class=n>random_idx</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>action</span><span class=p>:</span> <span class=n>AllocateAction</span> <span class=o>=</span> <span class=n>AllocateAction</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>vm_id</span><span class=o>=</span><span class=n>decision_event</span><span class=o>.</span><span class=n>vm_id</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>pm_id</span><span class=o>=</span><span class=n>pm_id</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1># 采取行动</span>
</span></span><span class=line><span class=cl>    <span class=n>metrics</span><span class=p>,</span> <span class=n>decision_event</span><span class=p>,</span> <span class=n>is_done</span> <span class=o>=</span> <span class=n>env</span><span class=o>.</span><span class=n>step</span><span class=p>(</span><span class=n>action</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;[Random] Topology: azure.2019.10k. Total ticks: 8638. Start tick: 0&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>metrics</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><br></div><footer class=post-footer><ul class=post-tags><li><a href=https://hcy-asleep.github.io/tags/MARO/>MARO</a></li></ul><nav class=paginav><a class=prev href=https://hcy-asleep.github.io/VIM-%E9%85%8D%E7%BD%AE/><span class=title>« 上一页</span><br><span>VIM 配置</span>
</a><a class=next href=https://hcy-asleep.github.io/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/><span class=title>下一页 »</span><br><span>工作面试</span></a></nav></footer></br></br><script src=https://giscus.app/client.js data-repo=HCY-ASLEEP/HCY-ASLEEP.github.io data-repo-id=R_kgDOISFjNg data-category=Announcements data-category-id=DIC_kwDOISFjNs4CUJyb data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://hcy-asleep.github.io/>Memos</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>