<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MySQL 闲谈 1 | Memos</title>
<meta name=keywords content="数据库,MySQL,对话"><meta name=description content=" 
对MySQL InnoDB引擎的索引了解吗？
"><meta name=author content="HCY"><link rel=canonical href=https://hcy-asleep.github.io/MySQL-%E9%97%B2%E8%B0%88-1/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bf546705000388ff8f0176e72d11be7c3d4efd591a0430f9c62915164a160ae2.css integrity="sha256-v1RnBQADiP+PAXbnLRG+fD1O/VkaBDD5xikVFkoWCuI=" rel="preload stylesheet" as=style><link rel=icon href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><link rel=apple-touch-icon href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><link rel=mask-icon href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://hcy-asleep.github.io/MySQL-%E9%97%B2%E8%B0%88-1/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><style>@media screen and (min-width:1px){.post-content input[type=checkbox]:checked~label>img{transform:scale(1.6);cursor:zoom-out;position:relative;z-index:999}.post-content img.zoomCheck{transition:transform .15s ease;z-index:999;cursor:zoom-in}}</style><meta property="og:title" content="MySQL 闲谈 1"><meta property="og:description" content=" 
对MySQL InnoDB引擎的索引了解吗？
"><meta property="og:type" content="article"><meta property="og:url" content="https://hcy-asleep.github.io/MySQL-%E9%97%B2%E8%B0%88-1/"><meta property="og:image" content="https://hcy-asleep.github.io/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-11-05T21:50:29+00:00"><meta property="article:modified_time" content="2022-11-05T21:50:29+00:00"><meta property="og:site_name" content="HCY-BLOGS"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hcy-asleep.github.io/"><meta name=twitter:title content="MySQL 闲谈 1"><meta name=twitter:description content=" 
对MySQL InnoDB引擎的索引了解吗？
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hcy-asleep.github.io/post/"},{"@type":"ListItem","position":2,"name":"MySQL 闲谈 1","item":"https://hcy-asleep.github.io/MySQL-%E9%97%B2%E8%B0%88-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MySQL 闲谈 1","name":"MySQL 闲谈 1","description":" 对MySQL InnoDB引擎的索引了解吗？ ","keywords":["数据库","MySQL","对话"],"articleBody":" 对MySQL InnoDB引擎的索引了解吗？ 嗯啊，使用索引可以加快查询速度，其实就是将无序的数据变成有序（有序就能加快检索速度） 在InnoDB引擎中，索引的底层数据结构是B+树 那为什么不使用红黑树或者B树呢？ MySQL的数据是存储在硬盘的，在查询时一般是不能「一次性」把全部数据加载到内存中 红黑树是「二叉查找树」的变种，一个Node节点只能存储一个Key和一个Value B和B+树跟红黑树不一样，它们算是「多路搜索树」，相较于「二叉搜索树」而言，一个Node节点可以存储的信息会更多，「多路搜索树」的高度会比「二叉搜索树」更低 了解了区别之后，其实就很容易发现，在数据不能一次加载至内存的场景下，数据需要被检索出来，选择B或B+树的理由就很充分了（一个Node节点存储信息更多（相较于二叉搜索树），树的高度更低，树的高度影响检索的速度） B+树相对于B树而言，它又有两种特性 一、B+树非叶子节点不存储数据，在相同的数据量下，B+树更加矮壮。（这个应该不用多解释了，数据都存储在叶子节点上，非叶子节点的存储能存储更多的索引，所以整棵树就更加矮壮） 二、B+树叶子节点之间组成一个链表，方便于遍历查询（遍历操作在MySQL中比较常见） 我稍微解释一下吧，你可以脑补下画面 我们在MySQL InnoDB引擎下，每创建一个索引，相当于生成了一颗B+树 如果该索引是「聚集(聚簇)索引」，那当前B+树的叶子节点存储着「主键和当前行的数据」 如果该索引是「非聚簇索引」，那当前B+树的叶子节点存储着「主键和当前索引列值」 比如写了一句sql：select * from user where id \u003e=10，那只要定位到id为10的记录，然后在叶子节点之间通过遍历链表(叶子节点组成的链表)，即可以找到往后的记录了 由于B树是会在非叶子节点也存储数据，要遍历的时候可能就得跨层检索，相对麻烦些 基于树的层级以及业务使用场景的特性，所以MySQL选择了B+树作为索引的底层数据结构 对于哈希结构，其实InnoDB引擎是「自适应」哈希索引的（hash索引的创建由InnoDB存储引擎引擎自动优化创建，我们是干预不了） 嗯…那我了解了，顺便想问下，你知道什么叫做回表吗？ 所谓的回表其实就是，当我们使用索引查询数据时，检索出来的数据可能包含其他列，但走的索引树叶子节点只能查到当前列值以及主键ID，所以需要根据主键ID再去查一遍数据，得到SQL 所需的列 举个例子，我这边建了给订单号ID建了个索引，但我的SQL 是：select orderId,orderName from orderdetail where orderId = 123 SQL都订单ID索引，但在订单ID的索引树的叶子节点只有orderId和Id，而我们还想检索出orderName，所以MySQL 会拿到ID再去查出orderName给我们返回，这种操作就叫回表 想要避免回表，也可以使用覆盖索引（能使用就使用，因为避免了回表操作） 所谓的覆盖索引，实际上就是你想要查出的列刚好在叶子节点上都存在，比如我建了orderId和orderName联合索引，刚好我需要查询也是orderId和orderName，这些数据都存在索引树的叶子节点上，就不需要回表操作了 既然你也提到了联合索引，我想问下你了解最左匹配原则吗？ 嗯，说明这个概念，还是举例子比较容易说明 如有索引 (a,b,c,d)，查询条件 a=1 and b=2 and c\u003e3 and d=4，则会在每个节点依次命中a、b、c，无法命中d 先匹配最左边的，索引只能用于查找key是否存在（相等），遇到范围查询 (\u003e、\u003c、between、like左匹配)等就不能进一步匹配了，后续退化为线性查找 这就是最左匹配原则 嗯嗯，我还想问下你们主键是怎么生成的？ 主键就自增的 那假设我不用MySQL自增的主键，你觉得会有什么问题呢？ 首先主键得保证它的唯一性和空间尽可能短吧，这两块是需要考虑的 另外，由于索引的特性（有序），如果生成像uuid类似的主键，那插入的的性能是比自增的要差的 因为生成的uuid，在插入时有可能需要移动磁盘块（比如，块内的空间在当前时刻已经存储满了，但新生成的uuid需要插入已满的块内，就需要移动块的数据） OK… Summary\n为什么B+树？\n数据无法一次load到内存，B+树是多路搜索树，只有叶子节点才存储数据，叶子节点之间链表进行关联。（树矮，易遍历） 什么是回表？\n非聚簇索引在叶子节点只存储列值以及主键ID，有条件下尽可能用覆盖索引避免回表操作，提高查询速度 什么是最左匹配原则？\n从最左边为起点开始连续匹配，遇到范围查询终止 主键非自增会有什么问题？\n插入效率下降，存在移动块的数据问题 ","wordCount":"73","inLanguage":"zh","image":"https://hcy-asleep.github.io/","datePublished":"2022-11-05T21:50:29Z","dateModified":"2022-11-05T21:50:29Z","author":{"@type":"Person","name":"HCY"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://hcy-asleep.github.io/MySQL-%E9%97%B2%E8%B0%88-1/"},"publisher":{"@type":"Organization","name":"Memos","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://hcy-asleep.github.io/ accesskey=h title="主页 (Alt + H)">主页</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://hcy-asleep.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://hcy-asleep.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://hcy-asleep.github.io/categories/ title=目录><span>目录</span></a></li><li><a href=https://hcy-asleep.github.io/friends/ title=友链><span>友链</span></a></li><li><a href=https://hcy-asleep.github.io/todo/ title=TODO><span>TODO</span></a></li><li><a href=https://hcy-asleep.github.io/about/ title=关于><span>关于</span></a></li><li><a href=https://hcy-asleep.github.io/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://hcy-asleep.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://hcy-asleep.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">MySQL 闲谈 1</h1><div class=post-meta><span title='2022-11-05 21:50:29 +0000 UTC'>十一月 5, 2022</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;73 字&nbsp;·&nbsp;HCY&nbsp;|&nbsp;<a href=https://github.com/HCY-ASLEEP rel="noopener noreferrer" target=_blank> Follow me</a></div></header><div class=post-content><div align=left><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>对MySQL InnoDB引擎的索引了解吗？</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>嗯啊，使用索引可以加快查询速度，其实就是将无序的数据变成有序（有序就能加快检索速度）</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>在InnoDB引擎中，索引的底层数据结构是B+树</div></div><br><div align=left><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>那为什么不使用红黑树或者B树呢？</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>MySQL的数据是存储在硬盘的，在查询时一般是不能「一次性」把全部数据加载到内存中</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>红黑树是「二叉查找树」的变种，一个Node节点只能存储一个Key和一个Value</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>B和B+树跟红黑树不一样，它们算是「多路搜索树」，相较于「二叉搜索树」而言，一个Node节点可以存储的信息会更多，「多路搜索树」的高度会比「二叉搜索树」更低</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>了解了区别之后，其实就很容易发现，在数据不能一次加载至内存的场景下，数据需要被检索出来，选择B或B+树的理由就很充分了（一个Node节点存储信息更多（相较于二叉搜索树），树的高度更低，树的高度影响检索的速度）</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>B+树相对于B树而言，它又有两种特性</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>一、B+树非叶子节点不存储数据，在相同的数据量下，B+树更加矮壮。（这个应该不用多解释了，数据都存储在叶子节点上，非叶子节点的存储能存储更多的索引，所以整棵树就更加矮壮）</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>二、B+树叶子节点之间组成一个链表，方便于遍历查询（遍历操作在MySQL中比较常见）</div></div><br><div align=right><div style=width:80%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center><img src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/v2-54a18a07f7adfbda09983b815a92c5b8_r.jpg></div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>我稍微解释一下吧，你可以脑补下画面</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>我们在MySQL InnoDB引擎下，每创建一个索引，相当于生成了一颗B+树</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>如果该索引是「聚集(聚簇)索引」，那当前B+树的叶子节点存储着「主键和当前行的数据」</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>如果该索引是「非聚簇索引」，那当前B+树的叶子节点存储着「主键和当前索引列值」</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>比如写了一句sql：select * from user where id >=10，那只要定位到id为10的记录，然后在叶子节点之间通过遍历链表(叶子节点组成的链表)，即可以找到往后的记录了</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>由于B树是会在非叶子节点也存储数据，要遍历的时候可能就得跨层检索，相对麻烦些</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>基于树的层级以及业务使用场景的特性，所以MySQL选择了B+树作为索引的底层数据结构</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>对于哈希结构，其实InnoDB引擎是「自适应」哈希索引的（hash索引的创建由InnoDB存储引擎引擎自动优化创建，我们是干预不了）</div></div><br><div align=left><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>嗯…那我了解了，顺便想问下，你知道什么叫做回表吗？</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>所谓的回表其实就是，当我们使用索引查询数据时，检索出来的数据可能包含其他列，但走的索引树叶子节点只能查到当前列值以及主键ID，所以需要根据主键ID再去查一遍数据，得到SQL 所需的列</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>举个例子，我这边建了给订单号ID建了个索引，但我的SQL 是：select orderId,orderName from orderdetail where orderId = 123</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>SQL都订单ID索引，但在订单ID的索引树的叶子节点只有orderId和Id，而我们还想检索出orderName，所以MySQL 会拿到ID再去查出orderName给我们返回，这种操作就叫回表</div></div><br><div align=right><div style=width:80%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center><img src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/v2-2393680d1df54c696f97c8194b34237c_r.jpg></div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>想要避免回表，也可以使用覆盖索引（能使用就使用，因为避免了回表操作）</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>所谓的覆盖索引，实际上就是你想要查出的列刚好在叶子节点上都存在，比如我建了orderId和orderName联合索引，刚好我需要查询也是orderId和orderName，这些数据都存在索引树的叶子节点上，就不需要回表操作了</div></div><br><div align=left><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>既然你也提到了联合索引，我想问下你了解最左匹配原则吗？</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>嗯，说明这个概念，还是举例子比较容易说明</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>如有索引 (a,b,c,d)，查询条件 a=1 and b=2 and c>3 and d=4，则会在每个节点依次命中a、b、c，无法命中d</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>先匹配最左边的，索引只能用于查找key是否存在（相等），遇到范围查询 (>、<、between、like左匹配)等就不能进一步匹配了，后续退化为线性查找</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>这就是最左匹配原则</div></div><br><div align=right><div style=width:80%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center><img src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/v2-6d6af5c6cfe9be27d1f41af4d7860d3a_r.jpg></div></div><br><div align=left><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>嗯嗯，我还想问下你们主键是怎么生成的？</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>主键就自增的</div></div><br><div align=left><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>那假设我不用MySQL自增的主键，你觉得会有什么问题呢？</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>首先主键得保证它的唯一性和空间尽可能短吧，这两块是需要考虑的</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>另外，由于索引的特性（有序），如果生成像uuid类似的主键，那插入的的性能是比自增的要差的</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>因为生成的uuid，在插入时有可能需要移动磁盘块（比如，块内的空间在当前时刻已经存储满了，但新生成的uuid需要插入已满的块内，就需要移动块的数据）</div></div><br><div align=left><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>OK…</div></div><br><div align=right><div style=width:80%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center><img src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/v2-ca51dbec74c22029ebde0650378dfbfd_r.jpg></div></div><br><p><strong>Summary</strong></p><ul><li><p><strong>为什么B+树？</strong></p><ul><li>数据无法一次load到内存，B+树是多路搜索树，只有叶子节点才存储数据，叶子节点之间链表进行关联。（树矮，易遍历）</li></ul></li></ul></br><ul><li><p><strong>什么是回表？</strong></p><ul><li>非聚簇索引在叶子节点只存储列值以及主键ID，有条件下尽可能用覆盖索引避免回表操作，提高查询速度</li></ul></li></ul></br><ul><li><p><strong>什么是最左匹配原则？</strong></p><ul><li>从最左边为起点开始连续匹配，遇到范围查询终止</li></ul></li></ul></br><ul><li><p><strong>主键非自增会有什么问题？</strong></p><ul><li>插入效率下降，存在移动块的数据问题</li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://hcy-asleep.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a></li><li><a href=https://hcy-asleep.github.io/tags/MySQL/>MySQL</a></li><li><a href=https://hcy-asleep.github.io/tags/%E5%AF%B9%E8%AF%9D/>对话</a></li></ul><nav class=paginav><a class=prev href=https://hcy-asleep.github.io/MySQL-%E9%97%B2%E8%B0%88-2/><span class=title>« 上一页</span><br><span>MySQL 闲谈 2</span>
</a><a class=next href=https://hcy-asleep.github.io/Markdown-%E5%AF%B9%E8%AF%9D%E6%A1%86/><span class=title>下一页 »</span><br><span>Markdown 对话框</span></a></nav></footer></br></br><script src=https://giscus.app/client.js data-repo=HCY-ASLEEP/HCY-ASLEEP.github.io data-repo-id=R_kgDOISFjNg data-category=Announcements data-category-id=DIC_kwDOISFjNs4CUJyb data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://hcy-asleep.github.io/>Memos</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>