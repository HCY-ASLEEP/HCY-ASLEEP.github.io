<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MySQL 闲谈 2 | Memos</title>
<meta name=keywords content="数据库,MySQL,对话"><meta name=description content="
你是怎么理解InnoDB引擎中的事务的？
"><meta name=author content="HCY"><link rel=canonical href=https://hcy-asleep.github.io/MySQL-%E9%97%B2%E8%B0%88-2/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bbe7c693ba1e57651eda5c9f7653fe0f608bca43c4b67d413bde2747e48dd912.css integrity="sha256-u+fGk7oeV2Ue2lyfdlP+D2CLykPEtn1BO94nR+SN2RI=" rel="preload stylesheet" as=style><link rel=icon href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><link rel=apple-touch-icon href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><link rel=mask-icon href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://hcy-asleep.github.io/MySQL-%E9%97%B2%E8%B0%88-2/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><style>@media screen and (min-width:1px){.post-content input[type=checkbox]:checked~label>img{transform:scale(1.6);cursor:zoom-out;position:relative;z-index:999}.post-content img.zoomCheck{transition:transform .15s ease;z-index:999;cursor:zoom-in}}</style><meta property="og:title" content="MySQL 闲谈 2"><meta property="og:description" content="
你是怎么理解InnoDB引擎中的事务的？
"><meta property="og:type" content="article"><meta property="og:url" content="https://hcy-asleep.github.io/MySQL-%E9%97%B2%E8%B0%88-2/"><meta property="og:image" content="https://hcy-asleep.github.io/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-11-06T16:14:33+00:00"><meta property="article:modified_time" content="2022-11-06T16:14:33+00:00"><meta property="og:site_name" content="HCY-BLOGS"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hcy-asleep.github.io/"><meta name=twitter:title content="MySQL 闲谈 2"><meta name=twitter:description content="
你是怎么理解InnoDB引擎中的事务的？
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hcy-asleep.github.io/post/"},{"@type":"ListItem","position":2,"name":"MySQL 闲谈 2","item":"https://hcy-asleep.github.io/MySQL-%E9%97%B2%E8%B0%88-2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MySQL 闲谈 2","name":"MySQL 闲谈 2","description":" 你是怎么理解InnoDB引擎中的事务的？ ","keywords":["数据库","MySQL","对话"],"articleBody":" 你是怎么理解InnoDB引擎中的事务的？ 在我的理解下，事务可以使「一组操作」要么全部成功，要么全部失败 事务其目的是为了「保证数据最终的一致性」 举个例子，我给你发支付宝转了888块红包。那自然我的支付宝余额会扣减888块，你的支付宝余额会增加888块 而事务就是保证我的余额扣减跟你的余额增添是同时成功或者同时失败的，这样这次转账就正常了 嗯，那你了解事务的几大特性吗？ 嗯，就是ACID嘛，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability） 原子性指的是：当前事务的操作要么同时成功，要么同时失败。原子性由undo log日志来保证，因为undo log记载着数据修改前的信息 比如我们要 insert 一条数据了，那undo log 会记录的一条对应的 delete 日志。我们要 update 一条记录时，那undo log会记录之前的「旧值」的update记录 如果执行事务过程中出现异常的情况，那执行「回滚」。InnoDB引擎就是利用undo log记录下的数据，来将数据「恢复」到事务开始之前 一致性我稍稍往后讲，我先来说下隔离性 嗯… 隔离性指的是：在事务「并发」执行时，他们内部的操作不能互相干扰。如果多个事务可以同时操作一个数据，那么就会产生脏读、重复读、幻读的问题 于是，事务与事务之间需要存在「一定」的隔离，在InnoDB引擎中，定义了四种隔离级别供我们使用 分别是：read uncommit(读未提交)、read commit (读已提交)、repeatable read (可重复复读)、serializable (串行) 不同的隔离级别对事务之间的隔离性是不一样的（级别越高事务隔离性越好，但性能就越低），而隔离性是由MySQL的各种锁来实现的，只是它屏蔽了加锁的细节 持久性指的就是：一旦提交了事务，它对数据库的改变就应该是永久性的。说白了就是，会将数据持久化在硬盘上 而持久性由redo log 日志来保证，当我们要修改数据时，MySQL是先把这条记录所在的「页」找到，然后把该页加载到内存中，将对应记录进行修改 为了防止内存修改完了，MySQL就挂掉了（如果内存改完，直接挂掉，那这次的修改相当于就丢失了） MySQL引入了redo log，内存写完了，然后会写一份redo log，这份redo log记载着这次在某个页上做了什么修改 即便MySQL在中途挂了，我们还可以根据redo log来对数据进行恢复 redo log 是顺序写的，写入速度很快。并且它记录的是物理修改（xxxx页做了xxx修改），文件的体积很小，恢复速度也很快 回头再来讲一致性，「一致性」可以理解为我们使用事务的「目的」，而「隔离性」「原子性」「持久性」均是为了保障「一致性」的手段，保证一致性需要由应用程序代码来保证 比如，如果事务在发生的过程中，出现了异常情况，此时你就得回滚事务，而不是强行提交事务来导致数据不一致 嗯，挺好的，讲了蛮多的 刚才你也提到了隔离性嘛，然后你说在MySQL中有四种隔离级别，能分别来介绍下吗？ 嗯，为了讲清楚隔离级别，我顺带来说下MySQL锁相关的知识吧 在InnoDB引擎下，按锁的粒度分类，可以简单分为行锁和表锁 行锁实际上是作用在索引之上的（索引上次已经说过了，这里就不赘述了）。当我们的SQL命中了索引，那锁住的就是命中条件内的索引节点（这种就是行锁），如果没有命中索引，那我们锁的就是整个索引树（表锁） 简单来说就是：锁住的是整棵树还是某几个节点，完全取决于SQL条件是否有命中到对应的索引节点 而行锁又可以简单分为读锁（共享锁、S锁）和写锁（排它锁、X锁） 读锁是共享的，多个事务可以同时读取同一个资源，但不允许其他事务修改。写锁是排他的，写锁会阻塞其他的写锁和读锁 我现在就再回到隔离级别上吧，就直接以例子来说明啦 嗯… 首先来说下read uncommit(读未提交)。比如说：A向B转账，A执行了转账语句，但A还没有提交事务，B读取数据，发现自己账户钱变多了！B跟A说，我已经收到钱了。A回滚事务【rollback】，等B再查看账户的钱时，发现钱并没有多 简单的定义就是：事务B读取到了事务A还没提交的数据，这种用专业术语来说叫做「脏读」 对于锁的维度而言，其实就是在read uncommit隔离级别下，读不会加任何锁，而写会加排他锁。读什么锁都不加，这就让排他锁无法排它了 而我们又知道，对于更新操作而言，InnoDB是肯定会加写锁的（数据库是不可能允许在同一时间，更新同一条记录的）。而读操作，如果不加任何锁，那就会造成上面的脏读 脏读在生产环境下肯定是无法接受的，那如果读加锁的话，那意味着：当更新数据的时，就没办法读取了，这会极大地降低数据库性能 在MySQL InnoDB引擎层面，又有新的解决方案（解决加锁后读写性能问题），叫做MVCC(Multi-Version Concurrency Control)多版本并发控制 在MVCC下，就可以做到读写不阻塞，且避免了类似脏读这样的问题 那MVCC是怎么做的呢？ MVCC通过生成数据快照（Snapshot)，并用这个快照来提供一定级别（语句级或事务级）的一致性读取 回到事务隔离级别下，针对于 read commit (读已提交) 隔离级别，它生成的就是语句级快照，而针对于repeatable read (可重复读)，它生成的就是事务级的快照 前面提到过read uncommit隔离级别下会产生脏读，而read commit (读已提交) 隔离级别解决了脏读。思想其实很简单：在读取的时候生成一个”版本号”，等到其他事务commit了之后，才会读取最新已commit的”版本号”数据 比如说：事务A读取了记录(生成版本号)，事务B修改了记录(此时加了写锁)，事务A再读取的时候，是依据最新的版本号来读取的(当事务B执行commit了之后，会生成一个新的版本号)，如果事务B还没有commit，那事务A读取的还是之前版本号的数据 通过「版本」的概念，这样就解决了脏读的问题，而「版本」其实就是对应快照的数据 read commit (读已提交) 解决了脏读，但也会有其他并发的问题。「不可重复读」：一个事务读取到另外一个事务已经提交的数据，也就是说一个事务可以看到其他事务所做的修改 不可重复读的例子：A查询数据库得到数据，B去修改数据库的数据，导致A多次查询数据库的结果都不一样【危害：A每次查询的结果都是受B的影响的】 了解MVCC基础之后，就很容易想到repeatable read (可重复复读)隔离级别是怎么避免不可重复读的问题了（前面也提到了） repeatable read (可重复复读)隔离级别是「事务级别」的快照！每次读取的都是「当前事务的版本」，即使当前数据被其他事务修改了(commit)，也只会读取当前事务版本的数据 而repeatable read (可重复复读)隔离级别会存在幻读的问题，「幻读」指的是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致 在InnoDB引擎下的的repeatable read (可重复复读)隔离级别下，快照读MVCC影响下，已经解决了幻读的问题（因为它是读历史版本的数据） 而如果是当前读（指的是 select * from table for update），则需要配合间隙锁来解决幻读的问题 剩下的就是serializable (串行)隔离级别了，它的最高的隔离级别，相当于不允许事务的并发，事务与事务之间执行是串行的，它的效率最低，但同时也是最安全的 嗯，不妨来说下MVCC的原理？ MVCC的主要是通过read view和undo log来实现的 undo log前面也提到了，它会记录修改数据之前的信息，事务中的原子性就是通过undo log来实现的。所以，有undo log可以帮我们找到「版本」的数据 而read view 实际上就是在查询时，InnoDB会生成一个read view，read view 有几个重要的字段，分别是：trx_ids（尚未提交commit的事务版本号集合），up_limit_id（下一次要生成的事务ID值），low_limit_id（尚未提交版本号的事务ID最小值）以及creator_trx_id（当前的事务版本号） 在每行数据有两列隐藏的字段，分别是DB_TRX_ID（记录着当前ID）以及DB_ROLL_PTR（指向上一个版本数据在undo log 里的位置指针） 铺垫到这了，很容易就发现，MVCC其实就是靠「比对版本」来实现读写不阻塞，而版本的数据存在于undo log中 而针对于不同的隔离级别（read commit和repeatable read），无非就是read commit隔离级别下，每次都获取一个新的read view，repeatable read隔离级别则每次事务只获取一个read view 嗯，OK的。细节就不考究了，今天就到这里吧 Summary\n事务为了保证数据的最终一致性 事务有四大特性，分别是原子性、一致性、隔离性、持久性\n原子性由undo log保证 持久性由redo log 保证 隔离性由数据库隔离级别供我们选择，分别有read uncommit,read commit,repeatable read,serializable 一致性是事务的目的，一致性由应用程序来保证 事务并发会存在各种问题，分别有脏读、重复读、幻读问题，上面的不同隔离级别可以解决掉由于并发事务所造成的问题，而隔离级别实际上就是由MySQL锁来实现的 频繁加锁会导致数据库性能低下，引入了MVCC多版本控制来实现读写不阻塞，提高数据库性能 MVCC原理即通过read view 以及undo log来实现 ","wordCount":"160","inLanguage":"zh","image":"https://hcy-asleep.github.io/","datePublished":"2022-11-06T16:14:33Z","dateModified":"2022-11-06T16:14:33Z","author":{"@type":"Person","name":"HCY"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://hcy-asleep.github.io/MySQL-%E9%97%B2%E8%B0%88-2/"},"publisher":{"@type":"Organization","name":"Memos","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://hcy-asleep.github.io/ accesskey=h title="主页 (Alt + H)">主页</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://hcy-asleep.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://hcy-asleep.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://hcy-asleep.github.io/categories/ title=目录><span>目录</span></a></li><li><a href=https://hcy-asleep.github.io/friends/ title=友链><span>友链</span></a></li><li><a href=https://hcy-asleep.github.io/about/ title=关于><span>关于</span></a></li><li><a href=https://hcy-asleep.github.io/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://hcy-asleep.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://hcy-asleep.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">MySQL 闲谈 2</h1><div class=post-meta><span title='2022-11-06 16:14:33 +0000 UTC'>十一月 6, 2022</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;160 字&nbsp;·&nbsp;HCY&nbsp;|&nbsp;<a href=https://github.com/HCY-ASLEEP rel="noopener noreferrer" target=_blank> Follow me</a></div></header><div class=post-content><div align=left><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>你是怎么理解InnoDB引擎中的事务的？</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>在我的理解下，事务可以使「一组操作」要么全部成功，要么全部失败</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>事务其目的是为了「保证数据最终的一致性」</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>举个例子，我给你发支付宝转了888块红包。那自然我的支付宝余额会扣减888块，你的支付宝余额会增加888块</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>而事务就是保证我的余额扣减跟你的余额增添是同时成功或者同时失败的，这样这次转账就正常了</div></div><br><div align=right><div style=width:80%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center><img src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/v2-3ebaa5e83396dabab44bc9d6371a384b_r.jpg></div></div><br><div align=left><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>嗯，那你了解事务的几大特性吗？</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>嗯，就是ACID嘛，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>原子性指的是：当前事务的操作要么同时成功，要么同时失败。原子性由undo log日志来保证，因为undo log记载着数据修改前的信息</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>比如我们要 insert 一条数据了，那undo log 会记录的一条对应的 delete 日志。我们要 update 一条记录时，那undo log会记录之前的「旧值」的update记录</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>如果执行事务过程中出现异常的情况，那执行「回滚」。InnoDB引擎就是利用undo log记录下的数据，来将数据「恢复」到事务开始之前</div></div><br><div align=right><div style=width:80%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center><img src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/v2-8fd6ccf7a2ef047768f34992bd1c7c30_r.jpg></div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>一致性我稍稍往后讲，我先来说下隔离性</div></div><br><div align=left><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>嗯…</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>隔离性指的是：在事务「并发」执行时，他们内部的操作不能互相干扰。如果多个事务可以同时操作一个数据，那么就会产生脏读、重复读、幻读的问题</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>于是，事务与事务之间需要存在「一定」的隔离，在InnoDB引擎中，定义了四种隔离级别供我们使用</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>分别是：read uncommit(读未提交)、read commit (读已提交)、repeatable read (可重复复读)、serializable (串行)</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>不同的隔离级别对事务之间的隔离性是不一样的（级别越高事务隔离性越好，但性能就越低），而隔离性是由MySQL的各种锁来实现的，只是它屏蔽了加锁的细节</div></div><br><div align=right><div style=width:80%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center><img src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/v2-12c1d8d4396bb7d0383f72b5eb4d77d6_r.jpg></div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>持久性指的就是：一旦提交了事务，它对数据库的改变就应该是永久性的。说白了就是，会将数据持久化在硬盘上</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>而持久性由redo log 日志来保证，当我们要修改数据时，MySQL是先把这条记录所在的「页」找到，然后把该页加载到内存中，将对应记录进行修改</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>为了防止内存修改完了，MySQL就挂掉了（如果内存改完，直接挂掉，那这次的修改相当于就丢失了）</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>MySQL引入了redo log，内存写完了，然后会写一份redo log，这份redo log记载着这次在某个页上做了什么修改</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>即便MySQL在中途挂了，我们还可以根据redo log来对数据进行恢复</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>redo log 是顺序写的，写入速度很快。并且它记录的是物理修改（xxxx页做了xxx修改），文件的体积很小，恢复速度也很快</div></div><br><div align=right><div style=width:80%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center><img src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/v2-2325a411c8f9da2e8c5f83367d913793_r.jpg></div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>回头再来讲一致性，「一致性」可以理解为我们使用事务的「目的」，而「隔离性」「原子性」「持久性」均是为了保障「一致性」的手段，保证一致性需要由应用程序代码来保证</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>比如，如果事务在发生的过程中，出现了异常情况，此时你就得回滚事务，而不是强行提交事务来导致数据不一致</div></div><br><div align=right><div style=width:80%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center><img src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/v2-e5c89083071510afe2afd6e6dc337efa_r.jpg></div></div><br><div align=left><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>嗯，挺好的，讲了蛮多的</div></div><br><div align=left><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>刚才你也提到了隔离性嘛，然后你说在MySQL中有四种隔离级别，能分别来介绍下吗？</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>嗯，为了讲清楚隔离级别，我顺带来说下MySQL锁相关的知识吧</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>在InnoDB引擎下，按锁的粒度分类，可以简单分为行锁和表锁</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>行锁实际上是作用在索引之上的（索引上次已经说过了，这里就不赘述了）。当我们的SQL命中了索引，那锁住的就是命中条件内的索引节点（这种就是行锁），如果没有命中索引，那我们锁的就是整个索引树（表锁）</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>简单来说就是：锁住的是整棵树还是某几个节点，完全取决于SQL条件是否有命中到对应的索引节点</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>而行锁又可以简单分为读锁（共享锁、S锁）和写锁（排它锁、X锁）</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>读锁是共享的，多个事务可以同时读取同一个资源，但不允许其他事务修改。写锁是排他的，写锁会阻塞其他的写锁和读锁</div></div><br><div align=right><div style=width:80%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center><img src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/v2-4ed4e54af979a73c24db83133be59359_r.jpg></div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>我现在就再回到隔离级别上吧，就直接以例子来说明啦</div></div><br><div align=left><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>嗯…</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>首先来说下read uncommit(读未提交)。比如说：A向B转账，A执行了转账语句，但A还没有提交事务，B读取数据，发现自己账户钱变多了！B跟A说，我已经收到钱了。A回滚事务【rollback】，等B再查看账户的钱时，发现钱并没有多</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>简单的定义就是：事务B读取到了事务A还没提交的数据，这种用专业术语来说叫做「脏读」</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>对于锁的维度而言，其实就是在read uncommit隔离级别下，读不会加任何锁，而写会加排他锁。读什么锁都不加，这就让排他锁无法排它了</div></div><br><div align=right><div style=width:80%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center><img src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/v2-6792ec868544bf39078b7e9255ff4f53_r.jpg></div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>而我们又知道，对于更新操作而言，InnoDB是肯定会加写锁的（数据库是不可能允许在同一时间，更新同一条记录的）。而读操作，如果不加任何锁，那就会造成上面的脏读</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>脏读在生产环境下肯定是无法接受的，那如果读加锁的话，那意味着：当更新数据的时，就没办法读取了，这会极大地降低数据库性能</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>在MySQL InnoDB引擎层面，又有新的解决方案（解决加锁后读写性能问题），叫做MVCC(Multi-Version Concurrency Control)多版本并发控制</div></div><br><div align=right><div style=width:80%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center><img src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/v2-7e397fcccc1d5dc2a519b45bf36d334f_r.jpg></div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>在MVCC下，就可以做到读写不阻塞，且避免了类似脏读这样的问题</div></div><br><div align=left><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>那MVCC是怎么做的呢？</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>MVCC通过生成数据快照（Snapshot)，并用这个快照来提供一定级别（语句级或事务级）的一致性读取</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>回到事务隔离级别下，针对于 read commit (读已提交) 隔离级别，它生成的就是语句级快照，而针对于repeatable read (可重复读)，它生成的就是事务级的快照</div></div><br><div align=right><div style=width:80%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center><img src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/v2-93fe1254a1c756b4ec092e44a2c6de12_r.jpg></div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>前面提到过read uncommit隔离级别下会产生脏读，而read commit (读已提交) 隔离级别解决了脏读。思想其实很简单：在读取的时候生成一个”版本号”，等到其他事务commit了之后，才会读取最新已commit的”版本号”数据</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>比如说：事务A读取了记录(生成版本号)，事务B修改了记录(此时加了写锁)，事务A再读取的时候，是依据最新的版本号来读取的(当事务B执行commit了之后，会生成一个新的版本号)，如果事务B还没有commit，那事务A读取的还是之前版本号的数据</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>通过「版本」的概念，这样就解决了脏读的问题，而「版本」其实就是对应快照的数据</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>read commit (读已提交) 解决了脏读，但也会有其他并发的问题。「不可重复读」：一个事务读取到另外一个事务已经提交的数据，也就是说一个事务可以看到其他事务所做的修改</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>不可重复读的例子：A查询数据库得到数据，B去修改数据库的数据，导致A多次查询数据库的结果都不一样【危害：A每次查询的结果都是受B的影响的】</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>了解MVCC基础之后，就很容易想到repeatable read (可重复复读)隔离级别是怎么避免不可重复读的问题了（前面也提到了）</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>repeatable read (可重复复读)隔离级别是「事务级别」的快照！每次读取的都是「当前事务的版本」，即使当前数据被其他事务修改了(commit)，也只会读取当前事务版本的数据</div></div><br><div align=right><div style=width:80%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center><img src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/v2-7e397fcccc1d5dc2a519b45bf36d334f_r.jpg></div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>而repeatable read (可重复复读)隔离级别会存在幻读的问题，「幻读」指的是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>在InnoDB引擎下的的repeatable read (可重复复读)隔离级别下，快照读MVCC影响下，已经解决了幻读的问题（因为它是读历史版本的数据）</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>而如果是当前读（指的是 select * from table for update），则需要配合间隙锁来解决幻读的问题</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>剩下的就是serializable (串行)隔离级别了，它的最高的隔离级别，相当于不允许事务的并发，事务与事务之间执行是串行的，它的效率最低，但同时也是最安全的</div></div><br><div align=left><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>嗯，不妨来说下MVCC的原理？</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>MVCC的主要是通过read view和undo log来实现的</div></div><br><div align=right><div style=width:80%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center><img src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/v2-cc344b44fe34fc54ec6c9e2f28a4aa2d_r.jpg></div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>undo log前面也提到了，它会记录修改数据之前的信息，事务中的原子性就是通过undo log来实现的。所以，有undo log可以帮我们找到「版本」的数据</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>而read view 实际上就是在查询时，InnoDB会生成一个read view，read view 有几个重要的字段，分别是：trx_ids（尚未提交commit的事务版本号集合），up_limit_id（下一次要生成的事务ID值），low_limit_id（尚未提交版本号的事务ID最小值）以及creator_trx_id（当前的事务版本号）</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>在每行数据有两列隐藏的字段，分别是DB_TRX_ID（记录着当前ID）以及DB_ROLL_PTR（指向上一个版本数据在undo log 里的位置指针）</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>铺垫到这了，很容易就发现，MVCC其实就是靠「比对版本」来实现读写不阻塞，而版本的数据存在于undo log中</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>而针对于不同的隔离级别（read commit和repeatable read），无非就是read commit隔离级别下，每次都获取一个新的read view，repeatable read隔离级别则每次事务只获取一个read view</div></div><br><div align=left><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>嗯，OK的。细节就不考究了，今天就到这里吧</div></div><br><p><strong>Summary</strong></p><ul><li>事务为了保证数据的最终一致性</li></ul></br><ul><li><p>事务有四大特性，分别是原子性、一致性、隔离性、持久性</p><ul><li>原子性由undo log保证</li><li>持久性由redo log 保证</li><li>隔离性由数据库隔离级别供我们选择，分别有read uncommit,read commit,repeatable read,serializable</li><li>一致性是事务的目的，一致性由应用程序来保证</li></ul></li></ul></br><ul><li>事务并发会存在各种问题，分别有脏读、重复读、幻读问题，上面的不同隔离级别可以解决掉由于并发事务所造成的问题，而隔离级别实际上就是由MySQL锁来实现的</li></ul></br><ul><li>频繁加锁会导致数据库性能低下，引入了MVCC多版本控制来实现读写不阻塞，提高数据库性能</li></ul></br><ul><li>MVCC原理即通过read view 以及undo log来实现</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://hcy-asleep.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a></li><li><a href=https://hcy-asleep.github.io/tags/MySQL/>MySQL</a></li><li><a href=https://hcy-asleep.github.io/tags/%E5%AF%B9%E8%AF%9D/>对话</a></li></ul><nav class=paginav><a class=prev href=https://hcy-asleep.github.io/MySQL-%E9%97%B2%E8%B0%88-3/><span class=title>« 上一页</span><br><span>MySQL 闲谈 3</span>
</a><a class=next href=https://hcy-asleep.github.io/MySQL-%E9%97%B2%E8%B0%88-1/><span class=title>下一页 »</span><br><span>MySQL 闲谈 1</span></a></nav></footer></br></br><script src=https://giscus.app/client.js data-repo=HCY-ASLEEP/HCY-ASLEEP.github.io data-repo-id=R_kgDOISFjNg data-category=Announcements data-category-id=DIC_kwDOISFjNs4CUJyb data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://hcy-asleep.github.io/>Memos</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>