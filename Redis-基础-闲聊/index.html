<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Redis-基础-闲聊 | Memos</title>
<meta name=keywords content="对话,Redis"><meta name=description content="
今天要不来聊聊Redis吧？
"><meta name=author content="HCY"><link rel=canonical href=https://hcy-asleep.github.io/Redis-%E5%9F%BA%E7%A1%80-%E9%97%B2%E8%81%8A/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.037ff07fa4938e0e4dc0f7f3922080cb4bf20aadb4c198aaff0752376c0e2ecd.css integrity="sha256-A3/wf6STjg5NwPfzkiCAy0vyCq20wZiq/wdSN2wOLs0=" rel="preload stylesheet" as=style><link rel=icon href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><link rel=apple-touch-icon href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><link rel=mask-icon href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><style>@media screen and (min-width:1px){.post-content input[type=checkbox]:checked~label>img{transform:scale(1.6);cursor:zoom-out;position:relative;z-index:999}.post-content img.zoomCheck{transition:transform .15s ease;z-index:999;cursor:zoom-in}}</style><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Redis-基础-闲聊"><meta property="og:description" content="
今天要不来聊聊Redis吧？
"><meta property="og:type" content="article"><meta property="og:url" content="https://hcy-asleep.github.io/Redis-%E5%9F%BA%E7%A1%80-%E9%97%B2%E8%81%8A/"><meta property="og:image" content="https://hcy-asleep.github.io/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-11-07T17:36:41+00:00"><meta property="article:modified_time" content="2022-11-07T17:36:41+00:00"><meta property="og:site_name" content="HCY-BLOGS"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hcy-asleep.github.io/"><meta name=twitter:title content="Redis-基础-闲聊"><meta name=twitter:description content="
今天要不来聊聊Redis吧？
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hcy-asleep.github.io/post/"},{"@type":"ListItem","position":2,"name":"Redis-基础-闲聊","item":"https://hcy-asleep.github.io/Redis-%E5%9F%BA%E7%A1%80-%E9%97%B2%E8%81%8A/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redis-基础-闲聊","name":"Redis-基础-闲聊","description":" 今天要不来聊聊Redis吧？ ","keywords":["对话","Redis"],"articleBody":" 今天要不来聊聊Redis吧？ 好 我个人是这样理解的：无论Redis也好、MySQL也好、HDFS也好、HBase也好，他们都是存储数据的地方 因为它们的设计理念的不同，我们会根据不同的应用场景使用不同的存储 像Redis一般我们会把它用作于缓存 当然啦，日常有的应用场景比较简单，用个HashMap也能解决很多的问题了，没必要上Redis 这就好比，有的单机限流可能应对某些场景就够用了，也没必要说一定要上分布式限流把系统搞得复杂 你在项目里有用到Redis吗？怎么用的？ Redis肯定是用到的，我负责的项目几乎都会有Redis的踪影 举几个项目用的案例？ 嗯 我这边负责消息管理平台，简单来说就是发消息的 那发完消息肯定我们是得知道消息有没有下发成功的，是吧？ 于是我们系统有一套完整的链路追踪体系 其中实时的数据我们就用Redis来进行存储，有实时肯定就会有离线的嘛（离线的数据我们是存储到Hive的） 对消息进行实时链路追踪，我这边就用了Redis好几种的数据结构 分别有Set、List和Hash 嗯…. 我再稍微铺垫下链路追踪的背景吧 要在消息管理平台发消息，首先得在后台新建一个「模板」，有模板自然会有一个模板ID 对模板ID进行扩展，比如说加上日期和固定的业务参数，形成的ID可以唯一标识某个模板的下发链路 在系统上，我这边叫它为UMPID 在发送入口处会对所有需要下发的消息打上UMPID，然后在关键链路上打上对应的点位 嗯，你继续吧 接下来的工作就是清洗出统一的模型，然后根据不同维度进行处理啦。比如说： 我要看某一天下发的所有模板有哪些，那只要我把清洗出来后数据的，将对应UMPID扔到了Set就好了 我要看某一个模板的消息下发的整体链路情况，那我以UMPID为Key，Value是Hash结构，Key是state，Value则是人数 这里的state我们在下发的过程中打的关键点位，比如接收到消息打个51，消息被去重了打个61，消息成功下发了打个81… 以UMPID为Key，Hash结构的Key（State）进行不断的累加，就可以实现某一个模板的消息下发的整体链路情况 我要看某个用户当天下发的消息有哪些，以及这些消息的整体链路是如何 这边我用的是List结构，Key是userId，Value则是UMPID+state(关键点位)+processTime（处理时间) 嗯…. 简单来说，就是通过Redis丰富的数据结构来实现对下发消息多个维度的统计 不同的应用场景选择不同的数据结构，再等到透出做处理的时候，就变得十分简单了 消息下发过程中去重或者一般正常的场景就直接Key-Value就能符合需求了 像bitmap、hyperloglogs、sortset、steam等等这些数据结构在我所负责的项目用得是真不多 要是我有机会去到贵公司，贵公司有相关的应用场景，我相信我也很快就能掌握 这些数据结构底层都由对应的object来支撑着，object记录对应的「编码」 其实就是会根据key-value存储的数量或者长度来使用选择不同的底层数据结构实现 比如说：ziplist压缩列表这个底层数据结构有可能上层的实现是list、hash和sortset Hash结构的底层数据结构可能是hash和ziplist 在节省内存和性能的考量之中切换 Redis还是有点屌的啊 就你上面那个实时链路场景，可以用其他的存储替代吗？ 嗯，理论上是可以的（或许可以尝试用HBase），但总体来说没这么好吧 因为Redis拥有丰富的数据结构，在透出的时候，处理会非常的方便 如果不用Redis的话，还得做很多解析的工作 并且，我那场景的并发还是相当大的（就一条消息发送，可能就产生10条记录） 监控峰值命令处理数会去到20k+QPS，当然了，这场景我肯定用了Pipeline的（不然处理会慢很多） 综合上面并发量和实时性以及数据结构，用Redis是一个比较好的选择 嗯….你觉得为什么Redis可以这么快？ 首先，它是纯内存操作，内存本身就很快 其次，它是单线程的，Redis服务器核心是基于非阻塞的IO多路复用机制，单线程避免了多线程的频繁上下文切换问题 至于这个单线程，其实官网也有过说明（：表示使用Redis往往的瓶颈在于内与和网络，而不在于CPU 了解 ","wordCount":"55","inLanguage":"zh","datePublished":"2022-11-07T17:36:41Z","dateModified":"2022-11-07T17:36:41Z","author":{"@type":"Person","name":"HCY"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://hcy-asleep.github.io/Redis-%E5%9F%BA%E7%A1%80-%E9%97%B2%E8%81%8A/"},"publisher":{"@type":"Organization","name":"Memos","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://hcy-asleep.github.io/ accesskey=h title="主页 (Alt + H)">主页</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://hcy-asleep.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://hcy-asleep.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://hcy-asleep.github.io/categories/ title=目录><span>目录</span></a></li><li><a href=https://hcy-asleep.github.io/friends/ title=友链><span>友链</span></a></li><li><a href=https://hcy-asleep.github.io/about/ title=关于><span>关于</span></a></li><li><a href=https://hcy-asleep.github.io/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://hcy-asleep.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://hcy-asleep.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Redis-基础-闲聊</h1><div class=post-meta><span title='2022-11-07 17:36:41 +0000 UTC'>十一月 7, 2022</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;55 字&nbsp;·&nbsp;HCY&nbsp;|&nbsp;<a href=https://github.com/HCY-ASLEEP rel="noopener noreferrer" target=_blank> Follow me</a></div></header><div class=post-content><div align=left><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>今天要不来聊聊Redis吧？</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>好</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>我个人是这样理解的：无论Redis也好、MySQL也好、HDFS也好、HBase也好，他们都是存储数据的地方</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>因为它们的设计理念的不同，我们会根据不同的应用场景使用不同的存储</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>像Redis一般我们会把它用作于缓存</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>当然啦，日常有的应用场景比较简单，用个HashMap也能解决很多的问题了，没必要上Redis</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>这就好比，有的单机限流可能应对某些场景就够用了，也没必要说一定要上分布式限流把系统搞得复杂</div></div><br><div align=right><div style=width:80%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center><img src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/2022.11.07.17.43.04.png></div></div><br><div align=left><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>你在项目里有用到Redis吗？怎么用的？</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>Redis肯定是用到的，我负责的项目几乎都会有Redis的踪影</div></div><br><div align=left><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>举几个项目用的案例？</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>嗯</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>我这边负责消息管理平台，简单来说就是发消息的</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>那发完消息肯定我们是得知道消息有没有下发成功的，是吧？</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>于是我们系统有一套完整的链路追踪体系</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>其中实时的数据我们就用Redis来进行存储，有实时肯定就会有离线的嘛（离线的数据我们是存储到Hive的）</div></div><br><div align=right><div style=width:80%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center><img src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/008i3skNgy1gtyvevn728j60ko0fygm202.jpg></div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>对消息进行实时链路追踪，我这边就用了Redis好几种的数据结构</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>分别有Set、List和Hash</div></div><br><div align=left><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>嗯….</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>我再稍微铺垫下链路追踪的背景吧</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>要在消息管理平台发消息，首先得在后台新建一个「模板」，有模板自然会有一个模板ID</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>对模板ID进行扩展，比如说加上日期和固定的业务参数，形成的ID可以唯一标识某个模板的下发链路</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>在系统上，我这边叫它为UMPID</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>在发送入口处会对所有需要下发的消息打上UMPID，然后在关键链路上打上对应的点位</div></div><br><div align=right><div style=width:80%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center><img src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/008i3skNgy1gtyvfly3b7j60q205cglr02.jpg></div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>嗯，你继续吧</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>接下来的工作就是清洗出统一的模型，然后根据不同维度进行处理啦。比如说：</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>我要看某一天下发的所有模板有哪些，那只要我把清洗出来后数据的，将对应UMPID扔到了Set就好了</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>我要看某一个模板的消息下发的整体链路情况，那我以UMPID为Key，Value是Hash结构，Key是state，Value则是人数</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>这里的state我们在下发的过程中打的关键点位，比如接收到消息打个51，消息被去重了打个61，消息成功下发了打个81…</div></div><br><div align=right><div style=width:80%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center><img src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/008i3skNgy1gtyvgkxib0j60pc066aac02.jpg></div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>以UMPID为Key，Hash结构的Key（State）进行不断的累加，就可以实现某一个模板的消息下发的整体链路情况</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>我要看某个用户当天下发的消息有哪些，以及这些消息的整体链路是如何</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>这边我用的是List结构，Key是userId，Value则是UMPID+state(关键点位)+processTime（处理时间)</div></div><br><div align=left><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>嗯….</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>简单来说，就是通过Redis丰富的数据结构来实现对下发消息多个维度的统计</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>不同的应用场景选择不同的数据结构，再等到透出做处理的时候，就变得十分简单了</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>消息下发过程中去重或者一般正常的场景就直接Key-Value就能符合需求了</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>像bitmap、hyperloglogs、sortset、steam等等这些数据结构在我所负责的项目用得是真不多</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>要是我有机会去到贵公司，贵公司有相关的应用场景，我相信我也很快就能掌握</div></div><br><div align=right><div style=width:80%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center><img src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/008i3skNgy1gtyvh1wbjoj60pk06w74l02.jpg></div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>这些数据结构底层都由对应的object来支撑着，object记录对应的「编码」</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>其实就是会根据key-value存储的数量或者长度来使用选择不同的底层数据结构实现</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>比如说：ziplist压缩列表这个底层数据结构有可能上层的实现是list、hash和sortset</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>Hash结构的底层数据结构可能是hash和ziplist</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>在节省内存和性能的考量之中切换</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>Redis还是有点屌的啊</div></div><br><div align=right><div style=width:80%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center><img src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/008i3skNgy1gtyvhui46sj60py04ut9402.jpg></div></div><br><div align=left><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>就你上面那个实时链路场景，可以用其他的存储替代吗？</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>嗯，理论上是可以的（或许可以尝试用HBase），但总体来说没这么好吧</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>因为Redis拥有丰富的数据结构，在透出的时候，处理会非常的方便</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>如果不用Redis的话，还得做很多解析的工作</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>并且，我那场景的并发还是相当大的（就一条消息发送，可能就产生10条记录）</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>监控峰值命令处理数会去到20k+QPS，当然了，这场景我肯定用了Pipeline的（不然处理会慢很多）</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>综合上面并发量和实时性以及数据结构，用Redis是一个比较好的选择</div></div><br><div align=right><div style=width:80%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center><img src=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/008i3skNgy1gtyw0mlggbj60y405emy302.jpg></div></div><br><div align=left><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>嗯….你觉得为什么Redis可以这么快？</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>首先，它是纯内存操作，内存本身就很快</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>其次，它是单线程的，Redis服务器核心是基于非阻塞的IO多路复用机制，单线程避免了多线程的频繁上下文切换问题</div></div><br><div align=right><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>至于这个单线程，其实官网也有过说明（：表示使用Redis往往的瓶颈在于内与和网络，而不在于CPU</div></div><br><div align=left><div style=width:60%;border-style:solid;border-width:1px;border-radius:16px;position:relative;padding:30px;text-align:center>了解</div></div><br></div><footer class=post-footer><ul class=post-tags><li><a href=https://hcy-asleep.github.io/tags/%E5%AF%B9%E8%AF%9D/>对话</a></li><li><a href=https://hcy-asleep.github.io/tags/Redis/>Redis</a></li></ul><nav class=paginav><a class=prev href=https://hcy-asleep.github.io/Vim-Diff/><span class=title>« 上一页</span><br><span>Vim Diff</span>
</a><a class=next href=https://hcy-asleep.github.io/TCP-Shakes/Waves-Hands-%E9%97%B2%E8%B0%88/><span class=title>下一页 »</span><br><span>TCP Shakes/Waves Hands 闲谈</span></a></nav></footer></br></br><script src=https://giscus.app/client.js data-repo=HCY-ASLEEP/HCY-ASLEEP.github.io data-repo-id=R_kgDOISFjNg data-category=Announcements data-category-id=DIC_kwDOISFjNs4CUJyb data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://hcy-asleep.github.io/>Memos</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>