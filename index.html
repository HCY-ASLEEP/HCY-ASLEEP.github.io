<!doctype html><html lang=zh dir=auto><head><meta name=generator content="Hugo 0.139.3"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Memos</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="Welcome"><meta name=author content="HCY"><link rel=canonical href=https://hcy-asleep.github.io/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bbe7c693ba1e57651eda5c9f7653fe0f608bca43c4b67d413bde2747e48dd912.css integrity="sha256-u+fGk7oeV2Ue2lyfdlP+D2CLykPEtn1BO94nR+SN2RI=" rel="preload stylesheet" as=style><link rel=icon href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><link rel=apple-touch-icon href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><link rel=mask-icon href=https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://hcy-asleep.github.io/index.xml><link rel=alternate type=application/json href=https://hcy-asleep.github.io/index.json><link rel=alternate hreflang=zh href=https://hcy-asleep.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><style>@media screen and (min-width:1px){.post-content input[type=checkbox]:checked~label>img{transform:scale(1.6);cursor:zoom-out;position:relative;z-index:999}.post-content img.zoomCheck{transition:transform .15s ease;z-index:999;cursor:zoom-in}}</style><meta property="og:title" content="Memos"><meta property="og:description" content="Welcome"><meta property="og:type" content="website"><meta property="og:url" content="https://hcy-asleep.github.io/"><meta property="og:image" content="https://hcy-asleep.github.io/"><meta property="og:site_name" content="HCY-BLOGS"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hcy-asleep.github.io/"><meta name=twitter:title content="Memos"><meta name=twitter:description content="Welcome"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Memos","url":"https://hcy-asleep.github.io/","description":"Welcome","thumbnailUrl":"https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png","sameAs":["https://github.com/HCY-ASLEEP","mailto:2420066864@qq.com"]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://hcy-asleep.github.io/ accesskey=h title="主页 (Alt + H)">主页</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://hcy-asleep.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://hcy-asleep.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://hcy-asleep.github.io/categories/ title=目录><span>目录</span></a></li><li><a href=https://hcy-asleep.github.io/friends/ title=友链><span>友链</span></a></li><li><a href=https://hcy-asleep.github.io/todo/ title=TODO><span>TODO</span></a></li><li><a href=https://hcy-asleep.github.io/about/ title=关于><span>关于</span></a></li><li><a href=https://hcy-asleep.github.io/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class="first-entry home-info"><header class=entry-header><h1>Hʌllo~ 👋</h1></header><div class=entry-content>Welcome to my blog</div><footer class=entry-footer><div class=social-icons><a href=https://github.com/HCY-ASLEEP target=_blank rel="noopener noreferrer me" title=Github><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a><a href=mailto:2420066864@qq.com target=_blank rel="noopener noreferrer me" title=Email><svg viewBox="0 0 24 21" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></div></footer></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Linux 虚拟文件系统（虚拟内存文件系统）以及共享内存原理</h2></header><div class=entry-content><p>最近看了《Understanding the Linux® Virtual Memory Manager》里面的第十二章 SHARED MEMORY VIRTUAL FILESYSTEM ，对文件系统以及内存文件管理有了更加深入的了解，下面是看了这一章节之后对其中一些概念的理解以及拓展，要是想了解这一章，建议读原文，配合这篇博客辅助理解
Linux 哲学 在 Linux 里面，一切皆文件，所有的东西都可以看作一个文件，而凡是文件，都应该支持POSIX文件操作（比如 read() ，write() ，open()） 每一块内存对象，都可以被看作一个文件，一旦赋予这块内存对象相对应的文件描述，就可以使用像使用普通文件那样子操作内存对象 而这也正是 VFS（虚拟文件系统 virtual file system ，包括内存文件系统以及共享内存管理系统）的设计理念以及实现方向 VMA（virtual memory area） Linux 内核用vm_area_struct结构体描述某一段连续的虚拟内存区域VMA（virtual memory area），每个虚拟内存区域 VMA 都有自己的vm_area_struct 结构体
内存描述符 mm_struct 指向进程的整个地址空间，vm_area_struct 只是指向了虚拟空间的一段，这块虚拟内存区域VMA的地址范围为 [vm_start, vm_end) ，左开右闭 vm_area_struct 是由双向链表链接起来的，它们是按照虚拟地址降序排序的，每个这样的结构都对应描述一个地址空间范围
为了快速根据地址找到对应的 VMA，内核对其建立了红黑树索引，红黑树的每个叶子结点就是一个VMA区域，引入红黑树的好处是可以提高查找VMA的效率（即便VMA的数量翻倍，VMA的查找次数也只增加一次） 之所以这样分隔是因为每个虚拟区间可能来源不同，有的可能来自可执行映像，有的可能来自共享库，而有的可能是动态内存分配的内存区，所以对于每个由 vm_area_struct 结构所描述的区间的处理操作和它前后范围的处理操作不同，因此 linux 把虚拟内存分割管理，并利用了虚拟内存处理例程 vm_ops 来抽象对不同来源虚拟内存的处理方法
不同的虚拟区间其处理操作可能不同，linux 在这里利用了面向对象的思想，即把一个虚拟区间看成是一个对象，用 vm_area_struct 描述这个对象的属性，其中的 vm_operation 结构描述了在这个对象上的操作 虚拟内存空间管理概括图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # https://elixir.bootlin.com/linux/v2.6.0/source/include/linux/mm.h#L51 struct vm_area_struct { struct mm_struct * vm_mm; /* The address space we belong to. */ unsigned long vm_start; /* Our start address within vm_mm. */ unsigned long vm_end; /* The first byte after our end address within vm_mm. */ /* linked list of VM areas per task, sorted by address */ struct vm_area_struct *vm_next; pgprot_t vm_page_prot; /* Access permissions of this VMA. */ unsigned long vm_flags; /* Flags, listed below. */ struct rb_node vm_rb; /* * For areas with an address space and backing store, * one of the address_space->i_mmap{,shared} lists, * for shm areas, the list of attaches, otherwise unused. */ struct list_head shared; /* Function pointers to deal with this struct. */ struct vm_operations_struct * vm_ops; /* Information about our backing store: */ unsigned long vm_pgoff; /* Offset (within vm_file) in PAGE_SIZE units, *not* PAGE_CACHE_SIZE */ struct file * vm_file; /* File we map to (can be NULL). */ void * vm_private_data; /* was vm_pte (shared mem) */ }; struct address_space 看 linux 内核很容易被 struct address_space 这个结构迷惑，它是代表某个地址空间吗？实际上不是的，它是用于管理文件 struct inode 映射到内存的页面 struct page 的，其实就是每个 file 都有这么一个结构，将文件系统中这个 file 对应的数据与这个 file 对应的内存绑定到一起 与之对应，address_space_operations 就是用来操作该文件映射到内存的页面，比如把内存中的修改写回文件、从文件中读入数据到页面缓冲等 一个具体的文件在打开后，内核会在内存中为之建立一个 struct inode 结构（该 inode 结构也会在对应的 file 结构体中引用），其中的 i_mapping 域指向一个 address_space 结构 一个文件就对应一个 address_space 结构，一个 address_space 与一个偏移量能够确定一个 page cache 或 swap cache 中的一个页面，当要寻址某个数据时，很容易根据给定的文件及数据在文件内的偏移量而找到相应的页面 struct file 和 struct inode 结构体中都有一个 struct address_space 指针，实际上，file -> f_mapping 是从对应 inode -> i_mapping 而来, inode -> i_mapping -> a_ops 是由对应的文件系统类型在生成这个 inode 时赋予的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # https://elixir.bootlin.com/linux/v2.6.0/source/include/linux/fs.h#L319 struct address_space { struct inode *host; /* owner: inode, block_device */ struct radix_tree_root page_tree; /* radix tree of all pages */ spinlock_t page_lock; /* and spinlock protecting it */ struct list_head clean_pages; /* list of clean pages */ struct list_head dirty_pages; /* list of dirty pages */ struct list_head locked_pages; /* list of locked pages */ struct list_head io_pages; /* being prepared for I/O */ unsigned long nrpages; /* number of total pages */ struct address_space_operations *a_ops; /* methods */ struct list_head i_mmap; /* list of private mappings */ struct list_head i_mmap_shared; /* list of shared mappings */ struct semaphore i_shared_sem; /* protect both above lists */ atomic_t truncate_count; /* Cover race condition with truncate */ unsigned long dirtied_when; /* jiffies of first page dirtying */ unsigned long flags; /* error bits/gfp mask */ struct backing_dev_info *backing_dev_info; /* device readahead, etc */ spinlock_t private_lock; /* for use by the address_space */ struct list_head private_list; /* ditto */ struct address_space *assoc_mapping; /* ditto */ }; 文件系统、文件类型、page 的划分 为了方便理解，在此将文件系统划分为内存文件系统（虚拟文件系统）与硬盘文件系统（物理文件系统），在书的这一章节里面，也将广义上的文件分为 virtual file 和 physics file 在书的这一章节里面，将内存页面 page 划分为 anonymous pages （没有物理文件支持的内存页面）与 pages backed by a file（由物理文件映射到内存的某些 pages） page cache 与 swap cache page cache 是与文件映射对应的，而 swap cache 是与匿名页对应的 如果一个内存页面不是文件映射，则在换入换出的时候加入到 swap cache ，如果是文件映射，则不需要交换缓冲 这两个的相同点就是它们都是 address_space ，都有相对应的文件操作：一个被访问的文件的物理页面都驻留在 page cache 或 swap cache 中，一个页面的所有信息由 struct page 来描述 一般情况下用户进程调用 mmap() 时，只是在进程空间内新增了一块相应大小的缓冲区，并设置了相应的访问标识，但并没有建立进程空间到物理页面的映射 因此，第一次访问该空间时，会引发一个缺页异常。对于共享内存映射情况，缺页异常处理程序首先在 swap cache 中寻找目标页（符合 address_space 以及偏移量的物理页），如果找到，则直接返回地址；如果没有找到，则判断该页是否在交换区 (swap area)，如果在，则执行一个换入操作；如果上述两种情况都不满足，处理程序将分配新的物理页面，并把它插入到 page cache 中，程最终将更新进程页表 对于映射普通文件情况（非共享映射），缺页异常处理程序首先会在 page cache 中根据 address_space 以及数据偏移量寻找相应的页面，如果没有找到，则说明文件数据还没有读入内存，处理程序会从磁盘读入相应的页面，并返回相应地址，同时，进程页表也会更新 硬盘文件系统 tmpfs 和 shm 共性与区别 tmpfs 和 shm 都是基于内存的文件系统，它们将文件存储在内存中，而不是磁盘上，尽管它们有一些相似之处，但它们的用途、配置方法以及操作上也有一些关键的区别
...</p></div><footer class=entry-footer><span title='2024-11-30 19:35:39 +0000 UTC'>十一月 30, 2024</span>&nbsp;·&nbsp;5 分钟&nbsp;·&nbsp;927 字&nbsp;·&nbsp;HCY</footer><a class=entry-link aria-label="post link to Linux 虚拟文件系统（虚拟内存文件系统）以及共享内存原理" href=https://hcy-asleep.github.io/Linux-%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%BB%A5%E5%8F%8A%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Linux磁盘占用分析</h2></header><div class=entry-content><p>前几天服务器又宕机了，仔细排查原来是磁盘的占用满了，在这里记录一下使用到的命令以及相关小知识 在 linux shell 里面查看磁盘占用信息主要有两个命令，一个是 du ，另外一个是 df
du 和 df 的区别 du : disk usage
主要用于递归计算指定文件夹的大小 它通过搜索文件来计算每个文件的大小然后累加，只能看到当前存在的，没有被删除的文件 使用 du - sh 可以显示当前目录的总磁盘使用量，并且以易读的格式（如 K、M、G）显示 -s 或 --summarize：只显示总计的磁盘使用量，而不是列出每个子目录的详细使用量，也就是说，它会显示当前目录（或指定目录）的总大小，而不是列出每个子目录的大小 -h 或 --human-readable：以更易读的格式显示磁盘使用量，例如以 K（千字节）、M（兆字节）、G（吉字节）等单位显示，而不是以字节为单位 1 2 hcy@debian:~$ du -sh 6.6G . 而 du -h 可以查看当前目录下所有文件和子目录的大小,这个会递归列出所有子目录占用信息，内容会非常多 有些情况下为了可以自顶向下逐层文件夹地分析哪些目录是导致磁盘臃肿的原因，可以使用 --max-depth 参数，下面是只递归展示一层（第一层）的占用情况（ –max-depth 1 ） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 root@xtz:~/build# du -h --max-depth 1 2.7M ./unittests 244K ./cmake 32K ./docs 124K ./share 13G ./bin 32K ./libexec 11M ./test 3.6G ./tools 4.1M ./include 1.5M ./examples 32K ./runtimes 13G ./lib 99M ./utils 150M ./projects 8.9M ./CMakeFiles 30G . 但是使用 du -h --max-depth 1 的结果并不是按照磁盘占用情况从小到大的顺序排序的，还是不够直观地分析占用情况，于是通过使用 sort -rh 进行进一步排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 root@xtz:~/build# du -h --max-depth 1 | sort -rh 30G . 13G ./lib 13G ./bin 3.6G ./tools 150M ./projects 99M ./utils 11M ./test 8.9M ./CMakeFiles 4.1M ./include 2.7M ./unittests 1.5M ./examples 244K ./cmake 124K ./share 32K ./runtimes 32K ./libexec 32K ./docs 其中 sort 目录的选项 -r 表示逆序，不加 -r 就是顺序；由于前面的 du 使用了 -h 选项，所以 sort 也要启用 -h 选项才可以和 du 结果匹配起来进行排序 df : disk free
...</p></div><footer class=entry-footer><span title='2024-11-25 19:27:02 +0000 UTC'>十一月 25, 2024</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;394 字&nbsp;·&nbsp;HCY</footer><a class=entry-link aria-label="post link to Linux磁盘占用分析" href=https://hcy-asleep.github.io/Linux%E7%A3%81%E7%9B%98%E5%8D%A0%E7%94%A8%E5%88%86%E6%9E%90/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SPEC CPU2006安装使用避坑</h2></header><div class=entry-content><p>安装 网上找到的版本应该是这个speccpu2006-v1.0.1-newest.tar，在想要安装的目录下执行tar -xvf speccpu2006-v1.0.1-newest.tar就可以解压安装 进入到目录里面cd speccpu2006-v1.0.1 安装 spec ，./install.sh，如果安装出现错误，极有可能是有一些文件没有可执行文件，递归赋予可执行文件就行chmod -R a+x .，不会有问题的 安装完成之后执行./shrc激活spec环境（以后每次重新打开一个 shell 会话的时候都需要激活一下） 构成 SPEC有两个部分组成，一个是数据，一个是代码（代码以项目的方式组织），运行需要指定数据以及项目 数据有三个规格 test（小型） train（中型） ref（大型） 代码有以下选项 int（整型运算性能） float，也叫 fp（浮点运算性能） all_c（全部 c 项目） all_cpp（全部 cpp 项目） all（全部项目） 特定项目，比如 453.povray 编译标准 C 语言要使用 -std=gnu89 CPP 要使用 -std=c++98 如果要启用 address sanitizer，要注意防止 sanitizer 检测到错误的时候 abort 程序而导致 benchmark 提前终止，需要使用以下编译选项 1 -fsanitize=address -fsanitize-recover=address 并且要注入环境变量ASAN_OPTIONS=halt_on_error=0:detect_leaks=0 配制 运行 spec 需要指定配制，在配制文件里面要声明 reportable = 1 才可以有结果输出
运行模式 spec 有两种运行模式，一个是 base ，基本模式，一般使用这个，一个是 peak ，性能模式，测试峰值性能极限
...</p></div><footer class=entry-footer><span title='2024-11-17 21:34:26 +0000 UTC'>十一月 17, 2024</span>&nbsp;·&nbsp;9 分钟&nbsp;·&nbsp;1762 字&nbsp;·&nbsp;HCY</footer><a class=entry-link aria-label="post link to SPEC CPU2006安装使用避坑" href=https://hcy-asleep.github.io/SPEC-CPU2006%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E9%81%BF%E5%9D%91/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Online LaTex2HTML Converter By Mathjax</h2></header><div class=entry-content><p>Enter LaTeX Formula 👇 Generated HTML Code 👇 🖱️👉 copy code 👈🖱️</p></div><footer class=entry-footer><span title='2024-11-08 14:44:13 +0000 UTC'>十一月 8, 2024</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;12 字&nbsp;·&nbsp;HCY</footer><a class=entry-link aria-label="post link to Online LaTex2HTML Converter By Mathjax" href=https://hcy-asleep.github.io/Online-LaTex2HTML-Converter-By-Mathjax/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>性能分析备忘录</h2></header><div class=entry-content><p>Perf Debian 安装 perf 1 sudo apt install linux-perf 收集分支预测事件 1 perf stat -e branch-instructions,branch-misses &lt;your_program> branch-instructions：分支指令的总数 branch-misses：分支预测失败的次数 1 hit_rate = 1 - branch-misses / branch-instructions //命中率 以下是一个包含多个复杂分支跳转的 C 语言程序示例。这个程序包含了多层嵌套的条件判断、循环和函数调用，以演示复杂的分支逻辑
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;time.h> // 模拟复杂条件的函数 int complex_condition(int x) { if (x % 2 == 0) { if (x % 3 == 0) { return 1; // 可被2和3整除 } else { if (x % 5 == 0) { return 2; // 可被2和5整除 } else { return 3; // 可被2整除，但不能被3或5整除 } } } else { if (x % 7 == 0) { return 4; // 可被7整除 } else { return 5; // 不能被2或7整除 } } } // 递归函数，模拟复杂的分支跳转 int recursive_function(int depth) { if (depth &lt;= 0) { return 0; } else { if (depth % 2 == 0) { return depth * recursive_function(depth - 1); } else { return depth + recursive_function(depth - 1); } } } // 主函数，包含多重循环和分支判断 int main() { srand(time(NULL)); // 用当前时间作为随机数种子 // 模拟分支跳转 for (int i = 0; i &lt; 20; i++) { int rand_num = rand() % 100 + 1; // 生成1到100之间的随机数 int result = complex_condition(rand_num); switch (result) { case 1: printf("Number %d is divisible by 2 and 3.\n", rand_num); break; case 2: printf("Number %d is divisible by 2 and 5.\n", rand_num); break; case 3: printf("Number %d is divisible by 2, but not by 3 or 5.\n", rand_num); break; case 4: printf("Number %d is divisible by 7.\n", rand_num); break; case 5: printf("Number %d is not divisible by 2 or 7.\n", rand_num); break; default: printf("Unexpected result for number %d.\n", rand_num); break; } } // 递归调用，模拟更复杂的分支 int depth = rand() % 10 + 1; printf("\nRecursive function result for depth %d: %d\n", depth, recursive_function(depth)); return 0; } 编译之后，使用 perf 进行分支预测事件统计得到结果：
...</p></div><footer class=entry-footer><span title='2024-11-06 17:31:59 +0000 UTC'>十一月 6, 2024</span>&nbsp;·&nbsp;6 分钟&nbsp;·&nbsp;1105 字&nbsp;·&nbsp;HCY</footer><a class=entry-link aria-label="post link to 性能分析备忘录" href=https://hcy-asleep.github.io/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%A4%87%E5%BF%98%E5%BD%95/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://hcy-asleep.github.io/page/2/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://hcy-asleep.github.io/>Memos</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>