[{"content":"我在 askbuntu 里面找到了答案：\nChange default user folders path\n具体做法：\n1 vi ~/.config/user-dirs.dirs 以下是我的配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # This file is written by xdg-user-dirs-update # If you want to change or add directories, just edit the line you\u0026#39;re # interested in. All local changes will be retained on the next run. # Format is XDG_xxx_DIR=\u0026#34;$HOME/yyy\u0026#34;, where yyy is a shell-escaped # homedir-relative path, or XDG_xxx_DIR=\u0026#34;/yyy\u0026#34;, where /yyy is an # absolute path. No other format is supported. # XDG_DESKTOP_DIR=\u0026#34;/home/hcy/Desktop/\u0026#34; XDG_DOWNLOAD_DIR=\u0026#34;/home/hcy/Downloads/\u0026#34; XDG_TEMPLATES_DIR=\u0026#34;/home/hcy/Templates/\u0026#34; XDG_PUBLICSHARE_DIR=\u0026#34;/home/hcy/Public/\u0026#34; XDG_DOCUMENTS_DIR=\u0026#34;/home/hcy/Documents/\u0026#34; XDG_MUSIC_DIR=\u0026#34;/home/hcy/Music/\u0026#34; XDG_PICTURES_DIR=\u0026#34;/home/hcy/Pictures/\u0026#34; XDG_VIDEOS_DIR=\u0026#34;/home/hcy/Videos/\u0026#34; ","permalink":"https://hcy-asleep.github.io/Debian-Gnome-%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E7%9B%AE%E5%BD%95/","summary":"我在 askbuntu 里面找到了答案：\nChange default user folders path\n具体做法：\n1 vi ~/.config/user-dirs.dirs 以下是我的配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # This file is written by xdg-user-dirs-update # If you want to change or add directories, just edit the line you\u0026#39;re # interested in. All local changes will be retained on the next run. # Format is XDG_xxx_DIR=\u0026#34;$HOME/yyy\u0026#34;, where yyy is a shell-escaped # homedir-relative path, or XDG_xxx_DIR=\u0026#34;/yyy\u0026#34;, where /yyy is an # absolute path.","title":"Debian Gnome 修改默认目录"},{"content":"Flameshot 直接从仓库安装 flameshot\n1 sudo apt install flameshot 要在 Wayland 下面可以复制粘贴图片还需安装：\n1 sudo apt install xdg-desktop-portal xdg-desktop-portal-kde wl-clipboard 为了让 flameshot 在 wayland 和 x11 下都可以使用剪切板，可以编写一个小脚本：\n1 2 3 4 5 if [[ $XDG_SESSION_TYPE == \u0026#34;wayland\u0026#34; ]] || [[ -n $WAYLAND_DISPLAY ]]; then flameshot gui -c --raw | wl-copy else flameshot gui -c fi 将这一个脚本压缩为一行：\n1 [[ $XDG_SESSION_TYPE == \u0026#34;wayland\u0026#34; ]] || [[ -n $WAYLAND_DISPLAY ]] \u0026amp;\u0026amp; flameshot gui -c --raw | wl-copy || flameshot gui -c Flameshot 的 GitHub 仓库 Issue 里面有讨论这个问题\n1 https://github.com/flameshot-org/flameshot/issues/2848 Neovim 剪切板 和上面的 Flameshot 需要 wl-clipboard 一样，在 X11 环境里面也需要：\n1 sudo apt install xclip 迅雷 在优麒麟的仓库里面安装\n1 https://mirrors.aliyun.com/ubuntukylin/pool/partner/com.xunlei.download_1.0.0.1_amd64.deb 安装之后尝试启动提示错误\n1 error while loading shared libraries: libdbus-glib-1.so.2 从软件仓库直接安装缺失\n1 sudo apt-get install libdbus-glib-1-2 ","permalink":"https://hcy-asleep.github.io/Debian-%E5%AE%89%E8%A3%85-Flameshot-%E5%92%8C%E8%BF%85%E9%9B%B7%E4%BB%A5%E5%8F%8A-Neovim-%E5%89%AA%E5%88%87%E6%9D%BF/","summary":"Flameshot 直接从仓库安装 flameshot\n1 sudo apt install flameshot 要在 Wayland 下面可以复制粘贴图片还需安装：\n1 sudo apt install xdg-desktop-portal xdg-desktop-portal-kde wl-clipboard 为了让 flameshot 在 wayland 和 x11 下都可以使用剪切板，可以编写一个小脚本：\n1 2 3 4 5 if [[ $XDG_SESSION_TYPE == \u0026#34;wayland\u0026#34; ]] || [[ -n $WAYLAND_DISPLAY ]]; then flameshot gui -c --raw | wl-copy else flameshot gui -c fi 将这一个脚本压缩为一行：\n1 [[ $XDG_SESSION_TYPE == \u0026#34;wayland\u0026#34; ]] || [[ -n $WAYLAND_DISPLAY ]] \u0026amp;\u0026amp; flameshot gui -c --raw | wl-copy || flameshot gui -c Flameshot 的 GitHub 仓库 Issue 里面有讨论这个问题","title":"Debian 安装 Flameshot 和迅雷以及 Neovim 剪切板"},{"content":"优麒麟（ukylin）原生微信 在用 Deepin 的星火商店微信之前，我一直是用优麒麟的微信，但是这个优麒麟的微信已经好久没有维护了，以下是这个版本微信的链接，是阿里云镜像上面的，进入网页之后，页内搜索关键字 weixin 即可：\n1 https://mirrors.aliyun.com/ubuntukylin/pool/partner/ Deepin 星火商店微信 尝试安装，出现依赖问题 直到有一天我刷到知乎里面有一篇文章说 Linux 微信支持语音通话，是星火商店的，于是我去看了以下，官网写的是支持的，星火商店链接：\n1 https://www.spark-app.store/store/sort/chat 上面有好多个微信，当时第三个才是我们需要的无 WINE 的原生微信，名字叫 ”微信Linux“，链接如下\n1 https://mirrors.sdu.edu.cn/spark-store-repository/store//chat/store.spark-app.wechat-linux-spark/store.spark-app.wechat-linux-spark_2.1.9_amd64.deb 下载下来之后使用命令安装：\n1 sudo apt install ./store.spark-app.wechat-linux-spark_2.1.9_amd64.deb 意料之中出现报错：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 hcy@debian:~/Downloads$ sudo apt install ./store.spark-app.wechat-linux-spark_2.1.9_amd64.deb 正在读取软件包列表... 完成 正在分析软件包的依赖关系树... 完成 正在读取状态信息... 完成 注意，选中 \u0026#39;store.spark-app.wechat-linux-spark\u0026#39; 而非 \u0026#39;./store.spark-app.wechat-linux-spark_2.1.9_amd64.deb\u0026#39; 有一些软件包无法被安装。如果您用的是 unstable 发行版，这也许是 因为系统无法达到您要求的状态造成的。该版本中可能会有一些您需要的软件 包尚未被创建或是它们已被从新到(Incoming)目录移出。 下列信息可能会对解决问题有所帮助： 下列软件包有未满足的依赖关系： store.spark-app.wechat-linux-spark : 依赖: libssl1.1 但无法安装它 推荐: deepin-elf-verify (\u0026gt;= 0.0.16.7-1) 但无法安装它 推荐: libgconf-2-4 但是它将不会被安装 或 libgconf2-4 但无法安装它 E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。 好，虽然报错但是知道是哪里出现错误，现在只要找到缺失的包就行，到了这一步我担心的是如果版本冲突又要封装进 docker 里面了\n安装 libssl1.1 首先在一个 Github Issue 里面找到了如何安装 libssl1.1 的方法：\n1 https://github.com/zerotier/ZeroTierOne/issues/1802#issuecomment-1416801584 在这个 Issue 里面他建议去 Ubuntu 的这个仓库看看：\n1 http://security.ubuntu.com/ubuntu/pool/main/o/openssl/ 页内搜索以下，找到多个在不同桌面环境下的这个包，最后我选择的是这个包：\n1 http://security.ubuntu.com/ubuntu/pool/main/o/openssl/libssl1.1_1.1.1-1ubuntu2.1~18.04.23_amd64.deb 安装 libssl1.1 顺利，很好：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 hcy@debian:~/Downloads$ sudo apt install ./libssl1.1_1.1.1-1ubuntu2.1~18.04.23_amd64.deb 正在读取软件包列表... 完成 正在分析软件包的依赖关系树... 完成 正在读取状态信息... 完成 注意，选中 \u0026#39;libssl1.1\u0026#39; 而非 \u0026#39;./libssl1.1_1.1.1-1ubuntu2.1~18.04.23_amd64.deb\u0026#39; 下列【新】软件包将被安装： libssl1.1 升级了 0 个软件包，新安装了 1 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。 需要下载 0 B/1,303 kB 的归档。 解压缩后会消耗 4,030 kB 的额外空间。 获取:1 /home/hcy/Downloads/libssl1.1_1.1.1-1ubuntu2.1~18.04.23_amd64.deb libssl1.1 amd64 1.1.1-1ubuntu2.1~18.04.23 [1,303 kB] 正在预设定软件包 ... 正在选中未选择的软件包 libssl1.1:amd64。 (正在读取数据库 ... 系统当前共安装有 146588 个文件和目录。) 准备解压 .../libssl1.1_1.1.1-1ubuntu2.1~18.04.23_amd64.deb ... 正在解压 libssl1.1:amd64 (1.1.1-1ubuntu2.1~18.04.23) ... 正在设置 libssl1.1:amd64 (1.1.1-1ubuntu2.1~18.04.23) ... 正在处理用于 libc-bin (2.36-9+deb12u3) 的触发器 ... 安装 deepin-elf-verify 接下来是看看 deepin-elf-verify 这个包了，要安装这个包心情更加忐忑，因为网上好多人说这个是锁发行版的，我在星火商店的这个讨论里面找到了答案：\n1 https://bbs.spark-app.store/d/1120-deepin-elf-verify/2 里面有一个用户说，可以去 deepin 的仓库找到这个包：\n1 https://community-packages.deepin.com/deepin/pool/main/d/deepin-elf-verify/ 好，现在找到了，我用的是这个链接下载的：\n1 https://community-packages.deepin.com/deepin/pool/main/d/deepin-elf-verify/deepin-elf-verify_1.2.0.6-1_amd64.deb 成功安装：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 hcy@debian:~/Downloads$ sudo apt install ./deepin-elf-verify_1.2.0.6-1_amd64.deb 正在读取软件包列表... 完成 正在分析软件包的依赖关系树... 完成 正在读取状态信息... 完成 注意，选中 \u0026#39;deepin-elf-verify\u0026#39; 而非 \u0026#39;./deepin-elf-verify_1.2.0.6-1_amd64.deb\u0026#39; 下列【新】软件包将被安装： deepin-elf-verify 升级了 0 个软件包，新安装了 1 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。 需要下载 0 B/1,408 B 的归档。 解压缩后会消耗 158 kB 的额外空间。 获取:1 /home/hcy/Downloads/deepin-elf-verify_1.2.0.6-1_amd64.deb deepin-elf-verify amd64 1.2.0.6-1 [1,408 B] 正在选中未选择的软件包 deepin-elf-verify。 (正在读取数据库 ... 系统当前共安装有 146598 个文件和目录。) 准备解压 .../deepin-elf-verify_1.2.0.6-1_amd64.deb ... 正在解压 deepin-elf-verify (1.2.0.6-1) ... 正在设置 deepin-elf-verify (1.2.0.6-1) ... 最后成功安装星火商店微信 再次安装微信安装包，成功安装\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 hcy@debian:~/Downloads$ sudo apt install ./store.spark-app.wechat-linux-spark_2.1.9_amd64.deb 正在读取软件包列表... 完成 正在分析软件包的依赖关系树... 完成 正在读取状态信息... 完成 注意，选中 \u0026#39;store.spark-app.wechat-linux-spark\u0026#39; 而非 \u0026#39;./store.spark-app.wechat-linux-spark_2.1.9_amd64.deb\u0026#39; 将会同时安装下列软件： gconf-service gconf2-common libgconf-2-4 建议安装： spark-dstore-patch | deepin-app-store 下列【新】软件包将被安装： gconf-service gconf2-common libgconf-2-4 store.spark-app.wechat-linux-spark 升级了 0 个软件包，新安装了 4 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。 需要下载 1,839 kB/93.9 MB 的归档。 解压缩后会消耗 356 MB 的额外空间。 您希望继续执行吗？ [Y/n] 获取:1 https://mirrors.tuna.tsinghua.edu.cn/debian bookworm/main amd64 gconf2-common all 3.2.6-8 [1,025 kB] 获取:2 /home/hcy/Downloads/store.spark-app.wechat-linux-spark_2.1.9_amd64.deb store.spark-app.wechat-linux-spark amd64 2.1.9 [92.0 MB] 获取:3 https://mirrors.tuna.tsinghua.edu.cn/debian bookworm/main amd64 libgconf-2-4 amd64 3.2.6-8 [413 kB] 获取:4 https://mirrors.tuna.tsinghua.edu.cn/debian bookworm/main amd64 gconf-service amd64 3.2.6-8 [401 kB] 已下载 1,839 kB，耗时 1秒 (1,741 kB/s) 正在选中未选择的软件包 gconf2-common。 (正在读取数据库 ... 系统当前共安装有 146393 个文件和目录。) 准备解压 .../gconf2-common_3.2.6-8_all.deb ... 正在解压 gconf2-common (3.2.6-8) ... 正在选中未选择的软件包 libgconf-2-4:amd64。 准备解压 .../libgconf-2-4_3.2.6-8_amd64.deb ... 正在解压 libgconf-2-4:amd64 (3.2.6-8) ... 正在选中未选择的软件包 gconf-service。 准备解压 .../gconf-service_3.2.6-8_amd64.deb ... 正在解压 gconf-service (3.2.6-8) ... 正在选中未选择的软件包 store.spark-app.wechat-linux-spark。 准备解压 .../store.spark-app.wechat-linux-spark_2.1.9_amd64.deb ... 正在解压 store.spark-app.wechat-linux-spark (2.1.9) ... 正在设置 gconf2-common (3.2.6-8) ... Creating config file /etc/gconf/2/path with new version 正在设置 store.spark-app.wechat-linux-spark (2.1.9) ... DISTRIB_ID=uos DISTRIB_RELEASE=20 DISTRIB_DESCRIPTION=UnionTech OS 20 DISTRIB_CODENAME=eagle 正在处理用于 sgml-base (1.31) 的触发器 ... 正在设置 libgconf-2-4:amd64 (3.2.6-8) ... 正在处理用于 libc-bin (2.36-9+deb12u3) 的触发器 ... 正在设置 gconf-service (3.2.6-8) ... 小问题 最后的最后还有一个小问题，就是，这个微信在哪里启动呢？我在星火商店的讨论里面再次找到了答案：\n1 https://bbs.spark-app.store/d/755-linux/4 这里面说，微信的启动路径在这里：\n1 ls /opt/apps/store.spark-app.wechat-linux-spark/files/launch.sh 至于制作桌面图标（desktop）文件请自行搜索，网上好多教程\n效果 在 Debian 12 的 KDE Wayland 环境下可以截图，聊天记录搜索，甚至可以语音通话！截止至 2024 年 1 月 7 日，不锁发行版，感谢 Deepin 社区\n","permalink":"https://hcy-asleep.github.io/Debian-%E5%AE%89%E8%A3%85-DeepinUOS-%E7%9A%84%E5%8E%9F%E7%94%9F%E5%BE%AE%E4%BF%A1%E9%9D%9E-WINE/","summary":"优麒麟（ukylin）原生微信 在用 Deepin 的星火商店微信之前，我一直是用优麒麟的微信，但是这个优麒麟的微信已经好久没有维护了，以下是这个版本微信的链接，是阿里云镜像上面的，进入网页之后，页内搜索关键字 weixin 即可：\n1 https://mirrors.aliyun.com/ubuntukylin/pool/partner/ Deepin 星火商店微信 尝试安装，出现依赖问题 直到有一天我刷到知乎里面有一篇文章说 Linux 微信支持语音通话，是星火商店的，于是我去看了以下，官网写的是支持的，星火商店链接：\n1 https://www.spark-app.store/store/sort/chat 上面有好多个微信，当时第三个才是我们需要的无 WINE 的原生微信，名字叫 ”微信Linux“，链接如下\n1 https://mirrors.sdu.edu.cn/spark-store-repository/store//chat/store.spark-app.wechat-linux-spark/store.spark-app.wechat-linux-spark_2.1.9_amd64.deb 下载下来之后使用命令安装：\n1 sudo apt install ./store.spark-app.wechat-linux-spark_2.1.9_amd64.deb 意料之中出现报错：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 hcy@debian:~/Downloads$ sudo apt install ./store.spark-app.wechat-linux-spark_2.1.9_amd64.deb 正在读取软件包列表... 完成 正在分析软件包的依赖关系树... 完成 正在读取状态信息... 完成 注意，选中 \u0026#39;store.spark-app.wechat-linux-spark\u0026#39; 而非 \u0026#39;./store.spark-app.wechat-linux-spark_2.1.9_amd64.deb\u0026#39; 有一些软件包无法被安装。如果您用的是 unstable 发行版，这也许是 因为系统无法达到您要求的状态造成的。该版本中可能会有一些您需要的软件 包尚未被创建或是它们已被从新到(Incoming)目录移出。 下列信息可能会对解决问题有所帮助： 下列软件包有未满足的依赖关系： store.spark-app.wechat-linux-spark : 依赖: libssl1.1 但无法安装它 推荐: deepin-elf-verify (\u0026gt;= 0.","title":"Debian 安装 Deepin(UOS) 的原生微信(非 WINE)"},{"content":"Github 八股文博客 fupenfei\n为什么C++20是最awesome的网络编程语言\nC++ STL std::vector 底层实现机制\nsocket的任意event都会导致epoll_wait的惊群效应吗？(1)\nsocket的任意event都会导致epoll_wait的惊群效应吗？(2)\n高性能网络模式：Reactor 和 Proactor\n两种 IO 设计模式 Reactor 和 Proactor\nProactor 与 Reactor\n五种网络 IO 模型\n100%弄明白5种IO模型\nIO多路复用——深入浅出理解select、poll、epoll的实现\nC 语言 Socket 理解\n30天自制C++服务器\n深入学习MySQL事务：ACID特性的实现原理\n全网最全一篇数据库MVCC详解，不全你打我\n对线面试官\n","permalink":"https://hcy-asleep.github.io/%E7%9F%A5%E8%AF%86%E9%93%BE%E6%8E%A5/","summary":"Github 八股文博客 fupenfei\n为什么C++20是最awesome的网络编程语言\nC++ STL std::vector 底层实现机制\nsocket的任意event都会导致epoll_wait的惊群效应吗？(1)\nsocket的任意event都会导致epoll_wait的惊群效应吗？(2)\n高性能网络模式：Reactor 和 Proactor\n两种 IO 设计模式 Reactor 和 Proactor\nProactor 与 Reactor\n五种网络 IO 模型\n100%弄明白5种IO模型\nIO多路复用——深入浅出理解select、poll、epoll的实现\nC 语言 Socket 理解\n30天自制C++服务器\n深入学习MySQL事务：ACID特性的实现原理\n全网最全一篇数据库MVCC详解，不全你打我\n对线面试官","title":"知识链接"},{"content":"删除软件安装包 apt-get下载的安装包会保存在/var/cache/apt/archives目录下，在软件安装完成后，这些安装包不会被删除\n查看archives文件夹大小\n1 du -sh /var/cache/apt/archives 删除已卸载软件的安装包\n1 sudo apt-get autoclean 删除所有的软件安装包\n1 sudo apt-get clean 删除孤立的软件（空间足够不建议操作）\n1 sudo apt-get autoremove 清理老旧内核 查看系统已安装过的内核（deinstall状态可以卸载，其他的建议保留）\n1 sudo dpkg --get-selections | grep linux 卸载内核\n1 sudo apt-get purge [要卸载的内核] 删除残余的配置文件 查看当前残余的配置文件\n1 sudo dpkg --list | grep \u0026#34;^rc\u0026#34; 删除残余的配置文件\n1 sudo dpkg --list | grep \u0026#34;^rc\u0026#34; | cut -d \u0026#34; \u0026#34; -f 3 | xargs sudo dpkg --purge ","permalink":"https://hcy-asleep.github.io/Debian-%E7%B3%BB%E7%BB%9F%E6%B8%85%E7%90%86/","summary":"删除软件安装包 apt-get下载的安装包会保存在/var/cache/apt/archives目录下，在软件安装完成后，这些安装包不会被删除\n查看archives文件夹大小\n1 du -sh /var/cache/apt/archives 删除已卸载软件的安装包\n1 sudo apt-get autoclean 删除所有的软件安装包\n1 sudo apt-get clean 删除孤立的软件（空间足够不建议操作）\n1 sudo apt-get autoremove 清理老旧内核 查看系统已安装过的内核（deinstall状态可以卸载，其他的建议保留）\n1 sudo dpkg --get-selections | grep linux 卸载内核\n1 sudo apt-get purge [要卸载的内核] 删除残余的配置文件 查看当前残余的配置文件\n1 sudo dpkg --list | grep \u0026#34;^rc\u0026#34; 删除残余的配置文件\n1 sudo dpkg --list | grep \u0026#34;^rc\u0026#34; | cut -d \u0026#34; \u0026#34; -f 3 | xargs sudo dpkg --purge ","title":"Debian 系统清理"},{"content":"系统级图标位置 系统级图标通常位于以下目录：\n系统默认图标目录 1 /usr/share/icons 程序安装时通常会在该目录下添加程序图标 1 /usr/share/pixmaps 应用程序的启动器文件通常位于该目录下 1 /usr/share/applications 用户级图标位置 用户级图标通常位于以下目录：\n用户自己添加的图标或自己下载的图标可以放在这个目录下 1 ~/.local/share/icons 桌面上的图标通常位于这个目录下 1 ~/Desktop 用户自己修改的应用程序菜单通常位于这个目录下 1 ~/.config/menus desktop 文件模板（以 onlyoffice 为例） 1 2 3 4 5 6 7 8 9 [Desktop Entry] Name=Onlyoffice Exec=/opt/only-office/DesktopEditors-x86_64.AppImage Terminal=false Type=Application Icon=/usr/share/icons/hicolor/only-office/onlyoffice.png StartupWMClass=\u0026#34;ONLYOFFICE Desktop Editors\u0026#34; Comment=Office Categories=Office; ","permalink":"https://hcy-asleep.github.io/Linux-%E5%9B%BE%E6%A0%87%E4%BD%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%A8%A1%E6%9D%BF/","summary":"系统级图标位置 系统级图标通常位于以下目录：\n系统默认图标目录 1 /usr/share/icons 程序安装时通常会在该目录下添加程序图标 1 /usr/share/pixmaps 应用程序的启动器文件通常位于该目录下 1 /usr/share/applications 用户级图标位置 用户级图标通常位于以下目录：\n用户自己添加的图标或自己下载的图标可以放在这个目录下 1 ~/.local/share/icons 桌面上的图标通常位于这个目录下 1 ~/Desktop 用户自己修改的应用程序菜单通常位于这个目录下 1 ~/.config/menus desktop 文件模板（以 onlyoffice 为例） 1 2 3 4 5 6 7 8 9 [Desktop Entry] Name=Onlyoffice Exec=/opt/only-office/DesktopEditors-x86_64.AppImage Terminal=false Type=Application Icon=/usr/share/icons/hicolor/only-office/onlyoffice.png StartupWMClass=\u0026#34;ONLYOFFICE Desktop Editors\u0026#34; Comment=Office Categories=Office; ","title":"Linux 图标位置以及配置模板"},{"content":"Hugo 默认生成 Toc 的只是一二三级标题，如果像六级标题都可以生成 Toc ，可以这样子配置:\n1 2 3 4 5 markup: tableOfContents: startLevel: 1 endLevel: 6 ordered: false 参考文章：\n1 https://atlex00.com/hugo/toc/#configure-toc 如果想让 Hugo 拥有侧边栏 Toc ，参考我 fork 的这个仓库：\n1 https://github.com/HCY-ASLEEP/hugo-PaperMod-Mod-Sidebar-Toc 顺便说一句题外话，就是 Hugo 的各个文件夹都有着不同的用处，值得去了解一下，比如说 archetypes 文件夹用于存放 hugo new 的生成模板，而 assets 文件夹用于存放自定义的 override 的 css ，layouts 文件夹用于存放自定义的 js 或者 html\n","permalink":"https://hcy-asleep.github.io/%E5%85%B3%E4%BA%8E-Hugo-Paper-Mod-%E4%B8%BB%E9%A2%98%E7%9A%84-Toc-%E9%85%8D%E7%BD%AE/","summary":"Hugo 默认生成 Toc 的只是一二三级标题，如果像六级标题都可以生成 Toc ，可以这样子配置:\n1 2 3 4 5 markup: tableOfContents: startLevel: 1 endLevel: 6 ordered: false 参考文章：\n1 https://atlex00.com/hugo/toc/#configure-toc 如果想让 Hugo 拥有侧边栏 Toc ，参考我 fork 的这个仓库：\n1 https://github.com/HCY-ASLEEP/hugo-PaperMod-Mod-Sidebar-Toc 顺便说一句题外话，就是 Hugo 的各个文件夹都有着不同的用处，值得去了解一下，比如说 archetypes 文件夹用于存放 hugo new 的生成模板，而 assets 文件夹用于存放自定义的 override 的 css ，layouts 文件夹用于存放自定义的 js 或者 html","title":"关于 Hugo Paper Mod 主题的 Toc 配置"},{"content":"众所周知，KDE Plasma 的 Meta 键也就是 Win 键或者叫 Super 键是很难直接在图形界面的设置里面直接重新调度 Remap,当你尝试要单独去映射 Meta 键的时候总会乱码，所以需要借助命令行的作用来使得 Meta 键位失效或者 Remap\n原来的 Meta 键是唤起 KDE 的菜单，要想使得它失效，可以应用以下命令：\n1 kwriteconfig5 --file kwinrc --group ModifierOnlyShortcuts --key Meta \u0026#34;\u0026#34; 如果要将 Meta 映射为激活后台切换调度，也就是图形界面设置里面 KWin 的\u0026quot;Overview=Meta+W,Meta+W,显示/隐藏桌面总览\u0026quot;，要使用如下命令：\n首先是映射：\n1 kwriteconfig5 --file kwinrc --group ModifierOnlyShortcuts --key Meta \u0026#34;org.kde.kglobalaccel,/component/kwin,,invokeShortcut,Overview\u0026#34; 然后是重启 KWin ：\n1 qdbus org.kde.KWin /KWin reconfigure 找到解决办法的 Reddit 讨论链接：\n1 https://www.reddit.com/r/kde/comments/t416lu/rebind_meta_key_to_open_overview/ ","permalink":"https://hcy-asleep.github.io/%E8%AE%A9-KDE-%E5%8F%AF%E4%BB%A5%E5%83%8F-GNOME-%E4%B8%80%E6%A0%B7%E4%BD%BF%E7%94%A8-Meta-%E9%94%AE%E8%BF%9B%E8%A1%8C%E5%90%8E%E5%8F%B0%E7%AA%97%E5%8F%A3%E8%B0%83%E5%BA%A6/","summary":"众所周知，KDE Plasma 的 Meta 键也就是 Win 键或者叫 Super 键是很难直接在图形界面的设置里面直接重新调度 Remap,当你尝试要单独去映射 Meta 键的时候总会乱码，所以需要借助命令行的作用来使得 Meta 键位失效或者 Remap\n原来的 Meta 键是唤起 KDE 的菜单，要想使得它失效，可以应用以下命令：\n1 kwriteconfig5 --file kwinrc --group ModifierOnlyShortcuts --key Meta \u0026#34;\u0026#34; 如果要将 Meta 映射为激活后台切换调度，也就是图形界面设置里面 KWin 的\u0026quot;Overview=Meta+W,Meta+W,显示/隐藏桌面总览\u0026quot;，要使用如下命令：\n首先是映射：\n1 kwriteconfig5 --file kwinrc --group ModifierOnlyShortcuts --key Meta \u0026#34;org.kde.kglobalaccel,/component/kwin,,invokeShortcut,Overview\u0026#34; 然后是重启 KWin ：\n1 qdbus org.kde.KWin /KWin reconfigure 找到解决办法的 Reddit 讨论链接：\n1 https://www.reddit.com/r/kde/comments/t416lu/rebind_meta_key_to_open_overview/ ","title":"让 KDE 可以像 GNOME 一样使用 Meta 键进行后台窗口调度"},{"content":"进入要存放博客文件的目录之后才可以执行以下指令\n拉取安装最新Hugo 1 2 3 4 5 6 7 8 9 10 response=$(curl -s https://api.github.com/repos/gohugoio/hugo/releases/latest);\\ version=$(echo \u0026#34;$response\u0026#34; | jq -r \u0026#39;.tag_name\u0026#39;);\\ download_url=$(echo \u0026#34;$response\u0026#34; | jq -r \u0026#39;.assets[-5].browser_download_url\u0026#39;);\\ echo \u0026#34;--- Hugo version: \u0026#34;$version\u0026#34; ----\u0026#34;;\\ curl -L -o hugo.deb $download_url;\\ sudo apt install ./hugo.deb;\\ rm hugo.deb;\\ unset response;\\ unset version;\\ unset download_url 拉取博客源数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 git config --global init.defaultBranch main;\\ git config --global user.name \u0026#34;hcy-asleep\u0026#34;;\\ git config --global user.email 2420066864@qq.com;\\ git config --global credential.helper store;\\ git clone https://github.com/HCY-ASLEEP/Hugo_Blog_Source.git;\\ mv Hugo_Blog_Source/ blogs/;\\ mkdir blogs/source/themes/;\\ git clone https://github.com/adityatelange/hugo-PaperMod.git blogs/source/themes/PaperMod/;\\ mkdir blogs/source/public/;\\ cp blogs/source/autogit blogs/source/public/autogit; sed -i \u0026#39;1 a script_dir=$(pwd)\\ncd ..\\nhugo\\ncd $script_dir\u0026#39; blogs/source/public/autogit;\\ echo \u0026#34;autogit\u0026#34; \u0026gt;\u0026gt; blogs/source/public/.gitignore;\\ cd blogs/source/public/;\\ git init;\\ git remote add origin https://github.com/HCY-ASLEEP/HCY-ASLEEP.github.io.git;\\ cp ../google188014ab03dc55b7.html . ;\\ cd .. ","permalink":"https://hcy-asleep.github.io/%E5%BF%AB%E9%80%9F%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2-Hugo-%E7%8E%AF%E5%A2%83/","summary":"进入要存放博客文件的目录之后才可以执行以下指令\n拉取安装最新Hugo 1 2 3 4 5 6 7 8 9 10 response=$(curl -s https://api.github.com/repos/gohugoio/hugo/releases/latest);\\ version=$(echo \u0026#34;$response\u0026#34; | jq -r \u0026#39;.tag_name\u0026#39;);\\ download_url=$(echo \u0026#34;$response\u0026#34; | jq -r \u0026#39;.assets[-5].browser_download_url\u0026#39;);\\ echo \u0026#34;--- Hugo version: \u0026#34;$version\u0026#34; ----\u0026#34;;\\ curl -L -o hugo.deb $download_url;\\ sudo apt install ./hugo.deb;\\ rm hugo.deb;\\ unset response;\\ unset version;\\ unset download_url 拉取博客源数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 git config --global init.","title":"快速本地部署 Hugo 环境"},{"content":"下面指令执行之前建议先挂个代理 启动一个 Ubuntu 容器 快速创建一个 Ubuntu 容器\n1 2 xhost +;\\ podman run -it --net=host -e DISPLAY=$DISPLAY --name=devenv -v /home/hcy/Documents/ubuntu/:/home/devenv/ ubuntu /bin/bash Ubuntu 容器基本设置 基本设置和基本软件\n1 2 3 4 5 6 7 8 9 apt update;\\ apt upgrade -y;\\ apt install jq xz-utils curl sudo git apt-transport-https ca-certificates ripgrep vim-tiny -y;\\ useradd -m devenv;\\ usermod -s /bin/bash devenv;\\ sudo sh -c \u0026#39;echo \u0026#34;devenv ALL=(ALL) NOPASSWD:ALL\u0026#34; \u0026gt;\u0026gt; /etc/sudoers\u0026#39;;\\ sudo chown devenv /home/devenv/;\\ sudo chgrp devenv /home/devenv/;\\ su devenv 切换到普通用户目录 回到家目录\n1 2 3 cd ~;\\ pwd;\\ touch .bashrc 配置 .bashrc 改变 Shell 外观，别名 Neovim ，配置 Shell 代理\n1 2 3 4 5 6 7 8 9 10 cat \u0026gt;\u0026gt; .bashrc \u0026lt;\u0026lt; EOF PS1=\u0026#39;\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ \u0026#39; alias iv=\u0026#39;nvim ~/.config/nvim/init.vim\u0026#39; alias v=\u0026#39;nvim\u0026#39; alias ls=\u0026#39;ls --color\u0026#39; alias p=\u0026#39;export ALL_PROXY=socks5://127.0.0.1:7897\u0026#39; alias np=\u0026#39;unset ALL_PROXY\u0026#39; EOF 记得开代理先 打开代理 p\n1 2 3 bash;\\ source ~/.bashrc;\\ p 拉取最新的 Neovim apt 安装的版本很旧，直接 github 拉取最新\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 cd ~;\\ source .bashrc;\\ response=$(curl -s https://api.github.com/repos/neovim/neovim/releases/latest);\\ version=$(echo \u0026#34;$response\u0026#34; | jq -r \u0026#39;.tag_name\u0026#39;);\\ download_url=$(echo \u0026#34;$response\u0026#34; | jq -r \u0026#39;.assets[0].browser_download_url\u0026#39;);\\ echo \u0026#34;--- Neovim version: \u0026#34;$version\u0026#34; ----\u0026#34;;\\ curl -L -o neovim.tar.gz $download_url;\\ sudo tar -zxvf neovim.tar.gz -C /opt/;\\ unset response;\\ unset version;\\ unset download_url;\\ rm neovim.tar.gz;\\ echo \u0026#34;alias nvim=/opt/nvim-linux64/bin/nvim\u0026#34; \u0026gt;\u0026gt; ~/.bashrc;\\ source ~/.bashrc 拉取具有 LSP 的 Neovim 配置 配置有 LSP 的\n1 curl -sL https://raw.githubusercontent.com/HCY-ASLEEP/NVIM-Config/main/nvim-config.sh | sh 拉取没有 LSP 的 Neovim 配置 配置没有 LSP 的\n1 curl -sL https://raw.githubusercontent.com/HCY-ASLEEP/NVIM-Config/main/nvim-config-without-lsp/nvim-config.sh | sh 拉取最新 Node.js 软件仓库里面也是太旧了，需要拉取最新的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 cd ~;\\ latest_version=$(curl -sL https://nodejs.org/en/download/ | grep -o -E \u0026#39;v[0-9]+\\.[0-9]+\\.[0-9]+\u0026#39; | head -n 1);\\ download_url=\u0026#34;https://nodejs.org/dist/$latest_version/node-$latest_version-linux-x64.tar.xz\u0026#34;;\\ install_dir=\u0026#34;/opt/nodejs\u0026#34;;\\ sudo mkdir $install_dir;\\ sudo chown -R devenv $install_dir;\\ sudo chgrp -R devenv $install_dir;\\ curl -o nodejs.tar.xz $download_url;\\ tar -xf nodejs.tar.xz -C $install_dir;\\ echo -e \u0026#34;\\nexport PATH=\\$PATH:\u0026#34;$install_dir\u0026#34;/node-\u0026#34;$latest_version\u0026#34;-linux-x64/bin/\u0026#34; \u0026gt;\u0026gt; ~/.bashrc;\\ rm nodejs.tar.xz;\\ . ~/.bashrc export PATH=$PATH:$install_dir/node-$latest_version-linux-x64/bin/;\\ npm config set registry https://registry.npm.taobao.org;\\ npm config set registry https://registry.npm.taobao.org;\\ npm i -g yarn;\\ unset latest_version;\\ unset download_url;\\ unset install_dir;\\ bash;\\ echo \u0026#34;---- Node.js $latest_version installed ----\u0026#34; 快速安装 miniconda (国内要撤销代理) 清华源安装\n1 2 3 4 5 6 7 8 curl https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-latest-Linux-x86_64.sh -o ~/miniconda.sh;\\ sh ~/miniconda.sh -b;\\ rm ~/miniconda.sh;\\ ~/miniconda3/bin/conda init bash;\\ sed -n \u0026#39;/# \u0026gt;\u0026gt;\u0026gt; conda initialize \u0026gt;\u0026gt;\u0026gt;/,/# \u0026lt;\u0026lt;\u0026lt; conda initialize \u0026lt;\u0026lt;\u0026lt;/p\u0026#39; ~/.bashrc \u0026gt;\u0026gt; ~/.condainit;\\ sed -i \u0026#39;/# \u0026gt;\u0026gt;\u0026gt; conda initialize \u0026gt;\u0026gt;\u0026gt;/,/# \u0026lt;\u0026lt;\u0026lt; conda initialize \u0026lt;\u0026lt;\u0026lt;/d\u0026#39; ~/.bashrc;\\ echo \u0026#39;alias cab=\u0026#34;source ~/.condainit\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bashrc;\\ . ~/.bashrc 安装 vim-language-server 安装 vimscript LSP\n1 https://github.com/iamcco/vim-language-server 1 npm install -g vim-language-server 安装 pyright language server 通过 pip 安装\n1 npm install -g pyright 安装 clangd language server 直接 apt 安装，但是要想获得真正的补全还要安装 gcc 和 g++\n1 sudo apt install clangd 安装 black python 格式化工具 格式化 python\n1 pip install black 设置容器内输入法变量 这个好像对我没有用\n1 2 sudo sh -c \u0026#39;echo \u0026#34;\\nexport GTK_IM_MODULE=fcitx\\nexport QT_IM_MODULE=fcitx\\nexport XMODIFIERS=@im=fcitx\\n\u0026#34; \u0026gt;\u0026gt; /etc/bash.bashrc\u0026#39;;\\ . /etc/bash.bashrc Host 的快速指令设置（需要根据实际修改一下） 配置 .bashrc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 cat \u0026gt;\u0026gt; .bashrc \u0026lt;\u0026lt; EOF PS1=\u0026#39;\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ \u0026#39; alias p=\u0026#39;export ALL_PROXY=socks5://127.0.0.1:7890\u0026#39; alias np=\u0026#39;unset ALL_PROXY\u0026#39; alias l=\u0026#39;curl \u0026#34;http://172.30.255.42:801/eportal/portal/login?user_account=392432\u0026amp;user_password=12542614\u0026#34; ; echo\u0026#39; alias v=\u0026#39;nvim\u0026#39; alias iv=\u0026#39;nvim ~/.config/nvim/init.vim\u0026#39; alias devenv=\u0026#39;xhost + \u0026gt;\u0026gt; /dev/null;\\ podman start devenv;\\ podman exec -it \\ -e DISPLAY=$DISPLAY \\ devenv /bin/bash -c \\ \u0026#34;cd /home/devenv/; su devenv;\u0026#34;\u0026#39; alias u=\u0026#39;sudo apt update; sudo apt upgrade -y;\u0026#39; EOF ","permalink":"https://hcy-asleep.github.io/%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AEUbuntu-Docker%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","summary":"下面指令执行之前建议先挂个代理 启动一个 Ubuntu 容器 快速创建一个 Ubuntu 容器\n1 2 xhost +;\\ podman run -it --net=host -e DISPLAY=$DISPLAY --name=devenv -v /home/hcy/Documents/ubuntu/:/home/devenv/ ubuntu /bin/bash Ubuntu 容器基本设置 基本设置和基本软件\n1 2 3 4 5 6 7 8 9 apt update;\\ apt upgrade -y;\\ apt install jq xz-utils curl sudo git apt-transport-https ca-certificates ripgrep vim-tiny -y;\\ useradd -m devenv;\\ usermod -s /bin/bash devenv;\\ sudo sh -c \u0026#39;echo \u0026#34;devenv ALL=(ALL) NOPASSWD:ALL\u0026#34; \u0026gt;\u0026gt; /etc/sudoers\u0026#39;;\\ sudo chown devenv /home/devenv/;\\ sudo chgrp devenv /home/devenv/;\\ su devenv 切换到普通用户目录 回到家目录","title":"快速配置Ubuntu Docker开发环境"},{"content":"在 ~/.config/alacritty/ 目录下创建 alacritty.yml\n1 2 mkdir ~/.config/alacritty/;\\ touch ~/.config/alacritty/alacritty.yml 写入 alacritty.yml 配置\n1 2 3 4 5 font: normal: family: Jetbrains Mono style: Regular size: 12 ","permalink":"https://hcy-asleep.github.io/Alacritty-%E9%85%8D%E7%BD%AE-JetBrains-Mono-%E5%AD%97%E4%BD%93/","summary":"在 ~/.config/alacritty/ 目录下创建 alacritty.yml\n1 2 mkdir ~/.config/alacritty/;\\ touch ~/.config/alacritty/alacritty.yml 写入 alacritty.yml 配置\n1 2 3 4 5 font: normal: family: Jetbrains Mono style: Regular size: 12 ","title":"Alacritty 配置 JetBrains Mono 字体"},{"content":"前言 我使用的 xv6-riscv 是 fork MIT 官方的库，在它的基础上面进行移植，这个教学系统原本是与 6.1810 一起配套使用的，下面这个是官方仓库地址：\n👉 https://github.com/mit-pdos/xv6-riscv\n这是我所做过的移植交互程序及之前 SZU OS 课程在 xv6 上面做的一些实验：\n👉 我对 xv6-riscv 的一些改动\n2048 移植以及相关移植准备 终端交互移植最关键的就是要把缺失的库函数都补完，首先就得增加和改进 xv6-riscv 原有的终端交互相关的库\n在 xv6-riscv 的顶层目录下新建一个 include 文件夹，里面存放改进的头文件\nHead What it does assert.h 断言的相关宏定义和函数声明，用于断言检查 ctype.h 字符处理的函数和宏定义，对字符进行分类和转换 limits.h 定义了各种数据类型的取值范围以及其他与整数类型相关的常量 stdarg.h 提供了支持可变参数函数的宏和类型定义 stdbool.h 定义了布尔类型和相关的常量，没错，xv6-riscv 原本甚至不支持 bool 型变量 stddef.h 提供了一些与指针、大小和偏移量相关的常量和类型定义 stdio.h 用于处理标准输入输出 stdlib.h 用于内存管理、字符串转换、伪随机数生成、算术运算和程序终止等 termios.h 用于控制和配置终端的行为 unistd.h 定义了一些与系统调用、文件操作、进程控制、环境变量和程序终止相关的函数和常量 上面这些改进的库函数里面最关键的是 termios.h 和 stdio.h ，没错，xv6-riscv 连标准输入输出都没有，刷新终端都做不到。。。即便如此 termios.h 移植之后也是极度残缺的，因为没有 xv6-riscv 压根就没有提供 ioctl 的系统调用！也正是因为这个原因，C语言里面的标准库 curses.h (可以控制光标位置、输出文本、设置颜色、处理用户输入等,使用这些函数和宏，可以在终端中实现基本的交互式图形界面) 压根移植不了，这进一步导致 vi 移植不了\nsyscall ioctl \u0026ndash;\u0026raquo; termios.h / curses.h \u0026ndash;\u0026raquo; vi / nano \u0026ndash;\u0026raquo; fuck?\n这些改经的库函数里面有一个库非常有趣，就是 stdarg.h ，有了它之后你就可以使用省略号作为函数的参数！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; void printValues(int num, ...) { va_list args; va_start(args, num); // 初始化va_list for (int i = 0; i \u0026lt; num; i++) { int value = va_arg(args, int); // 从va_list中获取下一个参数 printf(\u0026#34;%d \u0026#34;, value); } va_end(args); // 结束va_list的访问 printf(\u0026#34;\\n\u0026#34;); } int main() { printValues(3, 10, 20, 30); // 调用打印函数并传递三个参数 return 0; } // 输出结果为：10 20 30 目前有一点不足的是这些移植的库函数所定义的宏或者函数会与 kernel 文件夹下面的冲突，也就是重定义错误，比如 stdio.h 里面的 printf 与 kernel 文件夹下的 printf 完全不一样\n接下来在 xv6 的顶层目录新建 lib 目录，里面新建一个 libc.c 文件用于实现之前 include 文件夹下定义的改进函数\n然后在 user 目录里面新建 2048.c ，里面存放 2048 这个小游戏的实现，整个游戏使用 wasd 进行方向控制，q 控制退出游戏，每次操作接收一个操作字母加回车\n最后修改 Makefile ，将改进的库以及 2048.c 纳入编译的范围\n注意的是，移植之后可能要细微修改 kernel 下面的 virtio.h 和 virtio_disk.c ，不然 xv6 可能无法正常启动，会抛出一个 panic 信息\n具体的 2048 实现以及相关改动都在这一个 👉 commit 里面\n移植扫雷(minesweeper) 有了 2048 移植之后的功能库，扫雷的移植就非常简单了，修改 Makefile 和添加 minesweeper 的实现就行，具体参考这个 👉 commit\n\u0026ldquo;移植\u0026quot;小火车 sl 最后是一个非常简陋的小火车 sl ，这不能说是移植，应该说是我模仿 sl 👉 官方仓库 结合能够用的库自己实现的，没有 ioctl 系统调用是真的痛啊！本来想参考 👉 nyuichi/xv6 移植这个 ioctl 系统调用的，但是 xv6-riscv 的接口与 xv6-x86 的内核接口差别有点大，有点超出能力范围之内了。。。小火车具体实现参考这个 👉 commit\nEnd 代码已经全部上传到我的 👉 github repo 里面，欢迎 star\n","permalink":"https://hcy-asleep.github.io/%E4%B8%BA-xv6-riscv-%E7%A7%BB%E6%A4%8D%E6%89%AB%E9%9B%B7minesweeper-2048-%E4%BB%A5%E5%8F%8A%E9%9D%9E%E5%B8%B8%E7%AE%80%E5%8D%95%E7%9A%84-sl/","summary":"前言 我使用的 xv6-riscv 是 fork MIT 官方的库，在它的基础上面进行移植，这个教学系统原本是与 6.1810 一起配套使用的，下面这个是官方仓库地址：\n👉 https://github.com/mit-pdos/xv6-riscv\n这是我所做过的移植交互程序及之前 SZU OS 课程在 xv6 上面做的一些实验：\n👉 我对 xv6-riscv 的一些改动\n2048 移植以及相关移植准备 终端交互移植最关键的就是要把缺失的库函数都补完，首先就得增加和改进 xv6-riscv 原有的终端交互相关的库\n在 xv6-riscv 的顶层目录下新建一个 include 文件夹，里面存放改进的头文件\nHead What it does assert.h 断言的相关宏定义和函数声明，用于断言检查 ctype.h 字符处理的函数和宏定义，对字符进行分类和转换 limits.h 定义了各种数据类型的取值范围以及其他与整数类型相关的常量 stdarg.h 提供了支持可变参数函数的宏和类型定义 stdbool.h 定义了布尔类型和相关的常量，没错，xv6-riscv 原本甚至不支持 bool 型变量 stddef.h 提供了一些与指针、大小和偏移量相关的常量和类型定义 stdio.h 用于处理标准输入输出 stdlib.h 用于内存管理、字符串转换、伪随机数生成、算术运算和程序终止等 termios.h 用于控制和配置终端的行为 unistd.h 定义了一些与系统调用、文件操作、进程控制、环境变量和程序终止相关的函数和常量 上面这些改进的库函数里面最关键的是 termios.h 和 stdio.h ，没错，xv6-riscv 连标准输入输出都没有，刷新终端都做不到。。。即便如此 termios.h 移植之后也是极度残缺的，因为没有 xv6-riscv 压根就没有提供 ioctl 的系统调用！也正是因为这个原因，C语言里面的标准库 curses.","title":"为 xv6-riscv 移植扫雷(minesweeper) 2048 以及非常简单的 sl"},{"content":"啊，这篇文章就随意一点吧，就意识流地写吧（虽然一直都是这样子），记录一下最近搞 Neovim 的心得\n1. 如何使用 nvim + coc 如何滚动悬浮窗口内的内容呢？ 使用 nvim + coc 编写代码的时候，弹出来的悬浮窗口内有滚动条，我怎样才能滚动悬浮窗口内的内容呢？试试 ctrl-w ctrl-w 切换到 floatwin 中，再翻页；更顺手一些的操作是：如果触发 floatwin 的按键是 nmap K, 连按两次 K 就会切换到 floatwin 中\n👉 https://segmentfault.com/q/1010000040349668\n或者直接映射相关的键位，参考官方 Github 的 Readme\n👉 https://github.com/neoclide/coc.nvim/commit/\n2. Vim f和t的快捷方式 [ 移动到指定字符 ]\n如果我们想在当前行内快速移动，可以使用f, t, F, T命令\n\u0026ldquo;f\u0026quot;命令移动到光标右边的指定字符上，例如，\u0026ldquo;fx\u0026rdquo;，会把移动到光标右边的第一个\u0026rsquo;x\u0026rsquo;字符上，\u0026ldquo;F\u0026quot;命令则反方向查找，也就是移动到光标左边的指定字符上\n\u0026ldquo;t\u0026quot;命令和\u0026quot;f\u0026quot;命令的区别在于，它移动到光标右边的指定字符之前，例如，\u0026ldquo;tx\u0026quot;会移动到光标右边第一个\u0026rsquo;x\u0026rsquo;字符的前面，\u0026ldquo;T\u0026quot;命令是\u0026quot;t\u0026quot;命令的反向版本，它移动到光标左边的指定字符之后\n这四个命令只在当前行中移动光标，光标不会跨越回车换行符\n可以在命令前面使用数字，表示倍数，例如，\u0026ldquo;3fx\u0026quot;表示移动到光标右边的第3个\u0026rsquo;x\u0026rsquo;字符上\n\u0026ldquo;;\u0026ldquo;命令重复前一次输入的f, t, F, T命令，而\u0026rdquo;,\u0026ldquo;命令会反方向重复前一次输入的f, t, F, T命令，这两个命令前也可以使用数字来表示倍数\n👉 https://www.jianshu.com/p/a46a89b460a9\n3. 如何在 Vim 里面使用 ripgrep ？ 关于这个问题有两种解决思路：\n使用 Vim 里面自带的 quickfix\n将 rg 搜索结果切割填充到 quickfix 里面，这个部分由 Vim 自己完成，要想使用这个功能，只需要在你的 vimrc 或者 init.vim 里面添加这句话就行\n1 set grepprg=rg\\ --vimgrep\\ --no-heading\\ --smart-case 👉 https://github.com/BurntSushi/ripgrep/issues/425\n👉 https://www.reddit.com/r/vim/comments/\n但是这里有一个问题，就是虽然 rg 搜索速度是非常快的，但是将 rg 搜索结果重定向到 quickfix 里面是非常慢的，因为填充 quickfix 的时候，vimscript 会把每一行切割成一段一段的字符串，然后字典化（也就是给每一段加上 key），以方便文字高亮着色还有后续跳转，在 Vim 普通模式下 :h cexpr 就可以知道原理了\n👉 https://www.reddit.com/r/vim/comments/\n狂热 VIM 爱好者 -\u0026gt; 手搓一个 quickfix\n既然填充的时候切割花费了大量时间，那么我再跳转的时候再切割获得跳转位置信息不久快啦？毕竟切割一行内容多慢都不会慢到哪里去\nVim 获取外部 shell 命令输出结果的方法：\n1 2 3 4 redir =\u0026gt; t:message execute a:cmd redir END echo t:message Vim 将 t:message 的信息填充进 buffer 里面可以使用 setline() 函数\n或者可以直接获取结果然后填充一步到位：\n1 read !ls ~ 👉 https://vim.fandom.com/wiki/Capture_ex_command_output\nVim 在不切换到另外一个窗口下操控另外一个窗口，可以使用 win_execute() 函数，Neovim 也是支持的（nvim 0.7.2 测试可以），用这个函数可以实现 quickfix 里 cNext 那种效果（这里提一嘴，win_execute 里面的 winid 是要通过 win_getid 获取的）\n1 let l:findWinId=win_getid(l:findWinNum) 👉 https://vi.stackexchange.com/questions/23271/\n👉 https://vi.stackexchange.com/questions/26602/\nVim 在 ex （命令模式里面跳转到具体的某行某列）需要使用 cal 命令，如跳转到第 30 行的第 5 列：\n1 cal cursor(30, 5) 👉 https://stackoverflow.com/questions/11767956/\nVim 允许设置 buffer 的文件类型（filetype）：\n1 setlocal filetype=your_type(不用双引号) 打印 buffer 文件类型：\n1 echo \u0026amp;filetype 这个 filetype 属性结合 nnoremap \u0026lt;buffer\u0026gt; 就可以做到指定某一个 buffer setlocal cursorline (Buffer local mappings in Vim) (vim map in specific window)\n👉 https://stackoverflow.com/questions/7985813/\n我将 rg 整合进 neovim 之后的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 \u0026#34; set ripgrep root dir let g:rgRootDir=getcwd() function! CdCurBufDir() let g:rgRootDir=expand(\u0026#34;%:p:h\u0026#34;) echo expand(\u0026#34;%:p:h\u0026#34;) endfunction \u0026#34; Cc means \u0026#39;cd cur\u0026#39;, cd cur buf dir command! -nargs=1 -complete=command Cc silent call CdCurBufDir() let t:redirPreviewWinnr = 1 function! OpenRedirWindow() let l:findWinNum=bufwinnr(bufnr(\u0026#39;FuzzyFilenameSearch\u0026#39;)) let l:rgWinNum=bufwinnr(bufnr(\u0026#39;RipgrepWordSearch\u0026#39;)) if l:findWinNum != -1 exec l:findWinNum.\u0026#34;wincmd w\u0026#34; enew elseif l:rgWinNum != -1 exec l:rgWinNum.\u0026#34;wincmd w\u0026#34; enew else let t:redirPreviewWinnr = winnr() botright 10new endif endfunction function! QuitRedirWindow() let l:findWinNum=bufwinnr(bufnr(\u0026#39;FuzzyFilenameSearch\u0026#39;)) let l:rgWinNum=bufwinnr(bufnr(\u0026#39;RipgrepWordSearch\u0026#39;)) if l:findWinNum != -1 exec l:findWinNum.\u0026#34;close\u0026#34; elseif l:rgWinNum != -1 exec l:rgWinNum.\u0026#34;close\u0026#34; else echo \u0026#34;\u0026gt;\u0026gt; No OpenRedirWindow!\u0026#34; endif endfunction nnoremap \u0026lt;silent\u0026gt;\u0026lt;space\u0026gt;q :call QuitRedirWindow()\u0026lt;CR\u0026gt; \u0026#34; Fuzzy Match filenames ----------------------------------------------------------------------------- \u0026#34; Go to the file on line function! FindJump(path) exec \u0026#34;cd \u0026#34;.g:rgRootDir let l:path=a:path exec t:redirPreviewWinnr.\u0026#34;wincmd w\u0026#34; exec \u0026#34;edit \u0026#34;.l:path endfunction \u0026#34; autocmd to jump to file with CR only in FuzzyFilenameSearch buffer function! FindJumpWithCR() augroup findJumpWithCR autocmd! autocmd FileType FuzzyFilenameSearch nnoremap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt;\u0026lt;CR\u0026gt; :call FindJump(getline(\u0026#39;.\u0026#39;))\u0026lt;CR\u0026gt; augroup END endfunction \u0026#34; redirect the command output to a buffer function! FindRedir(cmd) call FindJumpWithCR() call OpenRedirWindow() edit FuzzyFilenameSearch exec \u0026#34;read \u0026#34;.a:cmd setlocal buftype=nofile bufhidden=wipe nobuflisted noswapfile cursorline filetype=FuzzyFilenameSearch endfunction command! -nargs=1 -complete=command FindRedir silent call FindRedir(\u0026lt;q-args\u0026gt;) \u0026#34; Show Files fuzzily searched with git function! FindWithGit(substr) exec \u0026#34;FindRedir !rg --files \\| rg --ignore-case \u0026#34;.a:substr exec \u0026#34;normal! gg\u0026#34; if getline(\u0026#39;.\u0026#39;) == \u0026#34;\u0026#34; exec \u0026#34;normal! dd\u0026#34; endif call feedkeys(\u0026#34;/\u0026#34;.a:substr.\u0026#34;\\\\c\\\u0026lt;CR\u0026gt;\u0026#34; ,\u0026#39;n\u0026#39;) endfunction \u0026#34; Show Files searched fuzzily without git function! FindWithoutGit(substr) exec \u0026#34;FindRedir !rg --no-ignore --files \\| rg --ignore-case \u0026#34;.a:substr exec \u0026#34;normal! gg\u0026#34; if getline(\u0026#39;.\u0026#39;) == \u0026#34;\u0026#34; exec \u0026#34;normal! dd\u0026#34; endif call feedkeys(\u0026#34;/\u0026#34;.a:substr.\u0026#34;\\\\c\\\u0026lt;CR\u0026gt;\u0026#34; ,\u0026#39;n\u0026#39;) endfunction \u0026#34; Fg means \u0026#39;file git\u0026#39;, search file names fuzzily with git command! -nargs=1 -complete=command Fg silent call FindWithGit(\u0026lt;q-args\u0026gt;) \u0026#34; Fs means \u0026#39;file search\u0026#39;, search file names fuzzily command! -nargs=1 -complete=command Fs silent call FindWithoutGit(\u0026lt;q-args\u0026gt;) \u0026#34; To show file preview, underlying of FindNext, imitate \u0026#39;cNext\u0026#39; command function! FindShow(direction) let l:findWinNum=bufwinnr(bufnr(\u0026#39;FuzzyFilenameSearch\u0026#39;)) if l:findWinNum == -1 echo \u0026#34;\u0026gt;\u0026gt; No FuzzyFilenameSearch Buffer!\u0026#34; else if l:findWinNum != t:redirPreviewWinnr let l:findWinId=win_getid(l:findWinNum) call win_execute(l:findWinId, \u0026#34;normal! \u0026#34;.a:direction) call win_execute(l:findWinId, \u0026#34;let t:findPreviewPath=getline(\u0026#39;.\u0026#39;)\u0026#34;) call FindJump(t:findPreviewPath) else call FindJump(getline(\u0026#39;.\u0026#39;)) endif endif endfunction \u0026#34; imitate \u0026#39;cNext\u0026#39; function! FindNext() call FindShow(\u0026#34;+\u0026#34;) endfunction \u0026#34; imitate \u0026#39;cprevious\u0026#39; function! FindPre() call FindShow(\u0026#34;-\u0026#34;) endfunction nnoremap \u0026lt;silent\u0026gt;\u0026lt;C-down\u0026gt; :call FindNext()\u0026lt;CR\u0026gt; nnoremap \u0026lt;silent\u0026gt;\u0026lt;C-up\u0026gt; :call FindPre()\u0026lt;CR\u0026gt; \u0026#34; Global Fuzzy Match words ------------------------------------------------------------------------- \u0026#34; Go to the file on line function! RgJump(location) exec \u0026#34;cd \u0026#34;.g:rgRootDir let l:location = split(a:location, \u0026#34;:\u0026#34;) exec t:redirPreviewWinnr.\u0026#34;wincmd w\u0026#34; exec \u0026#34;edit \u0026#34;.l:location[0] cal cursor(l:location[1], l:location[2]) endfunction \u0026#34; autocmd to jump to file with CR only in RipgrepWordSearch buffer function! RgJumpWithCR() augroup rgJumpWithCR autocmd! autocmd FileType RipgrepWordSearch nnoremap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt;\u0026lt;CR\u0026gt; :call RgJump(getline(\u0026#39;.\u0026#39;))\u0026lt;CR\u0026gt; augroup END endfunction \u0026#34; redirect the command output to a buffer function! RgRedir(cmd) call RgJumpWithCR() call OpenRedirWindow() edit RipgrepWordSearch exec \u0026#34;read \u0026#34;a:cmd setlocal buftype=nofile bufhidden=wipe nobuflisted noswapfile cursorline filetype=RipgrepWordSearch endfunction command! -nargs=1 -complete=command RgRedir silent call RgRedir(\u0026lt;q-args\u0026gt;) \u0026#34; Show Words fuzzily searched with git function! RgWithGit(substr) exec \u0026#34;RgRedir !rg \u0026#39;\u0026#34;.a:substr.\u0026#34;\u0026#39; \u0026#34;.getcwd().\u0026#34; --ignore-case --vimgrep --no-heading\u0026#34; exec \u0026#34;normal! gg\u0026#34; if getline(\u0026#39;.\u0026#39;) == \u0026#34;\u0026#34; exec \u0026#34;normal! dd\u0026#34; endif call feedkeys(\u0026#34;/\u0026#34;.a:substr.\u0026#34;\\\\c\\\u0026lt;CR\u0026gt;\u0026#34; ,\u0026#39;n\u0026#39;) endfunction \u0026#34; Show Files fuzzily searched without git function! RgWithoutGit(substr) exec \u0026#34;RgRedir !rg \u0026#39;\u0026#34;.a:substr.\u0026#34;\u0026#39; \u0026#34;.getcwd().\u0026#34; --ignore-case --vimgrep --no-heading --no-ignore\u0026#34; exec \u0026#34;normal! gg\u0026#34; if getline(\u0026#39;.\u0026#39;) == \u0026#34;\u0026#34; exec \u0026#34;normal! dd\u0026#34; endif call feedkeys(\u0026#34;/\u0026#34;.a:substr.\u0026#34;\\\\c\\\u0026lt;CR\u0026gt;\u0026#34; ,\u0026#39;n\u0026#39;) endfunction \u0026#34; Wg means \u0026#39;word git\u0026#39;, search file fuzzily names with git command! -nargs=1 -complete=command Wg silent call RgWithGit(\u0026lt;q-args\u0026gt;) \u0026#34; Ws means \u0026#39;word search\u0026#39;, search file fuzzily names without git command! -nargs=1 -complete=command Ws silent! call RgWithoutGit(\u0026lt;q-args\u0026gt;) \u0026#34; To show file preview, underlying of RgNext, imitate \u0026#39;cNext\u0026#39; command function! RgShow(direction) let l:rgWinNum=bufwinnr(bufnr(\u0026#39;RipgrepWordSearch\u0026#39;)) if l:rgWinNum == -1 echo \u0026#34;\u0026gt;\u0026gt; No RipgrepWordSearch Buffer!\u0026#34; else if l:rgWinNum != t:redirPreviewWinnr let l:rgWinId=win_getid(l:rgWinNum) call win_execute(l:rgWinId, \u0026#34;normal! \u0026#34;.a:direction) call win_execute(l:rgWinId, \u0026#34;let t:rgPreviewLocation=getline(\u0026#39;.\u0026#39;)\u0026#34;) call RgJump(t:rgPreviewLocation) else call RgJump(getline(\u0026#39;.\u0026#39;)) endif endif endfunction \u0026#34; imitate \u0026#39;cNext\u0026#39; function! RgNext() call RgShow(\u0026#34;+\u0026#34;) endfunction \u0026#34; imitate \u0026#39;cprevious\u0026#39; function! RgPre() call RgShow(\u0026#34;-\u0026#34;) endfunction nnoremap \u0026lt;silent\u0026gt;\u0026lt;S-down\u0026gt; :call RgNext()\u0026lt;CR\u0026gt; nnoremap \u0026lt;silent\u0026gt;\u0026lt;S-up\u0026gt; :call RgPre()\u0026lt;CR\u0026gt; 👉 https://github.com/HCY-ASLEEP/NVIM-Config/tree/main\n4. Ripgrep 在线使用手册 一些简单的例子说明：\n👉 https://jdhao.github.io/2020/02/16/ripgrep_cheat_sheet/\nrg 在线 man 手册，没有例子：\n👉 https://www.mankier.com/1/rg\n顺便提一下防止我以后忘记，如果想 rg 搜索结果里面包含隐藏文件（以 \u0026lsquo;.\u0026rsquo; 开头的文件），使用 \u0026ndash;hidden 参数就可以了\n5. Where is neovim\u0026rsquo;s .viminfo located? vim 的历史命令文件位于 ~/.viminfo ，而 neovim 的位于\n1 ~/local/share/nvim/shada/main.shada 👉 https://www.reddit.com/r/neovim/comments/\n6. 设置 netrw 的工作目录(root dir) How to set selected directory as current in vim (netrw)? 只需要把光标放在 netrw 里面你想设置的目录下面，然后执行 :Ntree 命令就行\n👉 https://stackoverflow.com/questions/33542513/\n","permalink":"https://hcy-asleep.github.io/Vim-ripgrep-quickfix-netrw-nmap-autocmd-wincmd-%E5%A4%A7%E6%9D%82%E7%83%A9/","summary":"啊，这篇文章就随意一点吧，就意识流地写吧（虽然一直都是这样子），记录一下最近搞 Neovim 的心得\n1. 如何使用 nvim + coc 如何滚动悬浮窗口内的内容呢？ 使用 nvim + coc 编写代码的时候，弹出来的悬浮窗口内有滚动条，我怎样才能滚动悬浮窗口内的内容呢？试试 ctrl-w ctrl-w 切换到 floatwin 中，再翻页；更顺手一些的操作是：如果触发 floatwin 的按键是 nmap K, 连按两次 K 就会切换到 floatwin 中\n👉 https://segmentfault.com/q/1010000040349668\n或者直接映射相关的键位，参考官方 Github 的 Readme\n👉 https://github.com/neoclide/coc.nvim/commit/\n2. Vim f和t的快捷方式 [ 移动到指定字符 ]\n如果我们想在当前行内快速移动，可以使用f, t, F, T命令\n\u0026ldquo;f\u0026quot;命令移动到光标右边的指定字符上，例如，\u0026ldquo;fx\u0026rdquo;，会把移动到光标右边的第一个\u0026rsquo;x\u0026rsquo;字符上，\u0026ldquo;F\u0026quot;命令则反方向查找，也就是移动到光标左边的指定字符上\n\u0026ldquo;t\u0026quot;命令和\u0026quot;f\u0026quot;命令的区别在于，它移动到光标右边的指定字符之前，例如，\u0026ldquo;tx\u0026quot;会移动到光标右边第一个\u0026rsquo;x\u0026rsquo;字符的前面，\u0026ldquo;T\u0026quot;命令是\u0026quot;t\u0026quot;命令的反向版本，它移动到光标左边的指定字符之后\n这四个命令只在当前行中移动光标，光标不会跨越回车换行符\n可以在命令前面使用数字，表示倍数，例如，\u0026ldquo;3fx\u0026quot;表示移动到光标右边的第3个\u0026rsquo;x\u0026rsquo;字符上\n\u0026ldquo;;\u0026ldquo;命令重复前一次输入的f, t, F, T命令，而\u0026rdquo;,\u0026ldquo;命令会反方向重复前一次输入的f, t, F, T命令，这两个命令前也可以使用数字来表示倍数\n👉 https://www.jianshu.com/p/a46a89b460a9\n3. 如何在 Vim 里面使用 ripgrep ？ 关于这个问题有两种解决思路：\n使用 Vim 里面自带的 quickfix","title":"Vim ripgrep quickfix netrw nmap autocmd wincmd 。。。大杂烩 ？！"},{"content":"在执行 git ls-files 的时候，只会列出被 git 跟踪了 (tracked) 的文件，而不会列出那些新建未跟踪的文件 (untracked) ，这个时候用以下命令就可以列出除了 .gitignore 以外的所有文件（包括 tracked 和 untracked 的）：\n1 git ls-files --exclude-standard --cache --others 这个命令也可以简写成：\n1 git ls-files --exclude-standard -c -o 或者：\n1 git ls-files --exclude-standard -co 各项参数的意思（参考 Git 官方文档）：\n-c \u0026ndash;cached Show all files cached in Git’s index, i.e. all tracked files. (This is the default if no -c/-s/-d/-o/-u/-k/-m/\u0026ndash;resolve-undo options are specified.)\n-o \u0026ndash;others Show other (i.e. untracked) files in the output\n\u0026ndash;exclude-standard Add the standard Git exclusions: .git/info/exclude, .gitignore in each directory, and the user’s global exclusion file.\nReferences 👇\n官方文档 git ls-files\n关于这个问题的讨论\n顺便提一句，在写 Markdown 的引用（quote）的时候，没错就是在写这篇文章的时候\n第一，我发现在引用里面是可以使用 **font** 来加粗字体的\n第二，是如果想要在引用（quote）里面换行，得显式地在行后面加上 \u0026ldquo;\u0026lt;/br\u0026gt;\u0026rdquo; 才可以\n","permalink":"https://hcy-asleep.github.io/Git-%E5%88%97%E5%87%BA%E9%99%A4%E4%BA%86-.gitignore-%E4%BB%A5%E5%A4%96%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%8C%85%E6%8B%AC-tracked-%E5%92%8C-untracked-%E7%9A%84/","summary":"在执行 git ls-files 的时候，只会列出被 git 跟踪了 (tracked) 的文件，而不会列出那些新建未跟踪的文件 (untracked) ，这个时候用以下命令就可以列出除了 .gitignore 以外的所有文件（包括 tracked 和 untracked 的）：\n1 git ls-files --exclude-standard --cache --others 这个命令也可以简写成：\n1 git ls-files --exclude-standard -c -o 或者：\n1 git ls-files --exclude-standard -co 各项参数的意思（参考 Git 官方文档）：\n-c \u0026ndash;cached Show all files cached in Git’s index, i.e. all tracked files. (This is the default if no -c/-s/-d/-o/-u/-k/-m/\u0026ndash;resolve-undo options are specified.)\n-o \u0026ndash;others Show other (i.e. untracked) files in the output","title":"Git 列出除了 .gitignore 以外的所有文件（包括 tracked 和 untracked 的）"},{"content":"文件是在 Windows 下创建的，Windows 的文件名中文编码默认为 GBK ，而 Linux 中默认文件名编码为 UTF8，由于编码不一致所以导致了文件名乱码的问题，解决这个问题需要对文件名进行转码\n安装 convmv ：\n1 sudo apt-get install convmv convmv 使用方法：\n1 convmv -f 源编码 -t 新编码 [选项] 文件名 常用参数：\n-r 递归处理子文件夹 \u0026ndash;notest 真正进行操作，默认情况下是不对文件进行真实操作 \u0026ndash;list 显示所有支持的编码 \u0026ndash;unescap 可以做一下转义，比如把%20变成空格 Eg:\n1 convmv -f GBK -t UTF-8 --notest –-unescap *.mp3 参考链接👉 https://www.shuzhiduo.com/A/RnJWmlWvdq/\n","permalink":"https://hcy-asleep.github.io/Linux-%E4%B8%8B%E6%96%87%E4%BB%B6%E5%90%8D%E5%AD%97%E4%B9%B1%E7%A0%81%E6%97%A0%E6%95%88%E7%9A%84%E7%BC%96%E7%A0%81invalid-encodingWindows/","summary":"文件是在 Windows 下创建的，Windows 的文件名中文编码默认为 GBK ，而 Linux 中默认文件名编码为 UTF8，由于编码不一致所以导致了文件名乱码的问题，解决这个问题需要对文件名进行转码\n安装 convmv ：\n1 sudo apt-get install convmv convmv 使用方法：\n1 convmv -f 源编码 -t 新编码 [选项] 文件名 常用参数：\n-r 递归处理子文件夹 \u0026ndash;notest 真正进行操作，默认情况下是不对文件进行真实操作 \u0026ndash;list 显示所有支持的编码 \u0026ndash;unescap 可以做一下转义，比如把%20变成空格 Eg:\n1 convmv -f GBK -t UTF-8 --notest –-unescap *.mp3 参考链接👉 https://www.shuzhiduo.com/A/RnJWmlWvdq/","title":"Linux 下文件名字乱码（无效的编码）（invalid encoding）（Windows）"},{"content":"Hugo PaperMod 主题的 Code block 背景 (background) 颜色总是黑色，然后我使用 F12 检查之后发现，黑色的代码块背景源自一个 CSS 变量 “hljs-bg” ，然后我通过 Google 查到了如何修改这个变量的颜色值:\nhttps://github.com/adityatelange/hugo-PaperMod/discussions/645\n在网站（不是主题）中创建一个文件，例如 assets/css/extended/theme-vars-override.css\n1 2 3 4 5 6 7 8 9 10 11 12 13 source ├──archetypes ├── assets │ └── css │ └── extended │ ├── emacs.css │ └── theme-vars-override.css ├── config ├── content ├── layouts ├── public ├── resources └── themes 在 theme-vars-override.css 里面添加以下内容：\n1 2 3 4 5 6 7 8 9 10 11 :root { --theme: rgb(255, 255, 255); --entry: rgb(255, 255, 255); --primary: rgb(30, 30, 30); --secondary: rgb(108, 108, 108); --tertiary: rgb(214, 214, 214); --content: rgb(31, 31, 31); --hljs-bg: rgb(245, 246, 247); --code-bg: rgb(245, 246, 247); --border: rgb(238, 238, 238); } 重新生成网站就行，喜欢什么配色可以自己微调\n而代码块的代码高亮其实也是有着自己的主题的，因为我使用的代码块背景是 light 的，所以代码高亮的主题使用了 emacs\n首先得启用 chroma 颜色高亮，需要禁用 hljs :\nhttps://github.com/adityatelange/hugo-PaperMod/wiki/FAQs#using-hugos-syntax-highlighter-chroma\n然后在网站目录（不是主题目录）下生成对应的 chroma 主题文件：\n1 hugo gen chromastyles --style=emacs \u0026gt; assets/css/extended/emacs.css 想要其他的 chroma 代码高亮主题可以在这个网站下面找：\nhttps://xyproto.github.io/splash/docs/all.html\n但是 hugo 的这个 emacs 主题有点问题，里面某些代码的高亮是灰色的，在亮色的背景下面就会看不清，需要把这部分的代码改成黑色，这需要在上面生成的 emacs.css 里面修改这一行代码：\n1 /* CodeLine */ .chroma .cl {color:#333333; } 这样子就基本完成配置了\n","permalink":"https://hcy-asleep.github.io/Hugo-PaperMod-%E6%94%B9%E5%8F%98%E4%B8%BB%E9%A2%98%E9%85%8D%E8%89%B2%E4%BB%A3%E7%A0%81%E5%9D%97%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2/","summary":"Hugo PaperMod 主题的 Code block 背景 (background) 颜色总是黑色，然后我使用 F12 检查之后发现，黑色的代码块背景源自一个 CSS 变量 “hljs-bg” ，然后我通过 Google 查到了如何修改这个变量的颜色值:\nhttps://github.com/adityatelange/hugo-PaperMod/discussions/645\n在网站（不是主题）中创建一个文件，例如 assets/css/extended/theme-vars-override.css\n1 2 3 4 5 6 7 8 9 10 11 12 13 source ├──archetypes ├── assets │ └── css │ └── extended │ ├── emacs.css │ └── theme-vars-override.css ├── config ├── content ├── layouts ├── public ├── resources └── themes 在 theme-vars-override.css 里面添加以下内容：\n1 2 3 4 5 6 7 8 9 10 11 :root { --theme: rgb(255, 255, 255); --entry: rgb(255, 255, 255); --primary: rgb(30, 30, 30); --secondary: rgb(108, 108, 108); --tertiary: rgb(214, 214, 214); --content: rgb(31, 31, 31); --hljs-bg: rgb(245, 246, 247); --code-bg: rgb(245, 246, 247); --border: rgb(238, 238, 238); } 重新生成网站就行，喜欢什么配色可以自己微调","title":"Hugo PaperMod 改变主题配色（代码块背景颜色）"},{"content":"VIM设置代码折叠\nzc 关闭当前打开的折叠 (也就是重新折叠起来) zo 打开当前的折叠 (也就是展开折叠) zm 关闭所有折叠 (也就是将所有展开的折叠都重新折叠起来) zM 关闭所有折叠及其嵌套的折叠 zr 打开所有折叠 zR 打开所有折叠及其嵌套的折叠 zd 删除当前折叠 zE 删除所有折叠 zj 移动至下一个折叠 zk 移动至上一个折叠 zn 禁用折叠 zN 启用折叠 ","permalink":"https://hcy-asleep.github.io/VIM-%E4%BB%A3%E7%A0%81%E6%8A%98%E5%8F%A0-Folding/","summary":"VIM设置代码折叠\nzc 关闭当前打开的折叠 (也就是重新折叠起来) zo 打开当前的折叠 (也就是展开折叠) zm 关闭所有折叠 (也就是将所有展开的折叠都重新折叠起来) zM 关闭所有折叠及其嵌套的折叠 zr 打开所有折叠 zR 打开所有折叠及其嵌套的折叠 zd 删除当前折叠 zE 删除所有折叠 zj 移动至下一个折叠 zk 移动至上一个折叠 zn 禁用折叠 zN 启用折叠 ","title":"VIM 代码折叠 Folding"},{"content":"在 Linux （Mac）使用 git status 或者 git ls-files 的时候，若 git 在显示中文文件名的时候出现类似下面这个乱码：\n\u0026quot;\\321\\203\\321\\201\\321\\202\\320\\260\\320\\275\\320\\276\\320\\262\u0026quot;\n这个因为 git 默认预设之会打印出 non-ASCII 字符，对于 UTF-8 的文件名或者信息，会用 quoted octal notation 印出。\nGit has always used octal utf8 display, and one way to show the actual name is by using printf in a bash shell.\nSince Git 1.7.10 introduced the support of unicode, this wiki page mentions:\nBy default, git will print non-ASCII file names in quoted octal notation, i.e. “\\nnn\\nnn…”.\n要使 git 能正常显示中文，使用一下命令\n1 git config [--global] core.quotepath off Reference👇\nhttp://stackoverflow.com/a/22828826/3744499\nhttps://leoluyi.tw/git/git-display-utf8\n","permalink":"https://hcy-asleep.github.io/Git-%E4%BF%AE%E6%AD%A3%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/","summary":"在 Linux （Mac）使用 git status 或者 git ls-files 的时候，若 git 在显示中文文件名的时候出现类似下面这个乱码：\n\u0026quot;\\321\\203\\321\\201\\321\\202\\320\\260\\320\\275\\320\\276\\320\\262\u0026quot;\n这个因为 git 默认预设之会打印出 non-ASCII 字符，对于 UTF-8 的文件名或者信息，会用 quoted octal notation 印出。\nGit has always used octal utf8 display, and one way to show the actual name is by using printf in a bash shell.\nSince Git 1.7.10 introduced the support of unicode, this wiki page mentions:\nBy default, git will print non-ASCII file names in quoted octal notation, i.","title":"Git 修正中文乱码"},{"content":" vimgrep 和 lvimgrep 是 vim 内置的搜索命令，可以处理不太复杂的正则表达式\n它们的搜索结果都会放入一个列表里面，grep 和 vimgrep 的搜索结果放在 quickfix list 里，quickfix list 可以使用 :cw 或者 :copen 在 vim 中打开，它的结果可以和所有的vim窗口共享；lgrep 和 lvimgrep 的结果存放在 location list 里，location list 是当前窗口的，可以使用 :lw 或者 :lopen 打开\n最妙的是搜索结果在cw或lw展现的时候，可以回车跳转到指定文件的搜索文本的位置\ng：代表所有匹配，而不是其中的一行匹配 j：代表vim不会自动跳转到第一个匹配的地方\n比如要在当前文件夹下递归所有文件搜索tar或者是zip，就可以这样搜：\n1 2 : lvim /\\\u0026lt;\\(tar\\|zip\\)\\\u0026gt;/gj **/* : lw tip: 使用cword取当前文件光标所在出的文字，.vimrc配置如下：\n1 map \u0026lt;F3\u0026gt; :execute \u0026#34;lvimgrep /\u0026#34; . expand(\u0026#34;\u0026lt;cword\u0026gt;\u0026#34;) . \u0026#34;/gj **/*\u0026#34; \u0026lt;Bar\u0026gt; lw\u0026lt;CR\u0026gt; 上述配置完成后，在vim中当前光标下，按下F3就会在vim的当前目录下搜索所有的文件及其子文件夹的文件，并显示出来，还可以使用 %:e 来做，意思是当前目录（%）下的同类型文件（e），如下：\n1 map \u0026lt;F3\u0026gt; :execute \u0026#34;lvimgrep /\u0026#34; . expand(\u0026#34;\u0026lt;cword\u0026gt;\u0026#34;) . \u0026#34;/gj \u0026#34; . expand(\u0026#34;%:e\u0026#34;) \u0026lt;Bar\u0026gt; lw\u0026lt;CR\u0026gt; 关闭autocmds以加速搜索，使用vimgrep搜索上百个文件会很慢，而用外置的grep就很快，一个原因是vimgrep使用vim的时序来读取文件，而这个时序将执行几个autocommands，所以我们在检索时关掉这个功能就会提速不少，所以最终的vimrc中配置如下：\n1 map \u0026lt;F3\u0026gt; :noautocmd execute \u0026#34;lvimgrep /\u0026#34; . expand(\u0026#34;\u0026lt;cword\u0026gt;\u0026#34;) . \u0026#34;/gj **/*\u0026#34; \u0026lt;Bar\u0026gt; lw\u0026lt;CR\u0026gt; ","permalink":"https://hcy-asleep.github.io/VIM-%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%85%B3%E9%94%AE%E8%AF%8D/","summary":"vimgrep 和 lvimgrep 是 vim 内置的搜索命令，可以处理不太复杂的正则表达式\n它们的搜索结果都会放入一个列表里面，grep 和 vimgrep 的搜索结果放在 quickfix list 里，quickfix list 可以使用 :cw 或者 :copen 在 vim 中打开，它的结果可以和所有的vim窗口共享；lgrep 和 lvimgrep 的结果存放在 location list 里，location list 是当前窗口的，可以使用 :lw 或者 :lopen 打开\n最妙的是搜索结果在cw或lw展现的时候，可以回车跳转到指定文件的搜索文本的位置\ng：代表所有匹配，而不是其中的一行匹配 j：代表vim不会自动跳转到第一个匹配的地方\n比如要在当前文件夹下递归所有文件搜索tar或者是zip，就可以这样搜：\n1 2 : lvim /\\\u0026lt;\\(tar\\|zip\\)\\\u0026gt;/gj **/* : lw tip: 使用cword取当前文件光标所在出的文字，.vimrc配置如下：\n1 map \u0026lt;F3\u0026gt; :execute \u0026#34;lvimgrep /\u0026#34; . expand(\u0026#34;\u0026lt;cword\u0026gt;\u0026#34;) . \u0026#34;/gj **/*\u0026#34; \u0026lt;Bar\u0026gt; lw\u0026lt;CR\u0026gt; 上述配置完成后，在vim中当前光标下，按下F3就会在vim的当前目录下搜索所有的文件及其子文件夹的文件，并显示出来，还可以使用 %:e 来做，意思是当前目录（%）下的同类型文件（e），如下：\n1 map \u0026lt;F3\u0026gt; :execute \u0026#34;lvimgrep /\u0026#34; .","title":"VIM 全局搜索目录下所有文件关键词"},{"content":"我自己的:\n1 2 3 4 5 6 cd $(dirname $0) cur=`date +%Y-%m-%d\\ \\|\\ %H-%M-%S` git add -A git commit -m \u0026#34;$cur\u0026#34; git push -f origin main unset cur 网上的:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/bash echo \u0026#34;=================\u0026#34; echo \u0026#34;auto git by JOEY\u0026#34; echo \u0026#34;======= 🤪 =========\u0026#34; echo -e \u0026#34; ▶ \\033[33;1mgit add . \\033[0m\u0026#34; git add . git status echo -e \u0026#34; ▶ \\033[33;1mcommit message: \\033[37;1m\u0026#34; read msg echo -e \u0026#34; ▶ \\033[33;1mgit commit -m \u0026#39;$msg\u0026#39; \\033[0m\u0026#34; git commit -m \u0026#34;$msg\u0026#34; echo -e \u0026#34; ▶ \\033[33;1mgit push \u0026#34; echo -e \u0026#34;\\033[37;1mstart pushing ...\\033[0m \u0026#34; git push echo -e \u0026#34; \\033[37;1mAll Done\\033[0m\u0026#34; ","permalink":"https://hcy-asleep.github.io/Git-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%8F%90%E4%BA%A4%E8%84%9A%E6%9C%AC-bash/","summary":"我自己的:\n1 2 3 4 5 6 cd $(dirname $0) cur=`date +%Y-%m-%d\\ \\|\\ %H-%M-%S` git add -A git commit -m \u0026#34;$cur\u0026#34; git push -f origin main unset cur 网上的:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/bash echo \u0026#34;=================\u0026#34; echo \u0026#34;auto git by JOEY\u0026#34; echo \u0026#34;======= 🤪 =========\u0026#34; echo -e \u0026#34; ▶ \\033[33;1mgit add .","title":"Git 自动化提交脚本 (bash)"},{"content":"VIM 的自带补全是根据上下文出现过的单词作为补全元的，将以下代码加入到你的 init.vim 里面就可以实现 Tab 触发补全以及连续使用 Tab 来进行切换选中补全\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026#34; Simple tab completion ----------------------------------------------------------------------------- \u0026#34; A simple tab completion, if you use the coc.nvim, you should remove this simple completion inoremap \u0026lt;expr\u0026gt; \u0026lt;Tab\u0026gt; getline(\u0026#39;.\u0026#39;)[col(\u0026#39;.\u0026#39;)-2] !~ \u0026#39;^\\s\\?$\u0026#39; \\|\\| pumvisible() \\ ? \u0026#39;\u0026lt;C-N\u0026gt;\u0026#39; : \u0026#39;\u0026lt;Tab\u0026gt;\u0026#39; inoremap \u0026lt;expr\u0026gt; \u0026lt;S-Tab\u0026gt; pumvisible() \\|\\| getline(\u0026#39;.\u0026#39;)[col(\u0026#39;.\u0026#39;)-2] !~ \u0026#39;^\\s\\?$\u0026#39; \\ ? \u0026#39;\u0026lt;C-P\u0026gt;\u0026#39; : \u0026#39;\u0026lt;Tab\u0026gt;\u0026#39; augroup SimpleComplete autocmd CmdwinEnter * inoremap \u0026lt;expr\u0026gt; \u0026lt;buffer\u0026gt; \u0026lt;Tab\u0026gt; \\ getline(\u0026#39;.\u0026#39;)[col(\u0026#39;.\u0026#39;)-2] !~ \u0026#39;^\\s\\?$\u0026#39; \\|\\| pumvisible() \\ ? \u0026#39;\u0026lt;C-X\u0026gt;\u0026lt;C-V\u0026gt;\u0026#39; : \u0026#39;\u0026lt;Tab\u0026gt;\u0026#39; augroup END \u0026#34; When you use konsole, you may need this hi Pmenu ctermfg=yellow hi PmenuSel ctermbg=darkgray ctermfg=white 不过值得注意的是，这个 VIM 设置片段不应该与其他那些自动补全插件一起使用，容易造成冲突，比如不能和 coc.nvim 一起使用\n","permalink":"https://hcy-asleep.github.io/VIM-%E8%87%AA%E5%B8%A6%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8/","summary":"VIM 的自带补全是根据上下文出现过的单词作为补全元的，将以下代码加入到你的 init.vim 里面就可以实现 Tab 触发补全以及连续使用 Tab 来进行切换选中补全\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026#34; Simple tab completion ----------------------------------------------------------------------------- \u0026#34; A simple tab completion, if you use the coc.nvim, you should remove this simple completion inoremap \u0026lt;expr\u0026gt; \u0026lt;Tab\u0026gt; getline(\u0026#39;.\u0026#39;)[col(\u0026#39;.\u0026#39;)-2] !~ \u0026#39;^\\s\\?$\u0026#39; \\|\\| pumvisible() \\ ? \u0026#39;\u0026lt;C-N\u0026gt;\u0026#39; : \u0026#39;\u0026lt;Tab\u0026gt;\u0026#39; inoremap \u0026lt;expr\u0026gt; \u0026lt;S-Tab\u0026gt; pumvisible() \\|\\| getline(\u0026#39;.\u0026#39;)[col(\u0026#39;.\u0026#39;)-2] !~ \u0026#39;^\\s\\?$\u0026#39; \\ ? \u0026#39;\u0026lt;C-P\u0026gt;\u0026#39; : \u0026#39;\u0026lt;Tab\u0026gt;\u0026#39; augroup SimpleComplete autocmd CmdwinEnter * inoremap \u0026lt;expr\u0026gt; \u0026lt;buffer\u0026gt; \u0026lt;Tab\u0026gt; \\ getline(\u0026#39;.","title":"VIM 自带的自动补全"},{"content":" Podman 默认注册表配置文件在 /etc/containers/registries.conf\n国内的镜像源有:\ndocker官方中国区 https://registry.docker-cn.com 网易 http://hub-mirror.c.163.com USTC http://docker.mirrors.ustc.edu.cn 阿里云 http://\u0026lt;你的ID\u0026gt;.mirror.aliyuncs.com 修改为以下内容:\n1 2 3 4 5 6 # 这个是添加 dockerhub 的搜索源 unqualified-search-registries = [\u0026#34;docker.io\u0026#34;] [[registry]] prefix = \u0026#34;docker.io\u0026#34; location = \u0026#34;xxxxxxxx.mirror.aliyuncs.com\u0026#34; ","permalink":"https://hcy-asleep.github.io/Podman-%E6%8D%A2%E6%BA%90/","summary":" Podman 默认注册表配置文件在 /etc/containers/registries.conf\n国内的镜像源有:\ndocker官方中国区 https://registry.docker-cn.com 网易 http://hub-mirror.c.163.com USTC http://docker.mirrors.ustc.edu.cn 阿里云 http://\u0026lt;你的ID\u0026gt;.mirror.aliyuncs.com 修改为以下内容:\n1 2 3 4 5 6 # 这个是添加 dockerhub 的搜索源 unqualified-search-registries = [\u0026#34;docker.io\u0026#34;] [[registry]] prefix = \u0026#34;docker.io\u0026#34; location = \u0026#34;xxxxxxxx.mirror.aliyuncs.com\u0026#34; ","title":"Podman 换源"},{"content":"直接上代码，就完事了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;style\u0026gt; .parent { margin-top:25px; position: relative; } .parent .child { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); width:100%; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;audio controls class=\u0026#34;child\u0026#34;\u0026gt; \u0026lt;source src=\u0026#34;horse.mp3\u0026#34; type=\u0026#34;audio/mpeg\u0026#34;\u0026gt; Your browser does not support the audio element. \u0026lt;/audio\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","permalink":"https://hcy-asleep.github.io/Hugo-Hexo-%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/","summary":"直接上代码，就完事了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;style\u0026gt; .parent { margin-top:25px; position: relative; } .parent .child { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); width:100%; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;audio controls class=\u0026#34;child\u0026#34;\u0026gt; \u0026lt;source src=\u0026#34;horse.mp3\u0026#34; type=\u0026#34;audio/mpeg\u0026#34;\u0026gt; Your browser does not support the audio element. \u0026lt;/audio\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","title":"Hugo Hexo 添加音乐播放器"},{"content":"说真的，能认识这一首歌是隔壁宿舍杨教士传给我的，然后就是现在这个样子，佤也成为了一名传教士。这首歌的 Drill 是其灵魂所在，前奏和尾声都是 \u0026ldquo;River Flows In You\u0026rdquo; 的影子，一开始觉得挺搞的，后面越听越觉得悲惨\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 作词 : 王云宏 作曲 : 王云宏 编曲 : YvngRick 直到外面下了大雨 我才选择离开，唉 我会控制不住的想你 我的女孩，唉 一个人喝苦咖啡好好干给他一大杯 不想擦眼泪你说我是寨子鬼 本来不会醉v8才是忘情水 我是真的累 我是真的累 为什么不喝南腊 我怕我会想你 我们熟悉的包谷地 我提去你家的腊肉 你吃了没有 你爸妈说相当香 你说的话就像农药把我干掉 我听了就睡不着 我送你的vivo我借钱买的 都分手了还在还钱 你是我的观音菩萨 我是你的刘德滑 你是我的观音菩萨 我是你的刘德滑 直到外面下了大雨 我才选择离开，唉 我会控制不住的想你 我的女孩，唉 一个人喝苦咖啡好好干给他一大杯 不想擦眼泪你说我是寨子鬼 本来不会醉v8才是忘情水 我是真的累 我是真的累 你是我的观音菩萨 我是你的刘德滑 你是我的观音菩萨 我是你的刘德滑 你不爱么我也不爱了嘛 搭伙都不爱了嘛 Your browser does not support the audio element. ","permalink":"https://hcy-asleep.github.io/%E4%BD%A4%E5%92%96%E5%95%A1%E6%9C%89%E6%84%9F/","summary":"说真的，能认识这一首歌是隔壁宿舍杨教士传给我的，然后就是现在这个样子，佤也成为了一名传教士。这首歌的 Drill 是其灵魂所在，前奏和尾声都是 \u0026ldquo;River Flows In You\u0026rdquo; 的影子，一开始觉得挺搞的，后面越听越觉得悲惨\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 作词 : 王云宏 作曲 : 王云宏 编曲 : YvngRick 直到外面下了大雨 我才选择离开，唉 我会控制不住的想你 我的女孩，唉 一个人喝苦咖啡好好干给他一大杯 不想擦眼泪你说我是寨子鬼 本来不会醉v8才是忘情水 我是真的累 我是真的累 为什么不喝南腊 我怕我会想你 我们熟悉的包谷地 我提去你家的腊肉 你吃了没有 你爸妈说相当香 你说的话就像农药把我干掉 我听了就睡不着 我送你的vivo我借钱买的 都分手了还在还钱 你是我的观音菩萨 我是你的刘德滑 你是我的观音菩萨 我是你的刘德滑 直到外面下了大雨 我才选择离开，唉 我会控制不住的想你 我的女孩，唉 一个人喝苦咖啡好好干给他一大杯 不想擦眼泪你说我是寨子鬼 本来不会醉v8才是忘情水 我是真的累 我是真的累 你是我的观音菩萨 我是你的刘德滑 你是我的观音菩萨 我是你的刘德滑 你不爱么我也不爱了嘛 搭伙都不爱了嘛 Your browser does not support the audio element.","title":"佤咖啡有感"},{"content":"在终端执行 flameshot gui 的时候异常，安装 xdg-desktop-portal 包就行，Gnome 桌面环境的话安装 xdg-desktop-portal-gnome\n","permalink":"https://hcy-asleep.github.io/Flameshot-Arch-%E6%97%A0%E6%B3%95%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8/","summary":"在终端执行 flameshot gui 的时候异常，安装 xdg-desktop-portal 包就行，Gnome 桌面环境的话安装 xdg-desktop-portal-gnome","title":"Flameshot Arch 无法命令行使用"},{"content":" 创建容器并且端口映射以及后台运行\n1 docker run -it -d -p 9009:22 ubuntu /bin/bash 查看containerId (或者containerAlias)\n1 docker ps -a 进入容器\n1 2 3 # 这里的 containerId 换成 containerAlias 也是可以的 docker start containerId docker exec -it containerId /bin/bash ubuntu 更新源列表\n1 apt-get update 安装ssh-client、ssh-server\n1 2 3 4 apt-get install openssh-client apt-get install openssh-server # 安装 neovim 工具 apt-get install neovim 编辑 sshd_config 文件\n1 vim /etc/ssh/sshd_config 允许 ssh 以 root 用户登录\n1 PermitRootLogin yes 设置 root 密码，同时也是设置 ssh root登录的密码\n1 passwd root 安装完成后，先启动ssh服务\n1 /etc/init.d/ssh start 查看是否正确启动\n1 ps -e | grep ssh 由于将 container 的 22 端口映射到了 host 的 9009 端口，所以可以以下登录\n1 ssh root@host_ip -p 9009 ","permalink":"https://hcy-asleep.github.io/SSH%E8%BF%9E%E6%8E%A5Docker%E5%AE%B9%E5%99%A8/","summary":"创建容器并且端口映射以及后台运行\n1 docker run -it -d -p 9009:22 ubuntu /bin/bash 查看containerId (或者containerAlias)\n1 docker ps -a 进入容器\n1 2 3 # 这里的 containerId 换成 containerAlias 也是可以的 docker start containerId docker exec -it containerId /bin/bash ubuntu 更新源列表\n1 apt-get update 安装ssh-client、ssh-server\n1 2 3 4 apt-get install openssh-client apt-get install openssh-server # 安装 neovim 工具 apt-get install neovim 编辑 sshd_config 文件\n1 vim /etc/ssh/sshd_config 允许 ssh 以 root 用户登录\n1 PermitRootLogin yes 设置 root 密码，同时也是设置 ssh root登录的密码","title":"SSH连接Docker容器"},{"content":"通过配置/etc/ssh/sshd_config文件的AllowUsers，可以添加多个允许登录的用户名，不同用户名之间用空格分开，不在其中的用户则不可以登录\n1 AllowUsers [username] 例如只想允许john和teena两个用户通过ssh登录，其余用户均不允许\n1 AllowUsers john teena 执行下面的命令，重启sshd服务使配置生效\n1 service sshd restart ","permalink":"https://hcy-asleep.github.io/SSH-%E5%85%81%E8%AE%B8%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95/","summary":"通过配置/etc/ssh/sshd_config文件的AllowUsers，可以添加多个允许登录的用户名，不同用户名之间用空格分开，不在其中的用户则不可以登录\n1 AllowUsers [username] 例如只想允许john和teena两个用户通过ssh登录，其余用户均不允许\n1 AllowUsers john teena 执行下面的命令，重启sshd服务使配置生效\n1 service sshd restart ","title":"SSH 允许非root用户登录"},{"content":" 免密码登录\n1 jupyter notebook --ip=\u0026#39;*\u0026#39; --NotebookApp.token=\u0026#39;\u0026#39; --NotebookApp.password=\u0026#39;\u0026#39; 其中 \u0026hellip; \u0026ndash;ip=\u0026rsquo;*\u0026rsquo; \u0026hellip; 表示允许所有 ip 访问而不仅是本机的 127.0.0.1 ，从而达到远程连接的效果 远程连接但是加上一点点安全性\n1 jupyter notebook --ip=\u0026#39;*\u0026#39; --NotebookApp.token=\u0026#39;hcy\u0026#39; 设置 token 为 hcy ，远程访问的时候如下访问\n1 2 # {jupyter notebook ip}:8888/?token=hcy http://172.35.40.120:8888/?token=hcy ","permalink":"https://hcy-asleep.github.io/Jupyter-Notebook-%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE-%E5%85%8D%E5%AF%86-%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95/","summary":" 免密码登录\n1 jupyter notebook --ip=\u0026#39;*\u0026#39; --NotebookApp.token=\u0026#39;\u0026#39; --NotebookApp.password=\u0026#39;\u0026#39; 其中 \u0026hellip; \u0026ndash;ip=\u0026rsquo;*\u0026rsquo; \u0026hellip; 表示允许所有 ip 访问而不仅是本机的 127.0.0.1 ，从而达到远程连接的效果 远程连接但是加上一点点安全性\n1 jupyter notebook --ip=\u0026#39;*\u0026#39; --NotebookApp.token=\u0026#39;hcy\u0026#39; 设置 token 为 hcy ，远程访问的时候如下访问\n1 2 # {jupyter notebook ip}:8888/?token=hcy http://172.35.40.120:8888/?token=hcy ","title":"Jupyter Notebook 远程访问 免密 设置密码登录"},{"content":"So easy：\n1 2 # curl \u0026#34;http://172.30.255.42:801/eportal/portal/login?user_account={校园卡卡号}\u0026amp;user_password={校园卡密码}\u0026#34; curl \u0026#34;http://172.30.255.42:801/eportal/portal/login?user_account=392257\u0026amp;user_password=12345678\u0026#34; ","permalink":"https://hcy-asleep.github.io/SZU-%E5%AE%BF%E8%88%8D%E5%8C%BA%E4%B8%8A%E7%BD%91-%E5%91%BD%E4%BB%A4%E8%A1%8C/","summary":"So easy：\n1 2 # curl \u0026#34;http://172.30.255.42:801/eportal/portal/login?user_account={校园卡卡号}\u0026amp;user_password={校园卡密码}\u0026#34; curl \u0026#34;http://172.30.255.42:801/eportal/portal/login?user_account=392257\u0026amp;user_password=12345678\u0026#34; ","title":"SZU 宿舍区上网 命令行"},{"content":"hugo server 命令一般是在 127.0.0.1 启动服务，而使用以下命令就可以远端预览 hugo server 的结果\n1 hugo server --bind=0.0.0.0 --baseURL={启动服务的机器的IP} 比如说我在服务器写了 passage ，在服务器 hugo server ，想在本地浏览器看到 server 效果，这时候 {启动服务的机器的IP} 就是服务器的 IP\n我在内网远端预览\n1 hugo server --bind=0.0.0.0 --baseURL=172.29.40.118 ","permalink":"https://hcy-asleep.github.io/Hugo-Server-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/","summary":"hugo server 命令一般是在 127.0.0.1 启动服务，而使用以下命令就可以远端预览 hugo server 的结果\n1 hugo server --bind=0.0.0.0 --baseURL={启动服务的机器的IP} 比如说我在服务器写了 passage ，在服务器 hugo server ，想在本地浏览器看到 server 效果，这时候 {启动服务的机器的IP} 就是服务器的 IP\n我在内网远端预览\n1 hugo server --bind=0.0.0.0 --baseURL=172.29.40.118 ","title":"Hugo Server 远程调试"},{"content":" 首先\n1 sudo vim /etc/default/grub 修改参数保存\n1 GRUB_GFXMODE=1920x1080x32 重新构建 grub\nArch\n1 sudo grub-mkconfig -o /boot/grub/grub.cfg Debian\n1 sudo update-grub ","permalink":"https://hcy-asleep.github.io/Linux-Grub-%E5%88%86%E8%BE%A8%E7%8E%87/","summary":" 首先\n1 sudo vim /etc/default/grub 修改参数保存\n1 GRUB_GFXMODE=1920x1080x32 重新构建 grub\nArch\n1 sudo grub-mkconfig -o /boot/grub/grub.cfg Debian\n1 sudo update-grub ","title":"Linux Grub 分辨率"},{"content":"Arch Plasma 界面关闭有时候要三分钟左右，查阅了网上大量资料，最终找到一个可以用的方法\n编辑 systemd 配置\n1 sudo nvim /etc/systemd/system.conf 改里面的两项，先去掉注释，再改时间\n1 2 DefaultTimeoutStopSec=1ms DefaultRestartSec=1ms ","permalink":"https://hcy-asleep.github.io/KDE-Slow-Shutdown/","summary":"Arch Plasma 界面关闭有时候要三分钟左右，查阅了网上大量资料，最终找到一个可以用的方法\n编辑 systemd 配置\n1 sudo nvim /etc/systemd/system.conf 改里面的两项，先去掉注释，再改时间\n1 2 DefaultTimeoutStopSec=1ms DefaultRestartSec=1ms ","title":"KDE Slow Shutdown"},{"content":"👉 感谢 askubuntu\nIn Thunar Edit \u0026gt; Configure custom actions\u0026hellip; then edit \u0026ldquo;Open Terminal Here\u0026rdquo;, and replace exo-open --working-directory %f --launch TerminalEmulator with konsole --workdir %f\n经过我的尝试，直接替换成 alacritty 也是可以的\n","permalink":"https://hcy-asleep.github.io/Thunar-%E8%AE%BE%E7%BD%AE%E6%89%93%E5%BC%80%E7%BB%88%E7%AB%AF/","summary":"👉 感谢 askubuntu\nIn Thunar Edit \u0026gt; Configure custom actions\u0026hellip; then edit \u0026ldquo;Open Terminal Here\u0026rdquo;, and replace exo-open --working-directory %f --launch TerminalEmulator with konsole --workdir %f\n经过我的尝试，直接替换成 alacritty 也是可以的","title":"Thunar 设置打开终端"},{"content":"引言 起初我是使用 Hexo+NexT 来搭建博客的，我对 Hexo 不满意的地方有两个，一个是生成速度，另外一个是依赖太多，以至于我都要把我的 Hexo 环境打包成 docker 分发到每一个写博客的机子。而 Hugo 就完美解决了这两个问题，可也并不是说 Hugo 毫无缺点。Hugo 最大的缺点是生态尚未完善，看着 github 上面那些 star 数量都不超过一千的主题实在是不太敢使用。但是 Hugo 的生成速度足以实时预览，这个是 Hexo 难以匹敌的。同时迁移成本也是我从 Hexo 迁移到 Hugo 的考虑之一，几乎没有迁移成本让我瞬间有了动力，要是说仅有的迁移成本，那也是 Hexo 的站内链接不适用而已。我不用考虑图片迁移问题，毕竟我是使用 Githb+Picgo 来进行图床存储的。如果你是一个 Rust 粉，你也可以考虑 Zola ，只不过 Zola 的生态更加贫瘠，对于我这种前端小白来说不太友好😭\n感谢为爱发电的开源作者们 👉 Picgo Github 仓库\n👉 Hugo 官方中文文档\n👉 Hugo Papermod Theme Github 仓库\n正文 PaperMod theme 配置小技巧\n代码块显示行数(Code block line number display)\n1 2 # config.yaml pygmentsOptions: linenos=table Hexo 生成的 URL 是和文章标题一一对应的，而 Hugo 会默认将标题的首字母小写，本来就是小站长，好不容易被收录的网站岂能丢掉? 一句话禁止 URL 自动首字母小写\n1 2 # config.yaml disablePathToLower: true SEO 优化，让网站结构更加扁平化\n1 2 3 4 # config.yaml permalinks: post: /:slug/ page: /:slug/ 允许在 markdown 里面嵌入 HTML\n1 2 3 4 5 # config.yaml markup: goldmark: renderer: unsafe: true 文章大纲（文章导航）\n文章导航在 hugo 里面也叫 table of content 即 toc\n1 2 3 4 # config.yaml params: showtoc: true tocopen: false 评论系统(Giscus)\n1 2 3 # config.yaml params: comments: true 创建指定位置的 comments.html 文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 site_source/ | archetypes/ | assets/ | config/ | content/ | data/ | layouts/ | | _default/ | | partials/ | | | comments.html | | | extend_head.html | public/ | resources/ | static/ | themes/ comments.html 文件里面写入(尚未配置仓库和/或分类这些字段之前，不会显示这些字段的值)\n👉 Giscus 详细字段获取\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script src=\u0026#34;https://giscus.app/client.js\u0026#34; data-repo=\u0026#34;[在此输入仓库]\u0026#34; data-repo-id=\u0026#34;[在此输入仓库 ID]\u0026#34; data-category=\u0026#34;[在此输入分类名]\u0026#34; data-category-id=\u0026#34;[在此输入分类 ID]\u0026#34; data-mapping=\u0026#34;pathname\u0026#34; data-strict=\u0026#34;0\u0026#34; data-reactions-enabled=\u0026#34;1\u0026#34; data-emit-metadata=\u0026#34;0\u0026#34; data-input-position=\u0026#34;bottom\u0026#34; data-theme=\u0026#34;preferred_color_scheme\u0026#34; data-lang=\u0026#34;zh-CN\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; 支持放大图片(Zoom images)\n👉 解决方法源自 Github Issues\n创建指定位置的 render-image.html 文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 site_source/ | archetypes/ | assets/ | config/ | content/ | data/ | layouts/ | | _default/ | | | _markup/ | | | | render-image.html | | partials/ | public/ | resources/ | static/ | themes/ render-image.html 文件里面写入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!-- Checks if page is part of section and page is not section itself --\u0026gt; {{- if and (ne .Page.Kind \u0026#34;section\u0026#34;) (.Page.Section ) }} \u0026lt;!-- Generate a unique id for each image --\u0026gt; {{- $random := (substr (md5 .Destination) 0 5) }} \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;zoomCheck-{{$random}}\u0026#34; hidden\u0026gt; \u0026lt;label for=\u0026#34;zoomCheck-{{$random}}\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;zoomCheck\u0026#34; loading=\u0026#34;lazy\u0026#34; decoding=\u0026#34;async\u0026#34; src=\u0026#34;{{ .Destination | safeURL }}\u0026#34; alt=\u0026#34;{{ .Text }}\u0026#34; {{ with.Title}} title=\u0026#34;{{ . }}\u0026#34; {{ end }} /\u0026gt; \u0026lt;/label\u0026gt; {{- else }} \u0026lt;img loading=\u0026#34;lazy\u0026#34; decoding=\u0026#34;async\u0026#34; src=\u0026#34;{{ .Destination | safeURL }}\u0026#34; alt=\u0026#34;{{ .Text }}\u0026#34; {{ with .Title}} title=\u0026#34;{{ . }}\u0026#34; {{ end }} /\u0026gt; {{- end }} 创建指定位置的 extend_head.html 文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 site_source/ | archetypes/ | assets/ | config/ | content/ | data/ | layouts/ | | _default/ | | partials/ | | | comments.html | | | extend_head.html | public/ | resources/ | static/ | themes/ extend_head.html 文件里面写入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;style\u0026gt; @media screen and (min-width: 1px) { /* .post-content is a class which will be present only on single pages and not lists and section pages in Hugo */ .post-content input[type=\u0026#34;checkbox\u0026#34;]:checked ~ label \u0026gt; img { transform: scale(1.6); cursor: zoom-out; position: relative; z-index: 999; } .post-content img.zoomCheck { transition: transform 0.15s ease; z-index: 999; cursor: zoom-in; } } \u0026lt;/style\u0026gt; 其他的关于代码块语法高亮，搜索界面，归档界面都可以在 PaperMod 的 Wiki 文档里面找到答案\n👉 Wiki\nHugo 与 Hexo 的使用区别\n文章头部如果使用了 draft:true ，那么这篇文件将不会被生成，只是作为草稿\nhugo server 等价于 hexo g \u0026amp;\u0026amp; hexo s ，但是不会将生成的文件存入磁盘中，也就是说，public 文件夹里面将不会有任何改变\nhexo d 就可以发布了，不过在 hugo 里面要先执行 hugo ，在 public 下生成 html 文件，然后在 pulbic 下 git push 发布\n我的 config.yaml 如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 baseURL: \u0026#34;https://hcy-asleep.github.io/\u0026#34; title: Memos paginate: 5 theme: PaperMod enableRobotsTXT: true buildDrafts: false buildFuture: true buildExpired: false googleAnalytics: UA-123-45 minify: disableXML: true minifyOutput: true params: env: production # to enable google analytics, opengraph, twitter-cards and schema. title: HCY-BLOGS description: \u0026#34;Welcome\u0026#34; keywords: [Blog, Portfolio, PaperMod] author: HCY # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors images: [\u0026#34;\u0026#34;] DateFormat: \u0026#34;January 2, 2006\u0026#34; defaultTheme: dark # dark, light disableThemeToggle: true ShowReadingTime: true ShowShareButtons: false ShowPostNavLinks: true ShowBreadCrumbs: true ShowCodeCopyButtons: true ShowWordCount: true ShowRssButtonInSectionTermList: true UseHugoToc: true disableSpecial1stPost: false disableScrollToTop: false comments: true hidemeta: false hideSummary: false showtoc: false tocopen: false assets: disableHLJS: true # to disable highlight.js # disableFingerprinting: true favicon: \u0026#34;https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png\u0026#34; favicon16x16: \u0026#34;https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png\u0026#34; favicon32x32: \u0026#34;https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png\u0026#34; apple_touch_icon: \u0026#34;https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png\u0026#34; safari_pinned_tab: \u0026#34;https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/hcy_site_favicon.png\u0026#34; label: text: \u0026#34;主页\u0026#34; icon: iconHeight: 35 # profile-mode profileMode: enabled: false # needs to be explicitly set title: ExampleSite subtitle: \u0026#34;This is subtitle\u0026#34; imageUrl: \u0026#34;\u0026lt;img location\u0026gt;\u0026#34; imageWidth: 120 imageHeight: 120 imageTitle: my image buttons: - name: Posts url: posts - name: Tags url: tags # home-info mode homeInfoParams: Title: \u0026#34;Hallo~ \\U0001F44B\u0026#34; Content: \u0026#34;Welcome to my blog\u0026#34; socialIcons: # - name: twitter # url: \u0026#34;https://twitter.com/\u0026#34; # - name: stackoverflow # url: \u0026#34;https://stackoverflow.com\u0026#34; - name: github url: \u0026#34;https://github.com/HCY-ASLEEP\u0026#34; - name: email url: \u0026#34;mailto:2420066864@qq.com\u0026#34; analytics: google: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; bing: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; yandex: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; cover: hidden: true # hide everywhere but not in structured data hiddenInList: true # hide on list pages and home hiddenInSingle: true # hide on single page editPost: URL: \u0026#34;https://github.com/HCY-ASLEEP\u0026#34; Text: \u0026#34; Follow me\u0026#34; # edit text appendFilePath: false # to append file path to Edit link # for search # https://fusejs.io/api/options.html fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.4 minMatchCharLength: 0 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] menu: main: - identifier: categories name: 目录 url: /categories/ weight: 20 - identifier: tags name: 标签 url: /tags/ weight: 10 - identifier: search name: 🔍 url: /search/ weight: 30 - identifier: archives name: 归档 url: /archives/ weight: 10 - identifier: about name: 关于 url: /about/ weight: 30 - identifier: friends name: 友链 url: /friends/ weight: 29 # Read: https://github.com/adityatelange/hugo-PaperMod/wiki/FAQs#using-hugos-syntax-highlighter-chroma pygmentsUseClasses: true markup: highlight: # noClasses: false # anchorLineNos: true codeFences: true guessSyntax: true lineNos: true style: monokailight goldmark: renderer: unsafe: true outputs: home: - HTML - RSS - JSON # is necessary disablePathToLower: true permalinks: post: /:slug/ page: /:slug/ pygmentsOptions: linenos=table ","permalink":"https://hcy-asleep.github.io/Migrate-to-Hugo/","summary":"引言 起初我是使用 Hexo+NexT 来搭建博客的，我对 Hexo 不满意的地方有两个，一个是生成速度，另外一个是依赖太多，以至于我都要把我的 Hexo 环境打包成 docker 分发到每一个写博客的机子。而 Hugo 就完美解决了这两个问题，可也并不是说 Hugo 毫无缺点。Hugo 最大的缺点是生态尚未完善，看着 github 上面那些 star 数量都不超过一千的主题实在是不太敢使用。但是 Hugo 的生成速度足以实时预览，这个是 Hexo 难以匹敌的。同时迁移成本也是我从 Hexo 迁移到 Hugo 的考虑之一，几乎没有迁移成本让我瞬间有了动力，要是说仅有的迁移成本，那也是 Hexo 的站内链接不适用而已。我不用考虑图片迁移问题，毕竟我是使用 Githb+Picgo 来进行图床存储的。如果你是一个 Rust 粉，你也可以考虑 Zola ，只不过 Zola 的生态更加贫瘠，对于我这种前端小白来说不太友好😭\n感谢为爱发电的开源作者们 👉 Picgo Github 仓库\n👉 Hugo 官方中文文档\n👉 Hugo Papermod Theme Github 仓库\n正文 PaperMod theme 配置小技巧\n代码块显示行数(Code block line number display)\n1 2 # config.yaml pygmentsOptions: linenos=table Hexo 生成的 URL 是和文章标题一一对应的，而 Hugo 会默认将标题的首字母小写，本来就是小站长，好不容易被收录的网站岂能丢掉?","title":"Migrate to Hugo"},{"content":"首先是感谢作者的工作，这个是此项目的地址\n我使用的是 vim-plug，首先是安装\n1 Plug \u0026#39;iamcco/markdown-preview.nvim\u0026#39;, { \u0026#39;do\u0026#39;: { -\u0026gt; mkdp#util#install() }, \u0026#39;for\u0026#39;: [\u0026#39;markdown\u0026#39;, \u0026#39;vim-plug\u0026#39;]} vim-plug 安装完之后，重启 vim ，打开 .vim 或者 .md 文件，手动安装离线版本\n1 :call mkdp#util#install() ","permalink":"https://hcy-asleep.github.io/Vim-iamcco/markdown-preview.nvim-without-nodejs/","summary":"首先是感谢作者的工作，这个是此项目的地址\n我使用的是 vim-plug，首先是安装\n1 Plug \u0026#39;iamcco/markdown-preview.nvim\u0026#39;, { \u0026#39;do\u0026#39;: { -\u0026gt; mkdp#util#install() }, \u0026#39;for\u0026#39;: [\u0026#39;markdown\u0026#39;, \u0026#39;vim-plug\u0026#39;]} vim-plug 安装完之后，重启 vim ，打开 .vim 或者 .md 文件，手动安装离线版本\n1 :call mkdp#util#install() ","title":"Vim =\u003e iamcco/markdown-preview.nvim without nodejs"},{"content":"live cd 安装使用 WIFI 先用命令 ip link查看网络接口\n1 ip link 查看到我的机器的无线网络接口是wlan0(不同的机器可能名字不同)，这里 wlan0 为例\n默认是关闭的状态，需要先开启它，而开启它之前还需要先激活它(即取消禁用，我这台机器默认是blockeded，禁用的)\n1 2 rfkill unblock wifi # 取消禁用wifi设备 ip link set wlan0 up # 开启wlan0 输入iwctl进入交互式提示符（interactive prompt），配置并连接到互联网\n1 2 3 4 5 station wlan0 scan station wlan0 get-networks station wlan0 connect \u0026lt;network name\u0026gt; station wlan0 show exit　# 回到命令行 ping百度可以ping通，就说明已经连接上了互联网\n免密 sudo Arch Linux run sudo without passwd\n首先\n1 sudo visudo 然后编辑里面的内容\n1 myname ALL=(ALL) NOPASSWD: ALL 添加中科大源 添加中科大的Arch Linux源\n编辑 /etc/pacman.d/mirrorlist ，在文件的最顶端添加\n1 Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch 添加中科大的Arch Linux CN源\n在 /etc/pacman.conf 文件末尾添加两行\n1 2 [archlinuxcn] Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch 然后安装 archlinuxcn-keyring 包以导入 GPG key\n1 sudo pacman -S archlinuxcn-keyring 安装 KDE 若有n卡驱动\n1 sudo pacman -S nvidia 安装 plasma\n1 2 3 sudo pacman -S plasma #完整版 plasma-meta #精简版 plasma-desktop #极简版，如果是这个版本，记得安装 alacritty 或者 konsole ，并不自带终端 安装启动界面\n1 2 sudo pacman -S sddm #启动界面 sudo systemctl enable sddm # 启用启动界面 中文 locale 编码和字体 locale配置\n可以执行命令locale查看当前配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ locale LANG=en_US.UTF-8 LANGUAGE=en_US LC_CTYPE=\u0026#34;en_US.UTF-8\u0026#34; LC_NUMERIC=en_US.UTF-8 LC_TIME=en_US.UTF-8 LC_COLLATE=\u0026#34;en_US.UTF-8\u0026#34; LC_MONETARY=en_US.UTF-8 LC_MESSAGES=\u0026#34;en_US.UTF-8\u0026#34; LC_PAPER=en_US.UTF-8 LC_NAME=en_US.UTF-8 LC_ADDRESS=en_US.UTF-8 LC_TELEPHONE=en_US.UTF-8 LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=en_US.UTF-8 LC_ALL= 注意：设置LC_ALL变量，会覆盖除了LANGUAGE之外的所有locale环境变量，因此尽量不要使用它\n安装中文locale\n使用UTF-8的locale，将en_US.UTF-8和zh_CN.UTF-8的注释从配置文件/etc/locale.gen去掉，即删除行首的#\n1 2 3 # /etc/locale.gen _US.UTF-8 UTF-8 _CN.UTF-8 UTF-8 然后执行\n1 sudo locale-gen 配置LANG和LANGUAGE\n设置locale全局配置文件/etc/locale.conf ，但不推荐在该文件中配置全局的中文locale，会导致 tty 乱码\n1 2 # /etc/locale.conf LANG=en_US.UTF-8 不同的用户可以在下列文件中，设置各自的环境变量\n1 2 3 4 5 6 # ~/.bashrc：每次使用终端登录时读取并运用里面的设置 # ~/.xinitrc：每次使用 startx 或 SLiM 启动 X 界面时读取并运用里面的设置 # ~/.xprofile：每次使用 GDM 等显示管理器登录时读取并运用里面的设置 export LANG=zh_CN.UTF-8 export LANGUAGE=zh_CN:en_US 安装中文字体\n1 2 3 4 5 6 7 8 9 10 # 这些是官方仓库里面的文泉驿字体 hcy@archlinux:~$ sudo pacman -Ss wqy community/wqy-bitmapfont 1.0.0RC1-5 [已安装] A bitmapped Song Ti (serif) Chinese font community/wqy-microhei 0.2.0_beta-11 [已安装] A Sans-Serif style high quality CJK outline font community/wqy-microhei-lite 0.2.0_beta-10 [已安装] The \u0026#34;Light\u0026#34; face of WenQuanYi Micro Hei font family community/wqy-zenhei 0.9.45-9 [已安装] A Hei Ti Style (sans-serif) Chinese Outline Font. 中文 fcitx5 安装 fcitx5 实现输入中文具体步骤如下\n1 2 sudo pacman -S fcitx5-im sudo pacman -S fcitx5-chinese-addons 其中 fcitx5-chinese-addons 包含了大量中文输入方式：拼音、双拼、五笔拼音、自然码、仓颉、冰蟾全息、二笔等\n然后在环境变量配置文件 /etc/environment 中添加如下内容\n1 2 3 4 5 6 7 # /etc/environment GTK_IM_MODULE=fcitx QT_IM_MODULE=fcitx XMODIFIERS=@im=fcitx INPUT_METHOD=fcitx SDL_IM_MODULE=fcitx GLFW_IM_MODULE=ibus 然后配置自动启动，提供以下3种方法，第一个不行，试第2个，然后第3个\n如果支持XDG桌面环境，例如KDE,GNOME, Xfce,默认重启后即可\n在~/.config/autostart目录下添加fcitx-autostart.desktop文件，可以从目录etc/xdg/autostart中复制\n对于i3-wm,可以在配置文件~/.config/i3/config中添加如下代码\n1 2 # fcitx5 exec_always --no-startup-id fcitx5 Fcitx5 Alacritty 显示问题 安装完成 fcitx5 中文输入法之后，其他界面都可以正常使用，就是 alacritty 不能使用，就连激活都没有办法激活\n直到我看到了这一篇博客\n只需要在 KDE Config 里面开启 Virtual Keyboard 就行了\n然后就可以愉快地享受 alacritty 啦\n开启 SSH 1 2 3 4 pacman -Sy openssh # 安装 echo \u0026#34;PermitRootLogin yes\u0026#34; \u0026gt;\u0026gt; \u0026#34;/etc/ssh/sshd_config\u0026#34; # 修改配置表 systemctl start sshd # 开启 systemctl enable sshd # 开机启动 配置 VNC 远程连接 在本文写的时候，VNC 远程连接 Wayland 显示协议只能说非常不成熟，甚至有点离谱，键盘压根输入不了，颜色反转，声音不能正常 pipewire 远程，因此如果将自己的桌面环境作为 VNC 远程后端，还是 X11/Xorg 协议体验好很多。与此同时，桌面环境里面，Xfce4 兼顾了流畅性与桌面功能健全性，虽然说 KDE 也是很健全的，但是 KDE 的动画在 VNC 远程里面反而是消耗资源的问题所在，远程体验不流畅。\n使用一个 GUI 的 VNC Server Manager：\n1 2 # KDE Remote Frame Buffer ，但是也是适用与其他桌面环境如 Xfce4 的 sudo pacman -S krfb 我是先安装了 KDE 和 SDDM 显示管理器再安装的 Xfce4\n1 sudo pacman -S xfce4 安装完 Xfce4 之后在 SDDM 的左下角就可以选择 Xfce4 还是 KDE 桌面\nkrfb 配置\nVNC 客户端推荐：\nWindows TigerVNC Linux krdc(KDE Remote Desktop Client) Android bVNC 有一些包是其他教程里面推荐的，不过我觉得应该不用\n1 2 3 sudo pacman -S xfce4-goodies # Xfce4 包组（group） sudo pacman -S xorg xorg-xinit sudo pacman -S xdg-desktop-portal 删除软件 我使用的是 archinstall 来安装 Arch KDE 的，在安装的时候是以 plasma-meta 整体安装，所以想卸载 discover 等组件的时候就会破坏依赖，所以采取下面的方法来卸载\n1 2 3 4 sudo pacman -Rdd discover # Software market sudo pacman -Rdd plasma-welcome sudo pacman -Rdd plasma-systemmonitor sudo pacman -Rdd drkonqi # Crash reporter 这种卸载方式只是单独卸载目标软件包，虽然在下次升级 plasma-meta 的时候还是会安装回来的，不过对我问题不大，升级之后再卸载就行\n如果一个包可以安全被卸载，想卸载干净的话 (卸载只是被它依赖的依赖)\n1 sudo pacman -Rsn \u0026lt;target\u0026gt; 如何修复 Discover 虽然我已经卸载 Discover 了，但是还是需要记录一下我是如何修复 Discover 的\n\u0026ldquo;感谢 Reddit 再次帮我排忧解难\u0026rdquo;\n1 2 # 只需要一步 sudo pacman -S packagekit-qt5 ","permalink":"https://hcy-asleep.github.io/Arch-KDE-%E6%8A%98%E8%85%BE%E6%97%A5%E5%BF%97/","summary":"live cd 安装使用 WIFI 先用命令 ip link查看网络接口\n1 ip link 查看到我的机器的无线网络接口是wlan0(不同的机器可能名字不同)，这里 wlan0 为例\n默认是关闭的状态，需要先开启它，而开启它之前还需要先激活它(即取消禁用，我这台机器默认是blockeded，禁用的)\n1 2 rfkill unblock wifi # 取消禁用wifi设备 ip link set wlan0 up # 开启wlan0 输入iwctl进入交互式提示符（interactive prompt），配置并连接到互联网\n1 2 3 4 5 station wlan0 scan station wlan0 get-networks station wlan0 connect \u0026lt;network name\u0026gt; station wlan0 show exit　# 回到命令行 ping百度可以ping通，就说明已经连接上了互联网\n免密 sudo Arch Linux run sudo without passwd\n首先\n1 sudo visudo 然后编辑里面的内容\n1 myname ALL=(ALL) NOPASSWD: ALL 添加中科大源 添加中科大的Arch Linux源","title":"Arch KDE 折腾日志"},{"content":"在换到 KDE 之后，我还是怀念 Nautilus ，而非 Dolphin ，因此我决定继续在 KDE 上使用 Nautilus 。而设置 Nautilus 右键打开的 terminal 选项，指定这个打开的选项为我的默认终端 alacritty ，需要 Nautilus 拓展来做到\n\u0026ldquo;这个是拓展的 Github 地址\u0026rdquo;\n我使用的是 Arch ，从 aur 下载安装\n1 yay -S nautilus-open-any-terminal 重启 Nautilus\n1 nautilus -q 在命令行设置 alacrity 为指定终端\n1 gsettings set com.github.stunkymonkey.nautilus-open-any-terminal terminal alacritty ","permalink":"https://hcy-asleep.github.io/Nautilus-%E6%B7%BB%E5%8A%A0%E5%8F%B3%E9%94%AE%E6%89%93%E5%BC%80-terminal-%E9%80%89%E9%A1%B9/","summary":"在换到 KDE 之后，我还是怀念 Nautilus ，而非 Dolphin ，因此我决定继续在 KDE 上使用 Nautilus 。而设置 Nautilus 右键打开的 terminal 选项，指定这个打开的选项为我的默认终端 alacritty ，需要 Nautilus 拓展来做到\n\u0026ldquo;这个是拓展的 Github 地址\u0026rdquo;\n我使用的是 Arch ，从 aur 下载安装\n1 yay -S nautilus-open-any-terminal 重启 Nautilus\n1 nautilus -q 在命令行设置 alacrity 为指定终端\n1 gsettings set com.github.stunkymonkey.nautilus-open-any-terminal terminal alacritty ","title":"Nautilus 添加右键打开 terminal 选项"},{"content":"这个问题困扰了我好久，我已经尝试如下方案：\ngsettings mimefile gnome-control-center dconf 这些都没有用。。。\n直到我看见了 reddit 的一个讨论，问题解决了，我想使用的默认终端是 alacritty：\n1 cd /usr/bin \u0026amp;\u0026amp; sudo ln -s alacritty xterm 关于此问题的 reddit 传送门\n","permalink":"https://hcy-asleep.github.io/Gnome-%E4%B8%8B%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4-terminal/","summary":"这个问题困扰了我好久，我已经尝试如下方案：\ngsettings mimefile gnome-control-center dconf 这些都没有用。。。\n直到我看见了 reddit 的一个讨论，问题解决了，我想使用的默认终端是 alacritty：\n1 cd /usr/bin \u0026amp;\u0026amp; sudo ln -s alacritty xterm 关于此问题的 reddit 传送门","title":"Gnome 下设置默认 terminal"},{"content":"我使用的是 clash ，在端口 7890 监听\nHttp 协议\n1 2 3 # export http_proxy=http://proxyAddress:port export http_proxy=http://127.0.0.1:7890 export https_proxy=http://127.0.0.1:7890 TCP 协议(socket5, ss, ssr)\n1 2 export http_proxy=\u0026#34;socks5://127.0.0.1:7890\u0026#34; export https_proxy=\u0026#34;socks5://127.0.0.1:7890\u0026#34; 或者干脆设置所有的代理\n1 export ALL_PROXY=socks5://127.0.0.1:7890 取消代理 ALL_PROXY ，其他同理\n1 unset ALL_PROXY ","permalink":"https://hcy-asleep.github.io/Shell-%E8%B5%B0%E4%BB%A3%E7%90%86/","summary":"我使用的是 clash ，在端口 7890 监听\nHttp 协议\n1 2 3 # export http_proxy=http://proxyAddress:port export http_proxy=http://127.0.0.1:7890 export https_proxy=http://127.0.0.1:7890 TCP 协议(socket5, ss, ssr)\n1 2 export http_proxy=\u0026#34;socks5://127.0.0.1:7890\u0026#34; export https_proxy=\u0026#34;socks5://127.0.0.1:7890\u0026#34; 或者干脆设置所有的代理\n1 export ALL_PROXY=socks5://127.0.0.1:7890 取消代理 ALL_PROXY ，其他同理\n1 unset ALL_PROXY ","title":"Shell 走代理"},{"content":"非常简单况且比我写的 CSS 好很多，我的那个 CSS 在 firefox 显示不正常，之前我找不到是因为我的搜索词语不对，我之前搜索使用的是 photo album ，而 Next 使用的相册关键词是 group pictures！\n1 2 {% grouppicture [your_picture_number]-[layout] %} {% endgrouppicture %} layout 的取值范围为 2～10\n1 2 3 4 5 {% grouppicture 3-3 %} ![\u0026#34;your_picture_description\u0026#34;](/images/next.svg) ![\u0026#34;your_picture_description\u0026#34;](/images/next.svg) ![\u0026#34;your_picture_description\u0026#34;](/images/next.svg) {% endgrouppicture %} 更加详细的效果参考 这里\n","permalink":"https://hcy-asleep.github.io/Hexo-Next-%E5%8E%9F%E7%94%9F%E7%9B%B8%E5%86%8C%E6%94%AF%E6%8C%81/","summary":"非常简单况且比我写的 CSS 好很多，我的那个 CSS 在 firefox 显示不正常，之前我找不到是因为我的搜索词语不对，我之前搜索使用的是 photo album ，而 Next 使用的相册关键词是 group pictures！\n1 2 {% grouppicture [your_picture_number]-[layout] %} {% endgrouppicture %} layout 的取值范围为 2～10\n1 2 3 4 5 {% grouppicture 3-3 %} ![\u0026#34;your_picture_description\u0026#34;](/images/next.svg) ![\u0026#34;your_picture_description\u0026#34;](/images/next.svg) ![\u0026#34;your_picture_description\u0026#34;](/images/next.svg) {% endgrouppicture %} 更加详细的效果参考 这里","title":"Hexo Next 原生相册支持"},{"content":" Mon Wed Thur 1-2 计⽹ L1-403 OS L1-503 3-4 计网 323 论题 L1-406 OS 240 7-10 实训 326 13-14 马原 L1-605 ","permalink":"https://hcy-asleep.github.io/%E5%A4%A7%E4%B8%89%E4%B8%8B%E8%AF%BE%E8%A1%A8/","summary":" Mon Wed Thur 1-2 计⽹ L1-403 OS L1-503 3-4 计网 323 论题 L1-406 OS 240 7-10 实训 326 13-14 马原 L1-605 ","title":"大三下课表"},{"content":" 直接上我的 markdown 源码就好了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;style\u0026gt; .blog_photo_album_grid { -webkit-column-count: 3; -webkit-column-gap: 10px; -webkit-column-fill: auto; -moz-column-count: 3; -moz-column-gap: 10px; -moz-column-fill: auto; column-count: 3; column-gap: 10px; column-fill: auto; } .blog_photo_album_block { background-color: none; display: block; padding: 10px; word-wrap: break-word; margin-bottom: 10px; -webkit-column-break-inside: avoid; -moz-column-break-inside: avoid; column-break-inside: avoid; border-style: solid; border-width: 1px; border-radius: 5px; border-color: #f0f0f0; box-shadow: 3px 3px 3px #f0f0f0; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;blog_photo_album_grid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;blog_photo_album_block\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;/pictures/photo_album/eat/doge.svg\u0026#34;\u0026gt;\u0026lt;h5 align=\u0026#34;center\u0026#34;\u0026gt;Hey, bro?\u0026lt;/h5\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;blog_photo_album_block\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;/pictures/photo_album/eat/brine_duck.jpg\u0026#34;\u0026gt;\u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt;教工餐厅卤鸭\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;blog_photo_album_block\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;/pictures/photo_album/eat/hall_chick_8.jpg\u0026#34;\u0026gt;\u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt;咖喱鸡扒饭\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;blog_photo_album_block\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;/pictures/photo_album/eat/gongcha_pancake.jpg\u0026#34;\u0026gt;\u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt;贡茶手抓饼\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;blog_photo_album_block\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;/pictures/photo_album/eat/griddle_braised_rice.jpg\u0026#34;\u0026gt;\u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt;烤盘饭\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;blog_photo_album_block\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;/pictures/photo_album/eat/lanzhou_beef_noodles.jpg\u0026#34;\u0026gt;\u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt;兰州牛肉面\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;blog_photo_album_block\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;/pictures/photo_album/eat/gongcha_pancake_1.jpg\u0026#34;\u0026gt;\u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt;贡茶手抓饼+1\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;blog_photo_album_block\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;/pictures/photo_album/eat/hall_duck_8.jpg\u0026#34;\u0026gt;\u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt;黑椒鸭扒饭\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;blog_photo_album_block\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;/pictures/photo_album/eat/eggtar.jpg\u0026#34;\u0026gt;\u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt;亲手做的蛋挞\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;blog_photo_album_block\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;/pictures/photo_album/eat/eggtar_1.jpg\u0026#34;\u0026gt;\u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt;亲手做的蛋挞+1\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;blog_photo_album_block\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;/pictures/photo_album/eat/chashao.jpg\u0026#34;\u0026gt;\u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt;旺角叉烧饭\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;blog_photo_album_block\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;/pictures/photo_album/eat/tea_cake.jpg\u0026#34;\u0026gt;\u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt;饭堂小吃\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 效果可以参考👇\n","permalink":"https://hcy-asleep.github.io/Markdown-HTML-%E7%A0%8C%E4%BD%93-%E7%80%91%E5%B8%83-%E5%B8%83%E5%B1%80/","summary":"直接上我的 markdown 源码就好了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;style\u0026gt; .blog_photo_album_grid { -webkit-column-count: 3; -webkit-column-gap: 10px; -webkit-column-fill: auto; -moz-column-count: 3; -moz-column-gap: 10px; -moz-column-fill: auto; column-count: 3; column-gap: 10px; column-fill: auto; } .blog_photo_album_block { background-color: none; display: block; padding: 10px; word-wrap: break-word; margin-bottom: 10px; -webkit-column-break-inside: avoid; -moz-column-break-inside: avoid; column-break-inside: avoid; border-style: solid; border-width: 1px; border-radius: 5px; border-color: #f0f0f0; box-shadow: 3px 3px 3px #f0f0f0; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;blog_photo_album_grid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;blog_photo_album_block\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;/pictures/photo_album/eat/doge.","title":"Markdown (HTML) 砌体 (瀑布) 布局"},{"content":" 修改主题配置文件\n开启 fancybox开关即可\n1 2 3 # FancyBox is a tool that offers a nice and elegant way to add zooming functionality for images. # For more information: https://fancyapps.com/fancybox fancybox: true ","permalink":"https://hcy-asleep.github.io/Hexo-next-%E5%BC%80%E5%90%AF-fancybox-%E6%9F%A5%E7%9C%8B%E5%9B%BE%E7%89%87%E5%A4%A7%E5%9B%BE/","summary":" 修改主题配置文件\n开启 fancybox开关即可\n1 2 3 # FancyBox is a tool that offers a nice and elegant way to add zooming functionality for images. # For more information: https://fancyapps.com/fancybox fancybox: true ","title":"Hexo next 开启 fancybox 查看图片大图"},{"content":" 「 不再犹豫 」 无聊望见了犹豫 达到理想不太易 即使有信心 斗志却抑止 谁人定我去或留 定我心中的宇宙 只想靠两手 向理想挥手 问句天几高 心中志比天更高 自信打不死的心态活到老 Wo oh 我有我心底故事 亲手写上每段得失乐与悲与梦儿 Wo oh 纵有创伤不退避 梦想有日达成 找到心底梦想的世界 终可见 ","permalink":"https://hcy-asleep.github.io/about/","summary":" 「 不再犹豫 」 无聊望见了犹豫 达到理想不太易 即使有信心 斗志却抑止 谁人定我去或留 定我心中的宇宙 只想靠两手 向理想挥手 问句天几高 心中志比天更高 自信打不死的心态活到老 Wo oh 我有我心底故事 亲手写上每段得失乐与悲与梦儿 Wo oh 纵有创伤不退避 梦想有日达成 找到心底梦想的世界 终可见 ","title":"About"},{"content":" 详情请参考官方网站\nGiscus 官方网站\n1 https://giscus.app/zh-CN Hexo-next-giscus 官方仓库\n1 https://github.com/next-theme/hexo-next-giscus 参考的博客，不保证链接长期有效\n1 https://getiot.tech/knowledge-base/hexo/hexo-comments 看域名，这个有可能在大陆被 ban 掉，科学上网\n1 https://ithelp.ithome.com.tw/articles/10306883 自己实践过的步骤\n准备工作\n你的仓库必须是公开的 (public)，否则访客将无法查看 discussion\n你的 GitHub 已安装 giscus app ，否则访客将无法评论和回应\n在你的仓库中启用 Discussions 功能\nHexo 配置\n在你的 Hexo 博客目录中执行以下命令，安装 hexo-next-giscus 插件\n1 npm install hexo-next-giscus --save 然后在 Hexo 或者 theme 的 _config.yml (我的是 _config.next.yml) 配置文件添加如下内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 giscus: enable: false repo: # Github repository name repo_id: # Github repository id category: # Github discussion category category_id: # Github discussion category id # Available values: pathname | url | title | og:title mapping: pathname # Available values: 0 | 1 reactions_enabled: 1 # Available values: 0 | 1 emit_metadata: 1 # Available values: light | dark | dark_high_contrast | transparent_dark | preferred-color-scheme theme: light # Available values: en | zh-CN lang: en # Place the comment box above the comments input_position: bottom # Load the comments lazily loading: lazy Giscus 配置\n在 https://giscus.app 页面根据你的个人喜好勾选 giscus 配置项，进行配置，会生成一个配置脚本\n在填仓库名字的时候要注意有没有空格（呜呜呜，因为这个搞了好久）\n配置脚本就是那一段 \u0026lt;script ... \u0026gt; ... \u0026lt;/script\u0026gt;\n参考该脚本内容修改 _config.yml 文件的 giscus 配置项\n部署\n1 2 hexo g hexo s 浏览器打开 http://localhost:4000，在文章末尾可以看到 giscus 评论区\n","permalink":"https://hcy-asleep.github.io/Hexo-Giscus-%E8%AF%84%E8%AE%BA-NexT-%E4%B8%BB%E9%A2%98/","summary":"详情请参考官方网站\nGiscus 官方网站\n1 https://giscus.app/zh-CN Hexo-next-giscus 官方仓库\n1 https://github.com/next-theme/hexo-next-giscus 参考的博客，不保证链接长期有效\n1 https://getiot.tech/knowledge-base/hexo/hexo-comments 看域名，这个有可能在大陆被 ban 掉，科学上网\n1 https://ithelp.ithome.com.tw/articles/10306883 自己实践过的步骤\n准备工作\n你的仓库必须是公开的 (public)，否则访客将无法查看 discussion\n你的 GitHub 已安装 giscus app ，否则访客将无法评论和回应\n在你的仓库中启用 Discussions 功能\nHexo 配置\n在你的 Hexo 博客目录中执行以下命令，安装 hexo-next-giscus 插件\n1 npm install hexo-next-giscus --save 然后在 Hexo 或者 theme 的 _config.yml (我的是 _config.next.yml) 配置文件添加如下内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 giscus: enable: false repo: # Github repository name repo_id: # Github repository id category: # Github discussion category category_id: # Github discussion category id # Available values: pathname | url | title | og:title mapping: pathname # Available values: 0 | 1 reactions_enabled: 1 # Available values: 0 | 1 emit_metadata: 1 # Available values: light | dark | dark_high_contrast | transparent_dark | preferred-color-scheme theme: light # Available values: en | zh-CN lang: en # Place the comment box above the comments input_position: bottom # Load the comments lazily loading: lazy Giscus 配置","title":"Hexo Giscus 评论 (NexT 主题)"},{"content":" 以下操作都是对管理本地的远端配置\n修改远程仓库地址\n1 git remote set-url origin \u0026lt;remote-url\u0026gt; 仓库路径查询查询\n1 git remote -v 添加远程仓库\n1 2 // 注:项目地址形式为:https://gitee.com/xxx/xxx.git或者 git@gitee.com:xxx/xxx.git git remote add origin \u0026lt;你的项目地址\u0026gt; 删除指定的远程仓库\n1 git remote rm origin ","permalink":"https://hcy-asleep.github.io/Git-%E4%BF%AE%E6%94%B9-/-%E6%B7%BB%E5%8A%A0-/-%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/","summary":" 以下操作都是对管理本地的远端配置\n修改远程仓库地址\n1 git remote set-url origin \u0026lt;remote-url\u0026gt; 仓库路径查询查询\n1 git remote -v 添加远程仓库\n1 2 // 注:项目地址形式为:https://gitee.com/xxx/xxx.git或者 git@gitee.com:xxx/xxx.git git remote add origin \u0026lt;你的项目地址\u0026gt; 删除指定的远程仓库\n1 git remote rm origin ","title":"Git 修改 / 添加 / 删除远程仓库"},{"content":" 1 2 3 4 5 6 # 删除包含特定字符的行，匹配删除 :% g/abc/d # 删除不包含特定字符的行 :% v/abc/d :% g!/abc/d ","permalink":"https://hcy-asleep.github.io/VIM-%E5%88%A0%E9%99%A4%E5%8C%85%E5%90%AB%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6%E7%9A%84%E8%A1%8C/","summary":" 1 2 3 4 5 6 # 删除包含特定字符的行，匹配删除 :% g/abc/d # 删除不包含特定字符的行 :% v/abc/d :% g!/abc/d ","title":"VIM 删除包含指定字符的行"},{"content":"给友链新增一个单独的页面\n命令创建页面\n1 hexo new page links 也可在博客根目录 /source 下手动创建 links 文件夹和里边的 index.md 文件\n然后在博客根目录 /source 下会生成一个 links 文件夹，打开其中的 index.md 文件，在头部写入 type = “links”，这个一定要写\n1 2 3 4 5 --- title: 友情链接 date: 2019-12-08 03:21:39 type: \u0026#34;links\u0026#34; --- 主题配置文件中menu下添加(我的是 NEXT 主题)\n1 Links: /links/ || fa fa-link 在 /themes/next/languages/zh-Hans.yml 文件中 menu 下增加中文描述(可选）\n1 links: 友链 像普通的 markdown 那样子编辑 index.md 就可以了\n","permalink":"https://hcy-asleep.github.io/Hexo-%E6%B7%BB%E5%8A%A0%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5/","summary":"给友链新增一个单独的页面\n命令创建页面\n1 hexo new page links 也可在博客根目录 /source 下手动创建 links 文件夹和里边的 index.md 文件\n然后在博客根目录 /source 下会生成一个 links 文件夹，打开其中的 index.md 文件，在头部写入 type = “links”，这个一定要写\n1 2 3 4 5 --- title: 友情链接 date: 2019-12-08 03:21:39 type: \u0026#34;links\u0026#34; --- 主题配置文件中menu下添加(我的是 NEXT 主题)\n1 Links: /links/ || fa fa-link 在 /themes/next/languages/zh-Hans.yml 文件中 menu 下增加中文描述(可选）\n1 links: 友链 像普通的 markdown 那样子编辑 index.md 就可以了","title":"Hexo 添加友情链接"},{"content":" 1 podman login -u \u0026#34;your_name\u0026#34; -p \u0026#34;your_password\u0026#34; docker.io ","permalink":"https://hcy-asleep.github.io/Podman-%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC/","summary":" 1 podman login -u \u0026#34;your_name\u0026#34; -p \u0026#34;your_password\u0026#34; docker.io ","title":"Podman 登录脚本"},{"content":" 在docker仓库中搜索mysql的镜像\n1 docker search mysql 下载镜像\n1 docker pull mysql 启动\n参数 -p 设置端口，\u0026ndash;name 取名 ，-e MYSQL_ROOT_PASSWORD=123456 设置 账号为 root ，密码为 123456 ，-d 表示作为一个守护进程在后台运行\n1 docker run -p 3306:3306 --name JY_mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql 宿主机连接docker中的mysql\n错误的连接方式\n1 2 3 4 5 $ mysql -u root -p Enter password: ERROR 2002 (HY000): Can\u0026#39;t connect to local MySQL server through socket \u0026#39;/var/run/mysqld/mysqld.sock\u0026#39; (2) # 可以看出这样会报错 正确的连接方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ mysql -h 127.0.0.1 -u root -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 9 Server version: 5.7.26 MySQL Community Server (GPL) Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type \u0026#39;help;\u0026#39; or \u0026#39;\\h\u0026#39; for help. Type \u0026#39;\\c\u0026#39; to clear the current input statement. mysql\u0026gt; 在docker容器中连接宿主机中的mysql\n查看宿主机和docker之间的桥接ip\n1 2 3 4 5 6 7 8 9 10 11 12 $ ifconfig docker0: flags=4163\u0026amp;lt;UP,BROADCAST,RUNNING,MULTICAST\u0026amp;gt; mtu 1500 inet 172.17.0.1 netmask 255.255.0.0 broadcast 172.17.255.255 inet6 fe80::42:8aff:febc:8533 prefixlen 64 scopeid 0x20\u0026amp;lt;link\u0026amp;gt; ether 02:42:8a:bc:85:33 txqueuelen 0 (以太网) RX packets 4779 bytes 11624681 (11.6 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 6006 bytes 441594 (441.5 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 # 宿主机在与容器同一局域网的IP地址一般是docker0对应的IP地址段的首个地址 即（172.17.0.1 ） 在容器中连接宿主机的mysql\n1 $ mysql -h 172.17.0.1 -u root -p ","permalink":"https://hcy-asleep.github.io/Docker-Podman-MySQL/","summary":"在docker仓库中搜索mysql的镜像\n1 docker search mysql 下载镜像\n1 docker pull mysql 启动\n参数 -p 设置端口，\u0026ndash;name 取名 ，-e MYSQL_ROOT_PASSWORD=123456 设置 账号为 root ，密码为 123456 ，-d 表示作为一个守护进程在后台运行\n1 docker run -p 3306:3306 --name JY_mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql 宿主机连接docker中的mysql\n错误的连接方式\n1 2 3 4 5 $ mysql -u root -p Enter password: ERROR 2002 (HY000): Can\u0026#39;t connect to local MySQL server through socket \u0026#39;/var/run/mysqld/mysqld.sock\u0026#39; (2) # 可以看出这样会报错 正确的连接方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ mysql -h 127.","title":"Docker (Podman) MySQL"},{"content":" 1 2 3 4 5 synmaxcol = 200 \u0026#34; 或者 syntax = off ","permalink":"https://hcy-asleep.github.io/VIM-%E9%95%BF%E8%A1%8Chan%E6%85%A2/","summary":" 1 2 3 4 5 synmaxcol = 200 \u0026#34; 或者 syntax = off ","title":"VIM 长行(han)慢"},{"content":" 修改镜像名称\n1 podman tag 拉取远程镜像\n1 podman pull 制作镜像\n1 podman commit 导出导入镜像\n保留镜像的层级信息，是一个 docker 的层级目录 tar 包\n1 2 3 4 # save docker save vell001/tf-keras \u0026gt; tf-keras.tar # load docker load \u0026lt; tf-keras.tar 不会保留镜像的层级信息，体积小，是一个直接的 linux 文件系统 tar 包\n1 2 docker export 33f6c8359187 \u0026gt; tf-keras-33f6c8359187.tar docker import tf-keras-33f6c8359187.tar ","permalink":"https://hcy-asleep.github.io/Podman-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","summary":" 修改镜像名称\n1 podman tag 拉取远程镜像\n1 podman pull 制作镜像\n1 podman commit 导出导入镜像\n保留镜像的层级信息，是一个 docker 的层级目录 tar 包\n1 2 3 4 # save docker save vell001/tf-keras \u0026gt; tf-keras.tar # load docker load \u0026lt; tf-keras.tar 不会保留镜像的层级信息，体积小，是一个直接的 linux 文件系统 tar 包\n1 2 docker export 33f6c8359187 \u0026gt; tf-keras-33f6c8359187.tar docker import tf-keras-33f6c8359187.tar ","title":"Podman 基本操作"},{"content":"用n升级nodejs\n1 2 3 4 5 6 7 8 9 npm install -g n # 全局安装n n stable # 升级到最新稳定版 n latest # 升级到最新版 n v7.10.0 # 升级到定制版 n 7.10.0 (ENTER) # 切换使用版本 ","permalink":"https://hcy-asleep.github.io/Nodejs-%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/","summary":"\u003cp\u003e用n升级nodejs\u003c/p\u003e","title":"Nodejs 升级版本"},{"content":"在 NexT 的主题配置文件里面启用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 codeblock: # Code Highlight theme # All available themes: https://theme-next.js.org/highlight/ theme: light: default dark: tomorrow-night prism: light: prism dark: prism-dark # Add copy button on codeblock copy_button: enable: true # Available values: default | flat | mac style: flat ","permalink":"https://hcy-asleep.github.io/Hexo-%E4%BB%A3%E7%A0%81%E5%9D%97%E9%85%8D%E7%BD%AE/","summary":"\u003cp\u003e在 NexT 的主题配置文件里面启用\u003c/p\u003e","title":"Hexo 代码块配置"},{"content":" 本文针对Next主题，不确保对于其它主题有效（但从修改模式来看，是有效的）\n修改配置\n首先需要在Next主题的_config.yml中把设置打开：(默认安装时就打开了)\n1 2 # Automatically excerpt description in homepage as preamble text. excerpt_description: true 方法一：写概述\n在文章的front-matter中添加description，其中description中的内容就会被显示在首页上，其余一律不显示\n1 2 3 4 5 --- title: 让首页显示部分内容 date: 2020-02-23 22:55:10 description: 这是显示在首页的概述，正文内容均会被隐藏。 --- 方法二：文章截断\n在需要截断的地方加入\n首页就会显示这条以上的所有内容，隐藏接下来的所有内容\n","permalink":"https://hcy-asleep.github.io/Hexo%E9%A6%96%E9%A1%B5%E5%8F%AA%E6%98%BE%E7%A4%BA%E9%83%A8%E5%88%86%E6%91%98%E8%A6%81/","summary":"本文针对Next主题，不确保对于其它主题有效（但从修改模式来看，是有效的）\n修改配置\n首先需要在Next主题的_config.yml中把设置打开：(默认安装时就打开了)\n1 2 # Automatically excerpt description in homepage as preamble text. excerpt_description: true 方法一：写概述\n在文章的front-matter中添加description，其中description中的内容就会被显示在首页上，其余一律不显示\n1 2 3 4 5 --- title: 让首页显示部分内容 date: 2020-02-23 22:55:10 description: 这是显示在首页的概述，正文内容均会被隐藏。 --- 方法二：文章截断\n在需要截断的地方加入\n首页就会显示这条以上的所有内容，隐藏接下来的所有内容","title":"Hexo首页只显示部分摘要"},{"content":" 从远端仓库获取最新代码合并到本地分支里 在日常开发中，很有可能几个终端都在开发同一个代码仓分支，导致本地分支里的代码“落后于”远端分支里的，我们需要做的就是从远端仓库获取最新代码合并到本地分支里。\ngit pull\n获取最新代码到本地，并自动合并到当前分支，前提是已经 \u0026ldquo;git init\u0026rdquo; 首先我们用命令行 去查询当前代码仓的远端分支 1 git remote -v 然后直接去拉取并合并最新的代码（因为是直接合并，无法提前处理冲突，不推荐） 即拉取远端origin/master分支并合并到当前分支 1 git pull origin master 即拉取远端origin/test分支并合并到当前分支 1 git pull origin test git fetch + merge （需要额外的本地分支）\n首先我们用命令行去查询当前代码仓的所有远端分支\n1 git remote -v 然后用命令行获取最新代码到本地临时分支（自定义为tempBranch），获取到的远端分支为origin/dev\n1 git fetch origin dev:tempBranch 用命令行去查看本地tempBranch分支和当前分支的版本差异\n1 git diff tempBranch 接着用命令行合并本地临时分支tempBranch到当前分支\n1 git merge tempBranch 最后用命令行来删除该临时分支\n1 git branch -D tempBranch 这种方式需要建立并删除这个额外的本地分支\ngit fetch + merge （不额外建立本地分支）\n首先我们用命令行去查询当前代码仓的所有远端分支 1 git remote -v 然后用命令行来获取远端的origin/dev分支的最新代码到本地（假设本地当前分支为dev） 1 git fetch origin dev 接着用命令行去查看本地dev分支和当前分支的版本差异 1 git log -p dev..origin/dev 最后用命令行来合并远端分支origin/dev 到当前分支 1 git merge origin/dev 这种方式可以不用额外建立本地分支 git fetch + reset + pull\n放弃修改，强制覆盖本地代码\n1 2 3 git fetch --all git reset --hard origin/main # origin 是远端的意思 git pull git push\n强制提交本地分支覆盖远程分支\n1 2 # git push origin --force \u0026lt;branch_name\u0026gt; git push --force origin main ","permalink":"https://hcy-asleep.github.io/Git-Multi-End-Sync/","summary":"从远端仓库获取最新代码合并到本地分支里 在日常开发中，很有可能几个终端都在开发同一个代码仓分支，导致本地分支里的代码“落后于”远端分支里的，我们需要做的就是从远端仓库获取最新代码合并到本地分支里。\ngit pull\n获取最新代码到本地，并自动合并到当前分支，前提是已经 \u0026ldquo;git init\u0026rdquo; 首先我们用命令行 去查询当前代码仓的远端分支 1 git remote -v 然后直接去拉取并合并最新的代码（因为是直接合并，无法提前处理冲突，不推荐） 即拉取远端origin/master分支并合并到当前分支 1 git pull origin master 即拉取远端origin/test分支并合并到当前分支 1 git pull origin test git fetch + merge （需要额外的本地分支）\n首先我们用命令行去查询当前代码仓的所有远端分支\n1 git remote -v 然后用命令行获取最新代码到本地临时分支（自定义为tempBranch），获取到的远端分支为origin/dev\n1 git fetch origin dev:tempBranch 用命令行去查看本地tempBranch分支和当前分支的版本差异\n1 git diff tempBranch 接着用命令行合并本地临时分支tempBranch到当前分支\n1 git merge tempBranch 最后用命令行来删除该临时分支\n1 git branch -D tempBranch 这种方式需要建立并删除这个额外的本地分支\ngit fetch + merge （不额外建立本地分支）\n首先我们用命令行去查询当前代码仓的所有远端分支 1 git remote -v 然后用命令行来获取远端的origin/dev分支的最新代码到本地（假设本地当前分支为dev） 1 git fetch origin dev 接着用命令行去查看本地dev分支和当前分支的版本差异 1 git log -p dev.","title":"Git Multi End Sync"},{"content":" 输入\n1 git config --global credential.helper store 查看配置\n1 git config --list 如果有下面的行，说明配置成功了\n1 credential.helper=store 后面操作的时候只需要输入一次密码之后，就可以免密码操作了，在家目录下会有一个 \u0026ldquo;.git-credentials\u0026rdquo; 文件生成\n","permalink":"https://hcy-asleep.github.io/Git-no-passwd-login/","summary":"输入\n1 git config --global credential.helper store 查看配置\n1 git config --list 如果有下面的行，说明配置成功了\n1 credential.helper=store 后面操作的时候只需要输入一次密码之后，就可以免密码操作了，在家目录下会有一个 \u0026ldquo;.git-credentials\u0026rdquo; 文件生成","title":"Git no passwd login"},{"content":" 把图标放在 hexo\\source\\images 目录下，这个目录没有可以自己手动创建\n修改 next主题配置文件，\\next\\themes\\next_config.yml 文件\n1 2 3 4 5 6 7 8 favicon: small: /images/favicon-16x16-next.png #medium: /images/favicon-32x32-next.png medium: /images/favicon.ico apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml ","permalink":"https://hcy-asleep.github.io/Hexo-next-favicon/","summary":" 把图标放在 hexo\\source\\images 目录下，这个目录没有可以自己手动创建\n修改 next主题配置文件，\\next\\themes\\next_config.yml 文件\n1 2 3 4 5 6 7 8 favicon: small: /images/favicon-16x16-next.png #medium: /images/favicon-32x32-next.png medium: /images/favicon.ico apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml ","title":"Hexo next favicon"},{"content":" \u0026ldquo;hexo s\u0026rdquo; 在本地运行预览的端口是 4000\n1 podman run -it --name=hexoenv -p 4000:4000 -v /home/hcy/Gateway/hexo_blogs:/home/devenv/hexo/source hexoenv /bin/bash 只需要把 source 文件夹暴露出来给 host 就行了\n为了多端同步，推送不用 \u0026ldquo;hexo d\u0026rdquo; ， 而是手动将 public 下的内容推到 github.io 那里\n","permalink":"https://hcy-asleep.github.io/Podman-hexo/","summary":"\u0026ldquo;hexo s\u0026rdquo; 在本地运行预览的端口是 4000\n1 podman run -it --name=hexoenv -p 4000:4000 -v /home/hcy/Gateway/hexo_blogs:/home/devenv/hexo/source hexoenv /bin/bash 只需要把 source 文件夹暴露出来给 host 就行了\n为了多端同步，推送不用 \u0026ldquo;hexo d\u0026rdquo; ， 而是手动将 public 下的内容推到 github.io 那里","title":"Podman hexo"},{"content":" 首先打开终端（我的容器使用 Linux 主机下的 podman cli 终端操作） 允许容器访问 xhost，在终端里面输入\n1 xhost + run 容器即可\n1 podman run -it --net=host -e DISPLAY=$DISPLAY --name=devenv -v /home/hcy/Gateway/:/home/devenv/Gateway devenv /bin/bash 参数解释：\n1 ... -it ... /bin/bash // 进入交互模式 1 ... --net=host ... // 允许访问 host 网络 1 ... -e DISPLAY=$DISPLAY ... // 使用 host 的显示 1 ... --name=devenv ... // 指定启动之后容器的名字 1 2 3 ... -v /home/hcy/Gateway/:/home/devenv/Gateway ... // 将 host 的 /home/hcy/Gateway/ 映射到 container 的 /home/devenv/Gateway 1 ... devenv ... // 镜像名字 ","permalink":"https://hcy-asleep.github.io/Podman-GUI-Wayland/X11/","summary":"首先打开终端（我的容器使用 Linux 主机下的 podman cli 终端操作） 允许容器访问 xhost，在终端里面输入\n1 xhost + run 容器即可\n1 podman run -it --net=host -e DISPLAY=$DISPLAY --name=devenv -v /home/hcy/Gateway/:/home/devenv/Gateway devenv /bin/bash 参数解释：\n1 ... -it ... /bin/bash // 进入交互模式 1 ... --net=host ... // 允许访问 host 网络 1 ... -e DISPLAY=$DISPLAY ... // 使用 host 的显示 1 ... --name=devenv ... // 指定启动之后容器的名字 1 2 3 ... -v /home/hcy/Gateway/:/home/devenv/Gateway ... // 将 host 的 /home/hcy/Gateway/ 映射到 container 的 /home/devenv/Gateway 1 .","title":"Podman GUI Wayland/X11"},{"content":" 燊 : 无所谓，我会出手 (doge 瀚 : 熱烈に歓迎する！ Viking : 玩转Pytorch 👌 Sunflower : 🌻 曹老板 : 身陷计算机，心系诗远方 W : 上号吗？ Kincih : 年薪二十万还不如考研 Puppy Jack : ⚽🚀 ","permalink":"https://hcy-asleep.github.io/friends/","summary":" 燊 : 无所谓，我会出手 (doge 瀚 : 熱烈に歓迎する！ Viking : 玩转Pytorch 👌 Sunflower : 🌻 曹老板 : 身陷计算机，心系诗远方 W : 上号吗？ Kincih : 年薪二十万还不如考研 Puppy Jack : ⚽🚀 ","title":"Friends"},{"content":" Markdown 编写的 Hexo 博客文章内部跳转，比如说想在文章1中的某个段落内部超链接跳转到文章2\n1 {% post_link 文章文件名(不要后缀) 文章标题(可选) %} 如文章文件名为 Hello-World.md\n1 2 {% post_link Hello-World %} {% post_link Hello-World 你好世界 %} 如果想做到这样子的效果\n1 2 3 4 5 6 7 8 9 10 \u0026lt;br/\u0026gt; \u0026lt;h3 style=\u0026#34;display:flex\u0026#34;\u0026gt; \u0026lt;span align=\u0026#34;left\u0026#34; style=\u0026#34;width:50%\u0026#34;\u0026gt; PRE : {% post_link 初识-MARO 初识 MARO %} \u0026lt;/span\u0026gt; \u0026lt;span align=\u0026#34;right\u0026#34; style=\u0026#34;width:50%\u0026#34;\u0026gt; NEXT : {% post_link MARO-VM-调度 MARO VM 调度%} \u0026lt;/span\u0026gt; \u0026lt;/h3\u0026gt; 单纯的右边\n1 2 3 4 5 6 \u0026lt;br/\u0026gt; \u0026lt;h3\u0026gt; \u0026lt;div align=\u0026#34;right\u0026#34; \u0026gt; NEXT : {% post_link MARO-Distibuted-toolkit MARO Distibuted toolkit %} \u0026lt;/div\u0026gt; \u0026lt;/h3\u0026gt; ","permalink":"https://hcy-asleep.github.io/Hexo-Inner-Link/","summary":" Markdown 编写的 Hexo 博客文章内部跳转，比如说想在文章1中的某个段落内部超链接跳转到文章2\n1 {% post_link 文章文件名(不要后缀) 文章标题(可选) %} 如文章文件名为 Hello-World.md\n1 2 {% post_link Hello-World %} {% post_link Hello-World 你好世界 %} 如果想做到这样子的效果\n1 2 3 4 5 6 7 8 9 10 \u0026lt;br/\u0026gt; \u0026lt;h3 style=\u0026#34;display:flex\u0026#34;\u0026gt; \u0026lt;span align=\u0026#34;left\u0026#34; style=\u0026#34;width:50%\u0026#34;\u0026gt; PRE : {% post_link 初识-MARO 初识 MARO %} \u0026lt;/span\u0026gt; \u0026lt;span align=\u0026#34;right\u0026#34; style=\u0026#34;width:50%\u0026#34;\u0026gt; NEXT : {% post_link MARO-VM-调度 MARO VM 调度%} \u0026lt;/span\u0026gt; \u0026lt;/h3\u0026gt; 单纯的右边\n1 2 3 4 5 6 \u0026lt;br/\u0026gt; \u0026lt;h3\u0026gt; \u0026lt;div align=\u0026#34;right\u0026#34; \u0026gt; NEXT : {% post_link MARO-Distibuted-toolkit MARO Distibuted toolkit %} \u0026lt;/div\u0026gt; \u0026lt;/h3\u0026gt; ","title":"Hexo Inner Link"},{"content":" 将文件从 Linux Host 传到 KVM Windows Guest\n在 Windows Guest 里面下载安装如下地址的软件\n1 https://www.spice-space.org/download/windows/spice-guest-tools/spice-guest-tools-latest.exe 重启 Windows Guest\n发现可以把 Linux 文件拖拽到 Windwos 里面，可是无法反向拖拽\n将文件从 KVM Windows Guest 传到 Linux Host\n在 Windows Guest 里面设置共享文件夹\n新建文件夹（此处在 C盘 根目录下） 设置文件夹共享\n右键 -\u0026gt; 属性 -\u0026gt; 共享\n选择 Everyone -\u0026gt; 添加\n选择权限\nShare\n留意这里，图片里面的 \u0026ldquo;DESKTOP-5J93LDB\u0026rdquo; 在 Linux mount 操作时将会被换为 Windows 的 IP 地址\n点击 Done 完成共享设置 设置外部可以访问 Windows\n回到 Share 的 share 属性页面\n点击 Network and Sharing Center\n改变设置如下\n保存设置完成 Windows 端配置 Linux Host 挂载\n在 Linux Host 下将 Windows Guset 的共享目录挂载到 Linux Host 的某个文件夹下面，然后 cd 到这个文件夹下面就可以访问 share 目录了\n1 sudo mount -t cifs //192.168.122.8/share /home/asleep/share/ \u0026ldquo;-t cifs\u0026rdquo; 指定要挂载外部文件系统 查看 Linux Host 下的文件目录内容，发现已经可以访问到 Windows Guset 的共享目录\n要卸载共享，也就是取消挂载，执行如下命令\n1 sudo umount -t cifs //192.168.122.8/share ","permalink":"https://hcy-asleep.github.io/Linux-Host-%E4%B8%8E-KVM-Windows-Guest-%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6/","summary":"将文件从 Linux Host 传到 KVM Windows Guest\n在 Windows Guest 里面下载安装如下地址的软件\n1 https://www.spice-space.org/download/windows/spice-guest-tools/spice-guest-tools-latest.exe 重启 Windows Guest\n发现可以把 Linux 文件拖拽到 Windwos 里面，可是无法反向拖拽\n将文件从 KVM Windows Guest 传到 Linux Host\n在 Windows Guest 里面设置共享文件夹\n新建文件夹（此处在 C盘 根目录下） 设置文件夹共享\n右键 -\u0026gt; 属性 -\u0026gt; 共享\n选择 Everyone -\u0026gt; 添加\n选择权限\nShare\n留意这里，图片里面的 \u0026ldquo;DESKTOP-5J93LDB\u0026rdquo; 在 Linux mount 操作时将会被换为 Windows 的 IP 地址\n点击 Done 完成共享设置 设置外部可以访问 Windows\n回到 Share 的 share 属性页面\n点击 Network and Sharing Center","title":"Linux Host 与 KVM Windows Guest 共享文件"},{"content":" Coc-pright 是静态语法分析器，而 python 有一些包是没有经过预编译的，比如说 opencv ，所以就会有找不到相关包的语法分析的情况发生\n首先\n1 pip install mypy 生成 cv2 的 pyi 文件\n1 stubgen -m cv2 -o {cv2-package-folder} 在我的环境下 {cv2-package-folder} 是\n1 /home/asleep/softwares/conda/conda/envs/ocv/lib/python3.9/site-packages/cv2 执行命令之后会在目录下生成 cv2.pyi 文件\n将 cv2.pyi 移动到 coc-pyright 的解析目录，成功解析\n1 cp /home/asleep/softwares/conda/conda/envs/ocv/lib/python3.9/site-packages/cv2/cv2.pyi /home/asleep/.config/coc/extensions/node_modules/coc-pyright/node_modules/pyright/dist/typeshed-fallback/stdlib ","permalink":"https://hcy-asleep.github.io/Coc-pyright-%E6%89%BE%E4%B8%8D%E5%88%B0%E7%9B%B8%E5%85%B3%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/","summary":" Coc-pright 是静态语法分析器，而 python 有一些包是没有经过预编译的，比如说 opencv ，所以就会有找不到相关包的语法分析的情况发生\n首先\n1 pip install mypy 生成 cv2 的 pyi 文件\n1 stubgen -m cv2 -o {cv2-package-folder} 在我的环境下 {cv2-package-folder} 是\n1 /home/asleep/softwares/conda/conda/envs/ocv/lib/python3.9/site-packages/cv2 执行命令之后会在目录下生成 cv2.pyi 文件\n将 cv2.pyi 移动到 coc-pyright 的解析目录，成功解析\n1 cp /home/asleep/softwares/conda/conda/envs/ocv/lib/python3.9/site-packages/cv2/cv2.pyi /home/asleep/.config/coc/extensions/node_modules/coc-pyright/node_modules/pyright/dist/typeshed-fallback/stdlib ","title":"Coc-pyright 找不到相关的语法分析"},{"content":"注意：以下操作都属于高危行为，请谨慎使用!\n在插入 U盘 之前，先查看有哪些磁盘\n可以看到加粗的有两行，第一行开头是 \u0026ldquo;Disk\u0026rdquo; ，第二行开头是 \u0026ldquo;Device\u0026rdquo; 整个输出只有一行加粗的 \u0026ldquo;Disk\u0026rdquo; ，表示目前只有一个硬盘 每一个加粗的 \u0026ldquo;Device\u0026rdquo; 都对应上一行的 \u0026ldquo;Disk\u0026rdquo; \u0026ldquo;Device\u0026rdquo; 里面的内容表示 \u0026ldquo;Disk\u0026rdquo; 里面的分区 在插入 U盘 之后，再查看有哪些磁盘\n发现多了一行加粗的 \u0026ldquo;Disk\u0026rdquo; 这个正是我们插入的 U盘 卸载 U盘\n1 umount /dev/sda /dev/后面的设备要根据你的实际情况而定，否则后面格式化，丢失数据！！ 格式化 U盘 ，并且建立 vfat 文件系统\n1 mkfs.vfat -I /dev/sda /dev/后面的设备要根据你的实际情况而定，否则后面格式化，丢失数据！！ 最后再 mount 上 U盘 ，或者把 U盘 拨了再插上，系统可能会自动 mount 上, 就可以使用 U盘 了\n异常处理\n假设 U盘 信息如下\n1 2 3 4 5 6 7 8 9 10 Disk /dev/sdb：7.5 GiB，8004304896 bytes，15633408 sectors Units：sectors of / 1 * 512 = 512 bytes Sector size(logical/physical)：512 bytes / 512 bytes I/O size(mininum/optimal)：512 bytes / 512 bytes Disklabel type：dos Disk identifier：0x663eb4c4 Device boot Start End Sectors Size Id Type /dev/sdb1 * 0 3815135 3815136 1.8G 0 Empty /dev/sdb2 3737268 3741939 4672 2.3M ef EFI (FAT-12/16/32) 如果 mkfs.vfat /dev/sdb 出现如下错误\n1 2 mkfs.vfat 3.0.10 (12 Sep 2010) mkfs.vfat: unable to open /dev/sdb 则需要先格式化 /dev/sdb1 ，即使用 mkfs.vfat /dev/sdb1 命令，将 /dev/sdb1 先格式化掉，然后再格式化 /dev/sdb\n如果出现如下错误\n1 2 mkfs.vfat 3.0.10 (12 Sep 2010) mkfs.vfat: Device partition expected, not making filesystem on entire device \u0026#39;/dev/sdb\u0026#39; (use -I to override) 系统提示需要使用 -I 参数来完成格式化：mkfs.vfat -I /dev/sdb, 这样就可以完全格式化的U盘\n","permalink":"https://hcy-asleep.github.io/Linux-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%A3%81%E7%9B%98U%E7%9B%98/","summary":"注意：以下操作都属于高危行为，请谨慎使用!\n在插入 U盘 之前，先查看有哪些磁盘\n可以看到加粗的有两行，第一行开头是 \u0026ldquo;Disk\u0026rdquo; ，第二行开头是 \u0026ldquo;Device\u0026rdquo; 整个输出只有一行加粗的 \u0026ldquo;Disk\u0026rdquo; ，表示目前只有一个硬盘 每一个加粗的 \u0026ldquo;Device\u0026rdquo; 都对应上一行的 \u0026ldquo;Disk\u0026rdquo; \u0026ldquo;Device\u0026rdquo; 里面的内容表示 \u0026ldquo;Disk\u0026rdquo; 里面的分区 在插入 U盘 之后，再查看有哪些磁盘\n发现多了一行加粗的 \u0026ldquo;Disk\u0026rdquo; 这个正是我们插入的 U盘 卸载 U盘\n1 umount /dev/sda /dev/后面的设备要根据你的实际情况而定，否则后面格式化，丢失数据！！ 格式化 U盘 ，并且建立 vfat 文件系统\n1 mkfs.vfat -I /dev/sda /dev/后面的设备要根据你的实际情况而定，否则后面格式化，丢失数据！！ 最后再 mount 上 U盘 ，或者把 U盘 拨了再插上，系统可能会自动 mount 上, 就可以使用 U盘 了\n异常处理\n假设 U盘 信息如下\n1 2 3 4 5 6 7 8 9 10 Disk /dev/sdb：7.5 GiB，8004304896 bytes，15633408 sectors Units：sectors of / 1 * 512 = 512 bytes Sector size(logical/physical)：512 bytes / 512 bytes I/O size(mininum/optimal)：512 bytes / 512 bytes Disklabel type：dos Disk identifier：0x663eb4c4 Device boot Start End Sectors Size Id Type /dev/sdb1 * 0 3815135 3815136 1.","title":"Linux 命令行格式化磁盘（U盘)"},{"content":"VIM(NEOVIM) 比较不同\n1 vim -d file_1 file_2 ","permalink":"https://hcy-asleep.github.io/Vim-Diff/","summary":"VIM(NEOVIM) 比较不同\n1 vim -d file_1 file_2 ","title":"Vim Diff"},{"content":" 今天要不来聊聊Redis吧？ 好 我个人是这样理解的：无论Redis也好、MySQL也好、HDFS也好、HBase也好，他们都是存储数据的地方 因为它们的设计理念的不同，我们会根据不同的应用场景使用不同的存储 像Redis一般我们会把它用作于缓存 当然啦，日常有的应用场景比较简单，用个HashMap也能解决很多的问题了，没必要上Redis 这就好比，有的单机限流可能应对某些场景就够用了，也没必要说一定要上分布式限流把系统搞得复杂 你在项目里有用到Redis吗？怎么用的？ Redis肯定是用到的，我负责的项目几乎都会有Redis的踪影 举几个项目用的案例？ 嗯 我这边负责消息管理平台，简单来说就是发消息的 那发完消息肯定我们是得知道消息有没有下发成功的，是吧？ 于是我们系统有一套完整的链路追踪体系 其中实时的数据我们就用Redis来进行存储，有实时肯定就会有离线的嘛（离线的数据我们是存储到Hive的） 对消息进行实时链路追踪，我这边就用了Redis好几种的数据结构 分别有Set、List和Hash 嗯…. 我再稍微铺垫下链路追踪的背景吧 要在消息管理平台发消息，首先得在后台新建一个「模板」，有模板自然会有一个模板ID 对模板ID进行扩展，比如说加上日期和固定的业务参数，形成的ID可以唯一标识某个模板的下发链路 在系统上，我这边叫它为UMPID 在发送入口处会对所有需要下发的消息打上UMPID，然后在关键链路上打上对应的点位 嗯，你继续吧 接下来的工作就是清洗出统一的模型，然后根据不同维度进行处理啦。比如说： 我要看某一天下发的所有模板有哪些，那只要我把清洗出来后数据的，将对应UMPID扔到了Set就好了 我要看某一个模板的消息下发的整体链路情况，那我以UMPID为Key，Value是Hash结构，Key是state，Value则是人数 这里的state我们在下发的过程中打的关键点位，比如接收到消息打个51，消息被去重了打个61，消息成功下发了打个81… 以UMPID为Key，Hash结构的Key（State）进行不断的累加，就可以实现某一个模板的消息下发的整体链路情况 我要看某个用户当天下发的消息有哪些，以及这些消息的整体链路是如何 这边我用的是List结构，Key是userId，Value则是UMPID+state(关键点位)+processTime（处理时间) 嗯…. 简单来说，就是通过Redis丰富的数据结构来实现对下发消息多个维度的统计 不同的应用场景选择不同的数据结构，再等到透出做处理的时候，就变得十分简单了 消息下发过程中去重或者一般正常的场景就直接Key-Value就能符合需求了 像bitmap、hyperloglogs、sortset、steam等等这些数据结构在我所负责的项目用得是真不多 要是我有机会去到贵公司，贵公司有相关的应用场景，我相信我也很快就能掌握 这些数据结构底层都由对应的object来支撑着，object记录对应的「编码」 其实就是会根据key-value存储的数量或者长度来使用选择不同的底层数据结构实现 比如说：ziplist压缩列表这个底层数据结构有可能上层的实现是list、hash和sortset Hash结构的底层数据结构可能是hash和ziplist 在节省内存和性能的考量之中切换 Redis还是有点屌的啊 就你上面那个实时链路场景，可以用其他的存储替代吗？ 嗯，理论上是可以的（或许可以尝试用HBase），但总体来说没这么好吧 因为Redis拥有丰富的数据结构，在透出的时候，处理会非常的方便 如果不用Redis的话，还得做很多解析的工作 并且，我那场景的并发还是相当大的（就一条消息发送，可能就产生10条记录） 监控峰值命令处理数会去到20k+QPS，当然了，这场景我肯定用了Pipeline的（不然处理会慢很多） 综合上面并发量和实时性以及数据结构，用Redis是一个比较好的选择 嗯….你觉得为什么Redis可以这么快？ 首先，它是纯内存操作，内存本身就很快 其次，它是单线程的，Redis服务器核心是基于非阻塞的IO多路复用机制，单线程避免了多线程的频繁上下文切换问题 至于这个单线程，其实官网也有过说明（：表示使用Redis往往的瓶颈在于内与和网络，而不在于CPU 了解 ","permalink":"https://hcy-asleep.github.io/Redis-%E5%9F%BA%E7%A1%80-%E9%97%B2%E8%81%8A/","summary":"\u003cdiv align=\"left\"\u003e\u003cdiv style=\"width: 60%; border-style: solid; border-width: 1px; border-radius: 16px; position: relative; padding:30px; text-align:center\"\u003e\n今天要不来聊聊Redis吧？\n\u003c/div\u003e\u003c/div\u003e\u003cbr/\u003e","title":"Redis-基础-闲聊"},{"content":" 面试官你好，请问面试可以开始了吗 嗯，开始吧 今天来聊聊TCP吧，TCP的各个状态还有印象吗？ 还有些许印象的，要不我就来简单说下TCP的三次握手和四次挥手的流程吧 说完这两个流程，就能把TCP的状态给涵盖上了 可以 在说TCP的三次握手和四次挥手之前，我先给你画下TCP的头部格式呗（： 对于TCP三次握手和四次挥手，我们最主要的就是关注TCP头部的序列号、确认号以及几个标记位（SYN/FIN/ACK/RST） 序列号：在初次建立连接的时候，客户端和服务端都会为「本次的连接」随机初始化一个序列号。（纵观整个TCP流程中，序列号可以用来解决网络包乱序的问题） 确认号：该字段表示「接收端」告诉「发送端」对上一个数据包已经成功接收（确认号可以⽤来解决网络包丢失的问题） 而标记位就很好理解啦。SYN为1时，表示希望创建连接。ACK为1时，确认号字段有效。FIN为1时，表示希望断开连接。RST为1时，表示TCP连接出现异常，需要断开 下面就先从三次握手开始吧，期间我也会在三次握手中涉及到的TCP状态也说下的 TCP三次握手的过程其实就是在：确认通信双方（客户端和服务端）的序列号 它的过程是这样的 在最开始的时候，客户端和服务端都处于 CLOSE 状态 服务器主动监听某个端口，处于 LISTEN 状态 客户端会随机生成出序列号（这里的序列号一般叫做client_isn），并且把标志位设置为SYN（意味着要连接），然后把该报文发送给服务端 客户端发送完SYN报文以后，自己便进入了 SYN_SEND 状态 服务端接收到了客户端的请求之后，自己也初始化对应的序列号（这里的序列号一般叫做 server_isn） 在「确认号」字段里填上client_isn + 1（相当于告诉客户端，已经收到了发送过来的序列号了） ，并且把 SYN 和 ACK 标记位都点亮(置为1) 把该报文发送客户端，服务端的状态变成 SYN-REVD 状态 客户端收到服务端发送的报文后，就知道服务端已经接收到了自己的序列号（通过确认号就可以知道），并且接收到了服务端的序列号(server_isn) 此时，客户端需要告诉服务端自己已经接收到了他发送过来的序列号，所以在「确认号」字段上填上server_isn+1，，并且标记位 ACK 为1 客户端在发送报文之后，进入 ESTABLISHED 状态，而服务端接收到客户端的报文之后，也进入 ESTABLISHED 状态 这就是三次握手的过程以及涉及到的TCP状态 总结下来，就是双方都把自身的序列号发给对方，看对方能不能接收到。如果「确认可以」，那就可以正常通信。（三次握手这个过程就可以看到双方都有接收和发送的能力） 那两次握手行吗？ 两次握手只能保证客户端的序列号成功被服务端接收，而服务端是无法确认自己的序列号是否被客户端成功接收。所以是不行的（： 了解了，那我想问问序列号为什么是随机的？以及序列号是怎么生成的？ 一方面为了安全性（随机ISN能避免非同一网络的攻击），另一方面可以让通信双方能够根据序号将「不属于」本连接的报文段丢弃 序列号怎么生成的？这…随便猜下就应该跟「时钟」和TCP头部的某些属性做运算生成的吧，类似于雪花算法（：具体我忘了 既然网络是不可靠的，那建立连接不是会经过三次握手吗？那要是在中途丢了，怎么办？ 假设第一个包丢了，客户端发送给服务端的 SYN 包丢了（简而要之就是服务端没接收到客户端的SYN包） 客户端迟迟收不到服务端的ACK包，那会周期性超时重传，直到收到服务端的ACK 假设第二个包丢了，服务端发送的SYN+ACK包丢了（简而要之就是客户端没接收到服务端的SYN+ACK包） 服务端迟迟收不到客户端的ACK包，那会周期性超时重传，直到收到客户端的ACK 假设第三个包丢了（ACK包），客户端发送完第三个包后单方面进入了 ESTABLISHED 状态，而服务端也认为此时连接是正常的，但第三个包没到达服务端 一、如果此时客户端与服务端都还没数据发送，那服务端会认为自己发送的SYN+ACK的包没发送至客户端，所以会超时重传自己的SYN+ACK包 二、如果这时候客户端已经要发送数据了，服务端接收到了ACK + Data数据包，那自然就切换到 ESTABLISHED 状态下，并且接收客户端的Data数据包 三、如果此时服务端要发送数据了，但发送不了，会一直周期性超时重传SYN + ACK，直到接收到客户端的ACK包 嗯，是不是要讲下四次挥手了？ 嗯，在建立完连接之后，客户端和服务端双方都处于 ESTABLISHED 状态 断开连接双方都有权利的，下面我还是以客户端主动断开为例好啦 客户端打算关闭连接，会发 FIN 报文给服务端（其实就是把标志位 FIN 点亮），客户端发送完之后，就进入FIN_WAIT_1状态 服务端收到 FIN 报文之后，回复 ACK 报文给客户端（表示已经收到了），服务端发送完之后，就进入 CLOSE_WAIT 状态 客户端接收到服务端的 ACK 报文，就进入了 FIN_WAIT_2 状态 这时候，服务器可能还有数据要发送给客户端，等服务端确认自己已经没有数据返回给客户端之后，就发送FIN报文给客户端了，自己进入 LAST_ACK 状态 客户端收到服务端的FIN报文之后，回应ACK报文，自己进入 TIME_WAIT 状态 服务端收到客户端的ACK报文之后，服务端就进入 CLOSE 状态 客户端在TIME_WAIT等到2MSL，也进入了 CLOSE 状态 四次挥手的流程到这里就结束了，结合三次握手，TCP的各个状态也已经说完了 嗯嗯，刚聊完四次挥手嘛，那你觉得为什么是四次呢？ 其实很好理解，当客户端第一次发送 FIN 报文之后，只是代表着客户端不再发送数据给服务端，但此时客户端还是有接收数据的能力的。而服务端收到FIN报文的时候，可能还有数据要传输给客户端，所以只能先回复 ACK给客户端 等到服务端不再有数据发送给客户端时，才发送 FIN 报文给客户端，表示可以关闭了 所以，一来一回就四次了 从四次挥手的流程上来看，有个 TIME_WAIT 状态，你知道这个状态干什么用的吗？（等待 2MSL） 主要有两个原因吧。1.保证最后的 ACK 报文 「接收方」一定能收到（如果收不到，对方会 重发 FIN 报文）2. 确保在创建新连接时，先前网络中残余的数据都丢失了 其实也比较好理解的。就正如我们重启服务器一样，会先优雅关闭各种资源，再留有一段时间，希望在这段时间内，资源是正常关闭的，这样重启服务器（或者发布）就基本认为不会影响到线上运行了 假设 TIME_WAIT 状态多过会有什么危害？怎么解决呢？ 从流程上看， TIME_WAIT 状态 只会出现在 主动发起 关闭连接的一方。危害就是会占用内存资源和端口呗（毕竟在等待嘛），解决的话，有Linux参数可以设置，具体忘了额 今天最后再问个问题吧，我们常说TCP连接，那这个连接到底是什么？你是怎么理解的？ 其实从三次握手可以发现的是，TCP建立连接无非就是交换了双方的状态（比如序列号）。然后就没有然后了…连接本质上「只是互相维持一个状态，有连接特性」 好吧 ","permalink":"https://hcy-asleep.github.io/TCP-Shakes/Waves-Hands-%E9%97%B2%E8%B0%88/","summary":"\u003cdiv align=\"right\"\u003e\u003cdiv style=\"width: 60%; border-style: solid; border-width: 1px; border-radius: 16px; position: relative; padding:30px; text-align:center\"\u003e\n面试官你好，请问面试可以开始了吗\n\u003c/div\u003e\u003c/div\u003e\u003cbr/\u003e","title":"TCP Shakes/Waves Hands 闲谈"},{"content":" 要不你来讲讲你们对MySQL是怎么调优的？ 哇，这命题很大阿…我认为，对于开发者而言，对MySQL的调优重点一般是在「开发规范」、「数据库索引」又或者说解决线上慢查询上 而对于MySQL内部的参数调优，由专业的DBA来搞 扯了这么多，你就是想表达你不会MySQL参数调优，对吧 草，被发现了 那你来聊聊你们平时开发的规范和索引这块，平时是怎么样的吧 嗯，首先，我们在生产环境下，创建数据库表，都是在工单系统下完成的（那就自然需要DBA审批）。如果在创建表时检测到没有创建索引，那就会直接提示warning（： 理论上来说，如果表有一定的数据量，那就应该要创建对应的索引。从数据库查询数据需要注意的地方还是蛮多的，其中很多都是平时积累来的。比如说： 1. 是否能使用「覆盖索引」，减少「回表」所消耗的时间。意味着，我们在select 的时候，一定要指明对应的列，而不是select * 2. 考虑是否组建「联合索引」，如果组建「联合索引」，尽量将区分度最高的放在最左边，并且需要考虑「最左匹配原则」 3.对索引进行函数操作或者表达式计算会导致索引失效 4.利用子查询优化超多分页场景。比如 limit offset , n 在MySQL是获取 offset + n的记录，再返回n条。而利用子查询则是查出n条，通过ID检索对应的记录出来，提高查询效率 嗯… 5.通过explain命令来查看SQL的执行计划，看看自己写的SQL是否走了索引，走了什么索引。通过show profile 来查看SQL对系统资源的损耗情况（不过一般还是比较少用到的） 6.在开启事务后，在事务内尽可能只操作数据库，并有意识地减少锁的持有时间（比如在事务内需要插入\u0026\u0026修改数据，那可以先插入后修改。因为修改是更新操作，会加行锁。如果先更新，那并发下可能会导致多个事务的请求等待行锁释放） 嗯，你提到了事务，之前也讲过了事务的隔离级别嘛，那你线上用的是什么隔离级别？ 嗯，我们这边用的是Read Commit（读已提交），MySQL默认用的是Repeatable read（可重复读）。选用什么隔离级别，主要看应用场景嘛，因为隔离级别越低，事务并发性能越高 一般互联网公司都选择Read Commit作为主要的隔离级别） 像Repeatable read（可重复读）隔离级别，就有可能因为「间隙锁」导致的死锁问题 但可能你已经知道，MySQL默认的隔离级别为Repeatable read。很大一部分原因是在最开始的时候，MySQL的binlog没有row模式，在read commit隔离级别下会存在「主从数据不一致」的问题 binlog记录了数据库表结构和表数据「变更」，比如update/delete/insert/truncate/create。在MySQL中，主从同步实际上就是应用了binlog来实现的（： 有了该历史原因，所以MySQL就将默认的隔离级别设置为Repeatable read 嗯，那我顺便想问下，你们遇到过类似的问题吗：即便走对了索引，线上查询还是慢 嗯嗯，当然遇到过了 那你们是怎么做的？ 如果走对了索引，但查询还是慢，那一般来说就是表的数据量实在是太大了 首先，考虑能不能把「旧的数据」给”删掉”，对于我们公司而言，我们都会把数据同步到Hive，说明已经离线存储了一份了 那如果「旧的数据」已经没有查询的业务了，那最简单的办法肯定是”删掉”部分数据咯。数据量降低了，那自然，检索速度就快了… 嗯，但一般不会删的 没错，只有极少部分业务可以删掉数据（： 随后，就考虑另一种情况，能不能在查询之前，直接走一层缓存（Redis） 而走缓存的话，又要看业务能不能忍受读取的「非真正实时」的数据（毕竟Redis和MySQL的数据一致性需要保证），如果查询条件相对复杂且多变的话（涉及各种group by 和sum），那走缓存也不是一种好的办法，维护起来就不方便了… 再看看是不是有「字符串」检索的场景导致查询低效，如果是的话，可以考虑把表的数据导入至Elasticsearch类的搜索引擎，后续的线上查询就直接走Elasticsearch了 MySQL-\u003eElasticsearch需要有对应的同步程序(一般就是监听MySQL的binlog，解析binlog后导入到Elasticsearch) 如果还不是的话，那考虑要不要根据查询条件的维度，做相对应的聚合表，线上的请求就查询聚合表的数据，不走原表 比如，用户下单后，有一份订单明细，而订单明细表的量级太大。但在产品侧(前台)透出的查询功能是以「天」维度来展示的，那就可以将每个用户的每天数据聚合起来，在聚合表就是一个用户一天只有一条汇总后的数据 查询走聚合后的表，那速度肯定杠杠的（聚合后的表数据量肯定比原始表要少很多） 思路大致的就是「以空间换时间」，相同的数据换别的地方也存储一份，提高查询效率 那我还想问下，除了读之外，写性能同样有瓶颈，怎么办？ 你说到这个，我就不困了 如果在MySQL读写都有瓶颈，那首先看下目前MySQL的架构是怎么样的 如果是单库的，那是不是可以考虑升级至主从架构，实现读写分离 简单理解就是：主库接收写请求，从库接收读请求。从库的数据由主库发送的binlog进而更新，实现主从数据一致（在一般场景下，主从的数据是通过异步来保证最终一致性的） 嗯… 如果在主从架构下，读写仍存在瓶颈，那就要考虑是否要分库分表了 至少在我前公司的架构下，业务是区分的。流量有流量数据库，广告有广告的数据库，商品有商品的数据库。所以，我这里讲的分库分表的含义是：在原来的某个库的某个表进而拆分 比如，现在我有一张业务订单表，这张订单表在广告库中，假定这张业务订单表已经有1亿数据量了，现在我要分库分表 那就会将这张表的数据分至多个广告库以及多张表中（： 分库分表的最明显的好处就是把请求进行均摊（本来单个库单个表有一亿的数据，那假设我分开8个库，那每个库1200+W的数据量，每个库下分8张表，那每张表就150W的数据量） 你们是以什么来作为分库键的？ 按照我们这边的经验，一般来说是按照userId的（因为按照用户的维度查询比较多），如果要按照其他的维度进行查询，那还是参照上面的的思路（以空间换时间） 那分库分表后的ID是怎么生成的？ 这就涉及到分布式ID生成的方式了，思路有很多。有借助MySQL自增的，有借助Redis自增的，有基于「雪花算法」自增的。具体使用哪种方式，那就看公司的技术栈了，一般使用Redis和基于「雪花算法」实现用得比较多 至于为什么强调自增（还是跟索引是有序有关，前面已经讲过了，你应该还记得） 嗯，那如果我要分库分表了，迁移的过程是怎么样的呢 我们一般采取「双写」的方式来进行迁移，大致步骤就是 一、增量的消息各自往新表和旧表写一份 二、将旧表的数据迁移至新库 三、迟早新表的数据都会追得上旧表（在某个节点上数据是同步的） 四、校验新表和老表的数据是否正常（主要看能不能对得上） 五、开启双读（一部分流量走新表，一部分流量走老表），相当于灰度上线的过程 六、读流量全部切新表，停止老表的写入 七、提前准备回滚机制，临时切换失败能恢复正常业务以及有修数据的相关程序 嗯…今天就到这吧 Summary\n数据库表存在一定数据量，就需要有对应的索引 发现慢查询时，检查是否走对索引，是否能用更好的索引进行优化查询速度，查看使用索引的姿势有没有问题 当索引解决不了慢查询时，一般由于业务表的数据量太大导致，利用空间换时间的思想 当读写性能均遇到瓶颈时，先考虑能否升级数据库架构即可解决问题，若不能则需要考虑分库分表 分库分表虽然能解决掉读写瓶颈，但同时会带来各种问题，需要提前调研解决方案和踩坑 ","permalink":"https://hcy-asleep.github.io/MySQL-%E9%97%B2%E8%B0%88-3/","summary":"\u003cdiv align=\"left\"\u003e\u003cdiv style=\"width: 60%; border-style: solid; border-width: 1px; border-radius: 16px; position: relative; padding:30px; text-align:center\"\u003e\n要不你来讲讲你们对MySQL是怎么调优的？\n\u003c/div\u003e\u003c/div\u003e\u003cbr/\u003e","title":"MySQL 闲谈 3"},{"content":" 你是怎么理解InnoDB引擎中的事务的？ 在我的理解下，事务可以使「一组操作」要么全部成功，要么全部失败 事务其目的是为了「保证数据最终的一致性」 举个例子，我给你发支付宝转了888块红包。那自然我的支付宝余额会扣减888块，你的支付宝余额会增加888块 而事务就是保证我的余额扣减跟你的余额增添是同时成功或者同时失败的，这样这次转账就正常了 嗯，那你了解事务的几大特性吗？ 嗯，就是ACID嘛，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability） 原子性指的是：当前事务的操作要么同时成功，要么同时失败。原子性由undo log日志来保证，因为undo log记载着数据修改前的信息 比如我们要 insert 一条数据了，那undo log 会记录的一条对应的 delete 日志。我们要 update 一条记录时，那undo log会记录之前的「旧值」的update记录 如果执行事务过程中出现异常的情况，那执行「回滚」。InnoDB引擎就是利用undo log记录下的数据，来将数据「恢复」到事务开始之前 一致性我稍稍往后讲，我先来说下隔离性 嗯… 隔离性指的是：在事务「并发」执行时，他们内部的操作不能互相干扰。如果多个事务可以同时操作一个数据，那么就会产生脏读、重复读、幻读的问题 于是，事务与事务之间需要存在「一定」的隔离，在InnoDB引擎中，定义了四种隔离级别供我们使用 分别是：read uncommit(读未提交)、read commit (读已提交)、repeatable read (可重复复读)、serializable (串行) 不同的隔离级别对事务之间的隔离性是不一样的（级别越高事务隔离性越好，但性能就越低），而隔离性是由MySQL的各种锁来实现的，只是它屏蔽了加锁的细节 持久性指的就是：一旦提交了事务，它对数据库的改变就应该是永久性的。说白了就是，会将数据持久化在硬盘上 而持久性由redo log 日志来保证，当我们要修改数据时，MySQL是先把这条记录所在的「页」找到，然后把该页加载到内存中，将对应记录进行修改 为了防止内存修改完了，MySQL就挂掉了（如果内存改完，直接挂掉，那这次的修改相当于就丢失了） MySQL引入了redo log，内存写完了，然后会写一份redo log，这份redo log记载着这次在某个页上做了什么修改 即便MySQL在中途挂了，我们还可以根据redo log来对数据进行恢复 redo log 是顺序写的，写入速度很快。并且它记录的是物理修改（xxxx页做了xxx修改），文件的体积很小，恢复速度也很快 回头再来讲一致性，「一致性」可以理解为我们使用事务的「目的」，而「隔离性」「原子性」「持久性」均是为了保障「一致性」的手段，保证一致性需要由应用程序代码来保证 比如，如果事务在发生的过程中，出现了异常情况，此时你就得回滚事务，而不是强行提交事务来导致数据不一致 嗯，挺好的，讲了蛮多的 刚才你也提到了隔离性嘛，然后你说在MySQL中有四种隔离级别，能分别来介绍下吗？ 嗯，为了讲清楚隔离级别，我顺带来说下MySQL锁相关的知识吧 在InnoDB引擎下，按锁的粒度分类，可以简单分为行锁和表锁 行锁实际上是作用在索引之上的（索引上次已经说过了，这里就不赘述了）。当我们的SQL命中了索引，那锁住的就是命中条件内的索引节点（这种就是行锁），如果没有命中索引，那我们锁的就是整个索引树（表锁） 简单来说就是：锁住的是整棵树还是某几个节点，完全取决于SQL条件是否有命中到对应的索引节点 而行锁又可以简单分为读锁（共享锁、S锁）和写锁（排它锁、X锁） 读锁是共享的，多个事务可以同时读取同一个资源，但不允许其他事务修改。写锁是排他的，写锁会阻塞其他的写锁和读锁 我现在就再回到隔离级别上吧，就直接以例子来说明啦 嗯… 首先来说下read uncommit(读未提交)。比如说：A向B转账，A执行了转账语句，但A还没有提交事务，B读取数据，发现自己账户钱变多了！B跟A说，我已经收到钱了。A回滚事务【rollback】，等B再查看账户的钱时，发现钱并没有多 简单的定义就是：事务B读取到了事务A还没提交的数据，这种用专业术语来说叫做「脏读」 对于锁的维度而言，其实就是在read uncommit隔离级别下，读不会加任何锁，而写会加排他锁。读什么锁都不加，这就让排他锁无法排它了 而我们又知道，对于更新操作而言，InnoDB是肯定会加写锁的（数据库是不可能允许在同一时间，更新同一条记录的）。而读操作，如果不加任何锁，那就会造成上面的脏读 脏读在生产环境下肯定是无法接受的，那如果读加锁的话，那意味着：当更新数据的时，就没办法读取了，这会极大地降低数据库性能 在MySQL InnoDB引擎层面，又有新的解决方案（解决加锁后读写性能问题），叫做MVCC(Multi-Version Concurrency Control)多版本并发控制 在MVCC下，就可以做到读写不阻塞，且避免了类似脏读这样的问题 那MVCC是怎么做的呢？ MVCC通过生成数据快照（Snapshot)，并用这个快照来提供一定级别（语句级或事务级）的一致性读取 回到事务隔离级别下，针对于 read commit (读已提交) 隔离级别，它生成的就是语句级快照，而针对于repeatable read (可重复读)，它生成的就是事务级的快照 前面提到过read uncommit隔离级别下会产生脏读，而read commit (读已提交) 隔离级别解决了脏读。思想其实很简单：在读取的时候生成一个”版本号”，等到其他事务commit了之后，才会读取最新已commit的”版本号”数据 比如说：事务A读取了记录(生成版本号)，事务B修改了记录(此时加了写锁)，事务A再读取的时候，是依据最新的版本号来读取的(当事务B执行commit了之后，会生成一个新的版本号)，如果事务B还没有commit，那事务A读取的还是之前版本号的数据 通过「版本」的概念，这样就解决了脏读的问题，而「版本」其实就是对应快照的数据 read commit (读已提交) 解决了脏读，但也会有其他并发的问题。「不可重复读」：一个事务读取到另外一个事务已经提交的数据，也就是说一个事务可以看到其他事务所做的修改 不可重复读的例子：A查询数据库得到数据，B去修改数据库的数据，导致A多次查询数据库的结果都不一样【危害：A每次查询的结果都是受B的影响的】 了解MVCC基础之后，就很容易想到repeatable read (可重复复读)隔离级别是怎么避免不可重复读的问题了（前面也提到了） repeatable read (可重复复读)隔离级别是「事务级别」的快照！每次读取的都是「当前事务的版本」，即使当前数据被其他事务修改了(commit)，也只会读取当前事务版本的数据 而repeatable read (可重复复读)隔离级别会存在幻读的问题，「幻读」指的是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致 在InnoDB引擎下的的repeatable read (可重复复读)隔离级别下，快照读MVCC影响下，已经解决了幻读的问题（因为它是读历史版本的数据） 而如果是当前读（指的是 select * from table for update），则需要配合间隙锁来解决幻读的问题 剩下的就是serializable (串行)隔离级别了，它的最高的隔离级别，相当于不允许事务的并发，事务与事务之间执行是串行的，它的效率最低，但同时也是最安全的 嗯，不妨来说下MVCC的原理？ MVCC的主要是通过read view和undo log来实现的 undo log前面也提到了，它会记录修改数据之前的信息，事务中的原子性就是通过undo log来实现的。所以，有undo log可以帮我们找到「版本」的数据 而read view 实际上就是在查询时，InnoDB会生成一个read view，read view 有几个重要的字段，分别是：trx_ids（尚未提交commit的事务版本号集合），up_limit_id（下一次要生成的事务ID值），low_limit_id（尚未提交版本号的事务ID最小值）以及creator_trx_id（当前的事务版本号） 在每行数据有两列隐藏的字段，分别是DB_TRX_ID（记录着当前ID）以及DB_ROLL_PTR（指向上一个版本数据在undo log 里的位置指针） 铺垫到这了，很容易就发现，MVCC其实就是靠「比对版本」来实现读写不阻塞，而版本的数据存在于undo log中 而针对于不同的隔离级别（read commit和repeatable read），无非就是read commit隔离级别下，每次都获取一个新的read view，repeatable read隔离级别则每次事务只获取一个read view 嗯，OK的。细节就不考究了，今天就到这里吧 Summary\n事务为了保证数据的最终一致性 事务有四大特性，分别是原子性、一致性、隔离性、持久性\n原子性由undo log保证 持久性由redo log 保证 隔离性由数据库隔离级别供我们选择，分别有read uncommit,read commit,repeatable read,serializable 一致性是事务的目的，一致性由应用程序来保证 事务并发会存在各种问题，分别有脏读、重复读、幻读问题，上面的不同隔离级别可以解决掉由于并发事务所造成的问题，而隔离级别实际上就是由MySQL锁来实现的 频繁加锁会导致数据库性能低下，引入了MVCC多版本控制来实现读写不阻塞，提高数据库性能 MVCC原理即通过read view 以及undo log来实现 ","permalink":"https://hcy-asleep.github.io/MySQL-%E9%97%B2%E8%B0%88-2/","summary":"\u003cdiv align=\"left\"\u003e\u003cdiv style=\"width: 60%; border-style: solid; border-width: 1px; border-radius: 16px; position: relative; padding:30px; text-align:center\"\u003e\n你是怎么理解InnoDB引擎中的事务的？\n\u003c/div\u003e\u003c/div\u003e\u003cbr/\u003e","title":"MySQL 闲谈 2"},{"content":"只有左右框\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;div align=\u0026#34;right\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;width:47%; border-style:solid; border-width:1px; border-radius:15px\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;text-align:center;margin:5%\u0026#34;\u0026gt; 这是右边 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div align=\u0026#34;left\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;width:47%; border-style:solid; border-width:1px; border-radius:15px\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;text-align:center;margin:5%\u0026#34;\u0026gt; 这是左边 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 带有箭头的左右框 写法一\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .div-diabox{ width: 60%; border-style: solid; border-width: 1px; border-radius: 16px; position: relative; padding:30px; text-align:center } .div-diabox .arrow-right-out{ width: 0px; height: 0px; border-style: solid; border-color: transparent transparent transparent black; border-width: 10px; position: absolute; top: 10px; right: -20px; } .div-diabox .arrow-right-in{ width: 0px; height: 0px; border-style: solid; border-color: transparent transparent transparent white; border-width: 10px; position: absolute; top: 10px; right: -19px; } .div-diabox .arrow-left-out{ width: 0px; height: 0px; border-style: solid; border-color: transparent black transparent transparent; border-width: 10px; position: absolute; top: 10px; left: -20px; } .div-diabox .arrow-left-in{ width: 0px; height: 0px; border-style: solid; border-color: transparent white transparent transparent; border-width: 10px; position: absolute; top: 10px; left: -19px; } \u0026lt;/style\u0026gt; \u0026lt;div align=\u0026#34;right\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;div-diabox\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;arrow-right-out\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;arrow-right-in\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 右边 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;div align=\u0026#34;left\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;div-diabox\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;arrow-left-out\u0026#34;/\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;arrow-left-in\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 左边 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;br/\u0026gt; 写法二\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;div align=\u0026#34;right\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;width: 60%; border-style: solid; border-width: 1px; border-radius: 16px; position: relative; padding:30px; text-align:center\u0026#34;\u0026gt; \u0026lt;span style=\u0026#34;width: 0px; height: 0px; border-style: solid; border-color: transparent transparent transparent black; border-width: 10px; position: absolute; top: 10px; right: -20px;\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;width: 0px; height: 0px; border-style: solid; border-color: transparent transparent transparent white; border-width: 10px; position: absolute; top: 10px; right: -19px\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 右边 \u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;div align=\u0026#34;left\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;width: 60%; border-style: solid; border-width: 1px; border-radius: 16px; position: relative; padding:30px; text-align:center\u0026#34;\u0026gt; \u0026lt;span style=\u0026#34;width: 0px; height: 0px; border-style: solid; border-color: transparent black transparent transparent; border-width: 10px; position: absolute; top: 10px; left: -20px;\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;width: 0px; height: 0px; border-style: solid; border-color: transparent white transparent transparent; border-width: 10px; position: absolute; top: 10px; left: -19px;\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 左边 \u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;br/\u0026gt; ","permalink":"https://hcy-asleep.github.io/Markdown-%E5%AF%B9%E8%AF%9D%E6%A1%86/","summary":"只有左右框\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;div align=\u0026#34;right\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;width:47%; border-style:solid; border-width:1px; border-radius:15px\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;text-align:center;margin:5%\u0026#34;\u0026gt; 这是右边 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div align=\u0026#34;left\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;width:47%; border-style:solid; border-width:1px; border-radius:15px\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;text-align:center;margin:5%\u0026#34;\u0026gt; 这是左边 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 带有箭头的左右框 写法一\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .","title":"Markdown 对话框"},{"content":" 1 du -sh ./* ","permalink":"https://hcy-asleep.github.io/Linux-%E6%9F%A5%E7%9C%8B%E7%A1%AC%E7%9B%98%E7%A9%BA%E9%97%B4/","summary":" 1 du -sh ./* ","title":"Linux 查看硬盘空间"},{"content":"apt 只下载包及其依赖而不安装\n1 2 # sudo apt-get install -d \u0026lt;软件包\u0026gt; sudo apt-get install -d vlc 这将会下载到这个目录\n1 /var/cache/apt/archives/ 为了只是获得想要的包和依赖，应该先清空这个目录再下载\n将 /var/cache/apt/archives/ 的包以及依赖移到某一个目录保存\n然后把这些包安装到指定目录\n1 2 3 4 5 for file in packagesPath: do echo $file sudo dpkg -x $file customInstallPath done 在 customInstallPath 下编写一个启动脚本\n1 2 3 4 5 6 7 8 9 #!/bin/sh HERE=\u0026#34;$(dirname \u0026#34;$(readlink -f \u0026#34;$0\u0026#34;)\u0026#34;)\u0026#34; export UNION_PRELOAD=$HERE export LD_PRELOAD=$HERE/libunionpreload.so export PATH=$HERE/usr/bin/:$HERE/usr/sbin/:$HERE/usr/games/:$HERE/bin/:$HERE/opt/vlc/:$HERE/sbin/:$PATH export LD_LIBRARY_PATH=/usr/lib/x86_64-linux-gnu/:$HERE/usr/lib/:$HERE/usr/lib/x86_64-linux-gnu/:$HERE/lib/:$HERE/lib/x86_64-linux-gnu/:$HERE/usr/lib/x86_64-linux-gnu/vlc/:$LD_LIBRARY_PATH export QT_PLUGIN_PATH=/usr/lib/x86_64-linux-gnu/qt5/plugins/:$HERE/usr/lib/x86_64-linux-gnu/qt5/plugins/:$QT_PLUGIN_PATH export XDG_DATA_DIRS=$HERE/usr/share/:$XDG_DATA_DIRS exec $HERE/usr/bin/vlc \u0026#34;$@\u0026#34; 保存并赋予这个启动脚本执行权限\n1 chmod a+x launch.sh 执行 launch.sh 就可以运行 vlc 了\n这个脚本里面的 bash 变量是程序内部执行需要的变量，并不是环境变量，只有知道软件构建运行的源码才可以写出来，所以这个脚本并不是通用的，只适合 vlc\n","permalink":"https://hcy-asleep.github.io/VLC-Linux-%E5%AE%89%E8%A3%85%E5%9C%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%AE%E5%BD%95/","summary":"\u003cp\u003eapt 只下载包及其依赖而不安装\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# sudo apt-get install -d \u0026lt;软件包\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install -d vlc\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"VLC Linux 安装在自定义目录"},{"content":"腾讯会议不支持 Wayland\n进入 /opt/wemeet 目录\n编辑 wemeetapp.sh 文件\n在 export QT_PLUGIN_PATH=\u0026quot;${HERE}/plugins\u0026quot; 后添加如下三行代码后保存\n1 2 3 export XDG_SESSION_TYPE=x11 export QT_QPA_PLATFORM=xcb unset WAYLAND_DISPLAY 重启即可\n缺点\n由于 Wayland 的限制，腾讯会议现在无法捕捉到屏幕，自然“共享屏幕”也就失效了，实际效果是当尝试共享屏幕时，共享的是 pure black ","permalink":"https://hcy-asleep.github.io/Wayland-Wemeet/","summary":"腾讯会议不支持 Wayland\n进入 /opt/wemeet 目录\n编辑 wemeetapp.sh 文件\n在 export QT_PLUGIN_PATH=\u0026quot;${HERE}/plugins\u0026quot; 后添加如下三行代码后保存\n1 2 3 export XDG_SESSION_TYPE=x11 export QT_QPA_PLATFORM=xcb unset WAYLAND_DISPLAY 重启即可\n缺点\n由于 Wayland 的限制，腾讯会议现在无法捕捉到屏幕，自然“共享屏幕”也就失效了，实际效果是当尝试共享屏幕时，共享的是 pure black ","title":"Wayland Wemeet"},{"content":"MARO 三层框架 接下来展示的是第三层 Distibuted toolkit\nMARO Distibuted Toolkit 遵循 message-passing 模式，即不同组件之间的协作基于消息发送和接收\n典型的 master/worker 分布式程序通常包含以下步骤\nmaster 会将任务（w/ or w/o data）发送到 worker worker 将在其本地计算环境或本地设备中完成任务 worker 将计算结果返回到 master 根据实际需要，主控组件和工作组件之间的通信方式可以是同步的，也可以是异步的\n关键部件\nComunication\n大致功能预览\n提供通用的消息传递接口\nsend, receive broadcast scatter 通信组件使用 可替换 的通信协议驱动程序来适应不同的通信协议栈\nTCP/IP InfiniBand Peer Discovering\n部分故障恢复\n条件事件自动调度\nProxy\nProxy 提供通信原语的实现，是通信操作接口，是通信组件的主要实体\nProxy 默认使用 ZeroMQ 框架\nProxy 为基于 Redis 的 peer discovering 提供支持\n分布式通信原语常见操作如下\nBroadcast\nScatter\nReduce (强调聚合之后处理)\nGather (单纯聚合没有额外处理)\nAll Reduce\nAll Gather\nReduce Scatter\nAll to All\nMessage\n用于打包组件之间的通信内容，消息实例的主要属性包括\ntag：自定义属性，可用于通过 conditional event register table 实现自动调度逻辑 source：message 发送者的别名 destination：message 接收者的别名 payload：用于远程函数调用的 Python 对象 session_id（自动生成）：特定会话的 UUID ，一个会话可能包含多条消息 message_id（自动生成）：特定消息的 UUID Example\n1 2 3 4 5 6 from maro.communication import Message message = Message(tag=\u0026#34;check_in\u0026#34;, source=\u0026#34;worker_001\u0026#34;, destination=\u0026#34;master\u0026#34;, body=\u0026#34;\u0026#34;) Session Message\nMARO 为常见的分布式场景提供了两种预定义的会话类型\nTask Session\n存在 master 和 worker 关系\n用于描述从 master 发送到 worker 的 computing task\nmaster 将 task 发送给 worker 一旦 worker 收到 task ，worker 就开始执行 task worker 将 computing result 返回给 master Notification Session\nsender 和 receiver 关系\n用于信息同步\nsender 发送 notification message receiver 接收 notification message session 的每个阶段由 proxy 在内部维护\nExample\n1 2 3 4 5 6 7 8 9 10 11 12 13 from maro.communication import SessionMessage, SessionType task_message = SessionMessage(tag=\u0026#34;sum\u0026#34;, source=\u0026#34;master\u0026#34;, destination=\u0026#34;worker_001\u0026#34;, body=[0, 1, 2, ...], session_type=SessionType.TASK) notification_message = SessionMessage(tag=\u0026#34;check_out\u0026#34;, source=\u0026#34;worker_001\u0026#34;, destination=\u0026#34;master\u0026#34;, body=\u0026#34;\u0026#34;, session_type=SessionType.NOTIFICATION) MARO 通信原语实际接口\nreceive：用于持续接收消息 receive_by_id：仅接收具有给定 session ID 的消息 send：单播，这是一种阻塞、一对一的发送模式，监视并收集来自远程对等方的回复消息 isend：非阻塞版的 send ，将立即返回 message session ID，该 ID 可由 receive_by_id 使用 scatter：send 的高级版本，用于向 peer 发送消息，并监视和收集来自 peer 的回复消息，不是真正的多播，每条消息都会经过完整的 TCP/IP 堆栈（ZeroMQ driver），如果要发送的消息完全相同，并且想要更好的性能，请改用 broadcast 接口 iscatter：非阻塞版本的 scatter ，message session ID 将立即返回，可由 receive_by_id 使用 broadcast：阻塞，用于向所有订阅者广播消息，将监视并收集所有订阅者的回复消息 ibroadcast：非阻塞版本的 broadcast ，相关 message session ID 将立即返回，可供 receive_by_id 使用 Conditional Event Register Table\n提供消息自动发送机制 通过将 conditional event 和相关的 handler function 注册到注册表中，当 conditional event 满足时，handler function 将与接收到的消息一起自动执行 ![](https://raw.githubusercontent.com/HCY-ASLEEP/picture-bed/main/picture-bed/register_table.register.svg) conditional event 用于声明自动触发相关 handler function 所需的消息组\nunit event 是条件事件中的最小组件，声明格式分三段\nsource：用于声明所需的消息源 tag：消息实例的属性 amount：所需的消息实例量 1 2 3 unit_event_abs = \u0026#34;worker:update:10\u0026#34; unit_event_rel = \u0026#34;worker:update:60%\u0026#34; AND OR 操作支持更复杂的业务逻辑\n1 2 3 4 5 6 7 8 9 10 11 combined_event_and = (\u0026#34;worker_01:update:2\u0026#34;, \u0026#34;worker_02:update:3\u0026#34;, \u0026#34;AND\u0026#34;) combined_event_or = (\u0026#34;worker_03:update:1\u0026#34;, \u0026#34;worker_04:update:5\u0026#34;, \u0026#34;OR\u0026#34;) combined_event_mix = ((\u0026#34;worker_01:update:2\u0026#34;, \u0026#34;worker_02:update:3\u0026#34;, \u0026#34;AND\u0026#34;), \u0026#34;worker_03:update:1\u0026#34;, \u0026#34;OR\u0026#34;) Handler function 是绑定到特定 conditional event 的用户定义的回调函数，当满足事件的条件时，相关消息将被发送到处理程序函数执行\n1 2 3 4 5 6 7 8 9 10 11 # A common handler function signature def handler(that, proxy, messages): \u0026#34;\u0026#34;\u0026#34; Conditional event handler function. Args: that: local instance reference, which needs to be operated. proxy: the proxy reference for remote communication. messages: received messages. \u0026#34;\u0026#34;\u0026#34; pass Distributed Decorator\n从本地函数类生成分布式 worker 类的帮助程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from maro.communication import dist, Proxy # Initialize proxy instance for remote communication. proxy = Proxy(group_name=\u0026#34;master-worker\u0026#34;, component_type=\u0026#34;worker\u0026#34;, expected_peers=[(\u0026#34;master\u0026#34;, 1)]) # Declare the trigger condition of rollout event. rollout_event = \u0026#34;master:rollout:1\u0026#34; # Implement rollout event handler logic. def on_rollout(that, proxy, messages): pass # Assemble event-handler directory. handler_dict = {rollout_event: on_rollout} # Convert a local functional class to a distributed one. @dist(proxy, handler_dict) class Worker: def __init__(self): pass ","permalink":"https://hcy-asleep.github.io/MARO-Distibuted-Toolkit/","summary":"\u003ch3 id=\"maro-三层框架\"\u003eMARO 三层框架\u003c/h3\u003e","title":"MARO Distibuted Toolkit"},{"content":"VIM 配置是会随着使用时间慢慢改进的，需要看最新最完整的需移步到 我的 Github 仓库\nVIM 配置说明\n安装 neovim 可以直接从 github 下载 appimage\n配置 neovim 首次启动使用 :checkhealth 查看配置的路径等信息\ncoc.nvim 的 LSP 服务需要 npm （ node.js ）提供支持，npm 安装的时候可以从官方网站那里下载然后安装到指定 path，之后的 -g 安装 npm 包的时候包会安装在安装 npm 的目录下面\n注意这个 coc-setting.json 这个在安装了 coc.nvim 之后可以 :CocConfig 来进行编辑，json 里面这一句话一定要加上，解决了初次 tab 选中的问题\n配置文件 init.vim 位于 /home/asleep/.config/nvim 下，coc-settings.json 也是在这个路径下面\nvimplug 管理插件，这里有点特殊，这里我将其他插件安装在与 vimplug 的 plug.vim 同一个目录下面，即 /home/asleep/.local/share/nvim/site/autoload\n安装各种插件之前，应该要了解各个插件的依赖\n至于 vimplug 的安装，只需要把 github 上面的那个 plug.vim 文件弄下来放在上面说的那个 path 下面就可以调用 :PlugInstall，不用整个仓库弄下来\n至于 coc 的插件，coc.nvim 是一个插件管理器，coc.nvim 管理的插件在 /home/asleep/.config/coc/extensions 下面\n综上所述，如果要迁移 nvim 及其配置，只需要复制\n1 2 3 4 5 /home/asleep/.config/coc/extensions “coc-extensions” /home/asleep/.config/nvim “coc-settings.json” “init.vim“ /home/asleep/.local/share/nvim/site/autoload “plug.vim” “vim-plug extensions” 这三个路径下的文件就可以完成迁移\n每次修改 init.vim 之后，都要 :so % 即 :source init.vim 生效\ncoc-setting.json\n1 2 3 { \u0026#34;suggest.noselect\u0026#34;: true, } init.vim 已启用的配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 \u0026#34; ------------------------------------------------------------------------------------------------------------- \u0026#34; ---------------------------------------------common-start---------------------------------------------------- \u0026#34; ------------------------------------------------------------------------------------------------------------- set number set mouse=c set tabstop=4 set autoindent set backspace=indent,eol,start set hlsearch set clipboard+=unnamedplus set foldmethod=syntax set nofoldenable \u0026#34; 自动同步 set autoread set fillchars=eob:\\ \u0026#34; Vim jump to the last position when reopening a file if has(\u0026#34;autocmd\u0026#34;) au BufReadPost * if line(\u0026#34;\u0026#39;\\\u0026#34;\u0026#34;) \u0026gt; 1 \u0026amp;\u0026amp; line(\u0026#34;\u0026#39;\\\u0026#34;\u0026#34;) \u0026lt;= line(\u0026#34;$\u0026#34;) | exe \u0026#34;normal! g\u0026#39;\\\u0026#34;\u0026#34; | endif endif function! ESC_IMAP() let l:frontChar = getline(\u0026#39;.\u0026#39;)[col(\u0026#39;.\u0026#39;) - 2] if l:frontChar == \u0026#34;;\u0026#34; call feedkeys(\u0026#34;\\\u0026lt;BS\u0026gt;\\\u0026lt;BS\u0026gt;\\\u0026lt;ESC\u0026gt;\u0026#34;, \u0026#39;n\u0026#39;) else call feedkeys(\u0026#34;\\\u0026lt;BS\u0026gt;\\;\u0026#34;, \u0026#39;n\u0026#39;) endif endfunction inoremap \u0026lt;expr\u0026gt; ; ESC_IMAP() set timeoutlen=200 nnoremap ;; \u0026lt;ESC\u0026gt; vnoremap ;; \u0026lt;ESC\u0026gt; snoremap ;; \u0026lt;ESC\u0026gt; xnoremap ;; \u0026lt;ESC\u0026gt; cnoremap ;; \u0026lt;ESC\u0026gt; onoremap ;; \u0026lt;ESC\u0026gt; \u0026#34; exit windows tnoremap ;; \u0026lt;C-\\\u0026gt;\u0026lt;C-n\u0026gt; \u0026#34; switch windows nnoremap \u0026lt;TAB\u0026gt; \u0026lt;C-w\u0026gt;w nnoremap vv \u0026lt;C-v\u0026gt; echo expand(\u0026#34;%:p:h\u0026#34;) cnoreabbrev fd echo expand(\u0026#34;%:p:h\u0026#34;) cnoreabbrev vst vs\u0026lt;ENTER\u0026gt;:term cnoreabbrev spt sp\u0026lt;ENTER\u0026gt;:term \u0026#34; ------------------------------------------------------------------------------------------------------------- \u0026#34;-----------------------------------------------common-end---------------------------------------------------- \u0026#34;------------------------------------------------------------------------------------------------------------- \u0026#34; \u0026#34; \u0026#34; \u0026#34;------------------------------------------------------------------------------------------------------------- \u0026#34;--------------------------------------------vim-plug-start--------------------------------------------------- \u0026#34;------------------------------------------------------------------------------------------------------------- call plug#begin(\u0026#39;/home/asleep/.local/share/nvim/site/autoload\u0026#39;) Plug \u0026#39;itchyny/lightline.vim\u0026#39; Plug \u0026#39;joshdick/onedark.vim\u0026#39; Plug \u0026#39;neoclide/coc.nvim\u0026#39;, {\u0026#39;branch\u0026#39;: \u0026#39;release\u0026#39;} Plug \u0026#39;jiangmiao/auto-pairs\u0026#39; Plug \u0026#39;ms-jpq/chadtree\u0026#39;, {\u0026#39;branch\u0026#39;: \u0026#39;chad\u0026#39;, \u0026#39;do\u0026#39;: \u0026#39;python3 -m chadtree deps\u0026#39;} Plug \u0026#39;sheerun/vim-polyglot\u0026#39; Plug \u0026#39;Yggdroot/LeaderF\u0026#39;, { \u0026#39;do\u0026#39;: \u0026#39;:LeaderfInstallCExtension\u0026#39; } Plug \u0026#39;tpope/vim-fugitive\u0026#39; Plug \u0026#39;sbdchd/neoformat\u0026#39; Plug \u0026#39;iamcco/markdown-preview.nvim\u0026#39;, { \u0026#39;do\u0026#39;: \u0026#39;cd app \u0026amp;\u0026amp; yarn install\u0026#39; } call plug#end() \u0026#34;有些插件需要安装 nerd fonts！ \u0026#34;nerd fonts 包括了 powerline fonts！ \u0026#34;建议安装 DejaVuSansMonoNerd！ \u0026#34;这个是 LeaderF 的设置 let g:Lf_WindowPosition = \u0026#39;popup\u0026#39; cnoreabbrev ff LeaderfFile cnoreabbrev fm Neoformat cnoreabbrev mt MarkdownPreviewToggle let g:mkdp_theme = \u0026#34;light\u0026#34; \u0026#34;这个是 chadtree 的设置 \u0026#34;明确指定绑定的键之后，就不会使用默认的键 let g:chadtree_settings = { \\ \u0026#39;keymap.change_focus_up\u0026#39;: [\u0026#34;..\u0026#34;], \\ \u0026#39;keymap.secondary\u0026#39;: [\u0026#34;\u0026lt;2-leftmouse\u0026gt;\u0026#34;] \\} nnoremap \u0026lt;F2\u0026gt; :CHADopen\u0026lt;CR\u0026gt; let g:onedark_terminal_italics=1 autocmd ColorScheme * highlight Normal ctermbg=NONE guibg=NONE colorscheme onedark let g:lightline = { \\\u0026#39;colorscheme\u0026#39; : \u0026#39;onedark\u0026#39;, \\ \u0026#39;separator\u0026#39;: { \u0026#39;left\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;right\u0026#39;: \u0026#39;\u0026#39; }, \\ \u0026#39;subseparator\u0026#39;: { \u0026#39;left\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;right\u0026#39;: \u0026#39;\u0026#39; }, \\ \u0026#39;component\u0026#39;: { \\ \u0026#39;lineinfo\u0026#39;: \u0026#39; %3l / %L : %-2v\u0026#39;, \\ }, \\ } \u0026#34;------------------------------------------------------------------------------------------------------------- \u0026#34;-----------------------------------------------vim-plug-end-------------------------------------------------- \u0026#34;------------------------------------------------------------------------------------------------------------- \u0026#34;------------------------------------------------------------------------------------------------------------- \u0026#34;------------------------------------------------coc-start---------------------------------------------------- \u0026#34;------------------------------------------------------------------------------------------------------------- inoremap \u0026lt;silent\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;TAB\u0026gt; coc#pum#visible() ? coc#pum#next(1) :\u0026#34;\\\u0026lt;Tab\u0026gt;\u0026#34; nnoremap gd \u0026lt;Plug\u0026gt;(coc-definition) nnoremap gt \u0026lt;Plug\u0026gt;(coc-type-definition) nnoremap gi \u0026lt;Plug\u0026gt;(coc-implementation) nnoremap gr \u0026lt;Plug\u0026gt;(coc-references) \u0026#34; Use K to show documentation in preview window. function! ShowDocumentation() if CocAction(\u0026#39;hasProvider\u0026#39;, \u0026#39;hover\u0026#39;) call CocActionAsync(\u0026#39;doHover\u0026#39;) else call feedkeys(\u0026#39;K\u0026#39;, \u0026#39;in\u0026#39;) endif endfunction nnoremap \u0026lt;silent\u0026gt; K :call ShowDocumentation()\u0026lt;CR\u0026gt; \u0026#34; Highlight the symbol and its references when holding the cursor. autocmd CursorHold * silent call CocActionAsync(\u0026#39;highlight\u0026#39;) \u0026#34; Symbol renaming. nnoremap \u0026lt;space\u0026gt;r \u0026lt;Plug\u0026gt;(coc-rename) \u0026#34; Show all diagnostics. nnoremap \u0026lt;silent\u0026gt;\u0026lt;nowait\u0026gt; \u0026lt;space\u0026gt;a :\u0026lt;C-u\u0026gt;CocList diagnostics\u0026lt;cr\u0026gt; \u0026#34; Manage extensions. nnoremap \u0026lt;silent\u0026gt;\u0026lt;nowait\u0026gt; \u0026lt;space\u0026gt;e :\u0026lt;C-u\u0026gt;CocList extensions\u0026lt;cr\u0026gt; \u0026#34; Find symbol of current document. nnoremap \u0026lt;silent\u0026gt;\u0026lt;nowait\u0026gt; \u0026lt;space\u0026gt;o :\u0026lt;C-u\u0026gt;CocList outline\u0026lt;cr\u0026gt; \u0026#34;------------------------------------------------------------------------------------------------------------- \u0026#34;-------------------------------------------------coc-end----------------------------------------------------- \u0026#34;------------------------------------------------------------------------------------------------------------- init.vim 未启用的配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 \u0026#34;\u0026#34;------------------------------------------------------------------------------------------------------------- \u0026#34;\u0026#34;----------------------------------------------netrw_start---------------------------------------------------- \u0026#34;\u0026#34;------------------------------------------------------------------------------------------------------------- let g:netrw_banner = 0 let g:netrw_liststyle = 3 let g:netrw_browse_split = 4 let g:netrw_altv = 1 let g:netrw_winsize = 15 set autochdir \u0026#34; Toggle Vexplore with \u0026lt;F2\u0026gt; function! ToggleVExplorer() if exists(\u0026#34;t:expl_buf_num\u0026#34;) let expl_win_num = bufwinnr(t:expl_buf_num) let cur_win_num = winnr() if expl_win_num != -1 while expl_win_num != cur_win_num exec \u0026#34;wincmd w\u0026#34; let cur_win_num = winnr() endwhile close endif unlet t:expl_buf_num else Vexplore let t:expl_buf_num = bufnr(\u0026#34;%\u0026#34;) endif endfunction map \u0026lt;F2\u0026gt; :call ToggleVExplorer()\u0026lt;CR\u0026gt; \u0026#34;\u0026#34; 状态栏无插件设置 hi VertSplit ctermfg=NONE ctermbg=NONE cterm=NONE set fillchars=vert:\\ \u0026#34;\u0026#34;set fillchars=vert:\\│ set statusline=%*\\ %.50F\\ \u0026#34;显示文件名和文件路径 set statusline+=%=%y%m%r%h%w\\ %* \u0026#34;显示文件类型及文件状态 set statusline+=%{\u0026amp;ff}\\[%{\u0026amp;fenc}]\\ %* \u0026#34;显示文件编码类型 set statusline+=%l/%L,%c\\ %* \u0026#34;显示光标所在行和列 set statusline+=%3p%% \u0026#34;显示光标前文本所占总文本的比例 hi Statusline ctermfg=NONE ctermbg=NONE cterm=bold hi StatuslineNC ctermfg=NONE ctermbg=NONE cterm=NONE \u0026#34;\u0026#34;------------------------------------------------------------------------------------------------------------- \u0026#34;\u0026#34;-----------------------------------------------netrw-end----------------------------------------------------- \u0026#34;\u0026#34;------------------------------------------------------------------------------------------------------------- ","permalink":"https://hcy-asleep.github.io/VIM-%E9%85%8D%E7%BD%AE/","summary":"VIM 配置是会随着使用时间慢慢改进的，需要看最新最完整的需移步到 我的 Github 仓库\nVIM 配置说明\n安装 neovim 可以直接从 github 下载 appimage\n配置 neovim 首次启动使用 :checkhealth 查看配置的路径等信息\ncoc.nvim 的 LSP 服务需要 npm （ node.js ）提供支持，npm 安装的时候可以从官方网站那里下载然后安装到指定 path，之后的 -g 安装 npm 包的时候包会安装在安装 npm 的目录下面\n注意这个 coc-setting.json 这个在安装了 coc.nvim 之后可以 :CocConfig 来进行编辑，json 里面这一句话一定要加上，解决了初次 tab 选中的问题\n配置文件 init.vim 位于 /home/asleep/.config/nvim 下，coc-settings.json 也是在这个路径下面\nvimplug 管理插件，这里有点特殊，这里我将其他插件安装在与 vimplug 的 plug.vim 同一个目录下面，即 /home/asleep/.local/share/nvim/site/autoload\n安装各种插件之前，应该要了解各个插件的依赖\n至于 vimplug 的安装，只需要把 github 上面的那个 plug.vim 文件弄下来放在上面说的那个 path 下面就可以调用 :PlugInstall，不用整个仓库弄下来\n至于 coc 的插件，coc.","title":"VIM 配置"},{"content":"背景 在云服务期间，用户请求具有一定数量资源的 虚拟机（VM）（Virtual Mechine），例如中央处理器、内存等 假设一个特定的时间，VM 请求的数量和到达模式是固定的，给定一个物理资源有限的 物理机（PM）（Physical Mechine） 集群 不同的 VM 分配策略导致数据中心的成功完成量不同，运营成本也不同 对于云提供商，一个好的 VM 分配策略可以最大限度地提高资源利用率，从而可以通过向用户提供更多的 VM 来增加利润 对于云用户，良好的 VM 分配策略可以最大程度地缩短 VM 响应时间，并提供更好的使用体验 资源供需 每个 PM 中的物理资源是中心资源，包括 物理内核 和 内存\nVM 请求需要一定数量的 物理资源 ，资源要求因不同的 VM 请求而异 只要指定的 PM 的剩余资源足够，模拟器 就会将 VM 分配到指定 PM ，VM 会在指定 PM 中创建 VM 的资源利用率动态变化，PM 的实时能耗将在 Runtime-Simulation（模拟器） 中被模拟出来 VM 执行一段时间后完成其任务，模拟器 将释放分配给此 VM 的资源，并从 PM 中解除分配此 VM ，物理资源被释放，可以处理下一个 VM 请求 VM Request MARO 和机器学习算法原理类似，需要 样本数据 训练出 模型（找出当前场景的规律），再通过模型去 预测 怎样的行为更加正确符合实际 VM scheduling 场景里面，样本数据 是 VM Requests ，样本数据从实际工作负荷中统一采样 只要原始数据集足够大，采样率不太小，采样的 VM Requests**（复数名词）** 就可以被认为遵循与原始请求类似的分布 一个 VM Request 包含 VM 信息（如 订阅 ID、部署 ID 和 VM 类别）、VM 的所需资源（包括所需的 CPU 核心数和内存）以及 剩余缓冲时间（remaining buffer time） VM 类型 交互式\n交互式 VM 通常需要较低的响应时间，因此设置此类 VM 只能分配给不可超额订阅的 PM 服务器 延迟不敏感\n不区分延迟的 VM 通常用于批处理任务或开发工作负荷，可以将此类 VM 分配给可过度订阅的 PM 服务器 VM 分配 根据 有效的 PM 列表 ，模拟器记录的历史信息 以及 VM 的详细所需资源 ，VM 调度器（决策代理） 将根据其分配策略做出决策\n两种有意义的操作\n将 有效的 PM ID 传送到模拟器 推迟如果 剩余缓冲区时间 足够，则可以稍后将处理的 VM Request Oversubscription 超额订阅 考虑到各种服务级别，将物理机分为可超额订阅和非超额订阅的\n所谓超额，就比如 10 个 VM 实际上只使用 7 个 PM （就是厂商为了省钱）\n对于超额订阅，可以在 config.yml 中设置参数\n在此场景，有两个资源可能被超额订阅，CPU 和 内存，因可以设置这两个的最大超额订阅率\nMAX_CPU_OVERSUBSCRIPTION_RATE ，CPU 的超额订阅率，默认设置为 1.15 ，意味着每个 PM 最多可以分配其资源容量的 1.15 倍\nMAX_MEM_OVERSUBSCRIPTION_RATE ，内存的超额订阅率，与 CPU 的类似\n为了保护 PM 免受过载的影响，需要考虑 CPU 利用率 ，MAX_UTILIZATION_RATE 被用作安全机制\nMAX_UTILIZATION_RATE ，默认设置为 1，这意味着在筛选有效 PM 时，允许的最大物理 CPU 使用率为 100% Runtime Simulation 动态利用率 为了使模拟环境最接近真实情况，MARO 模拟每个 VM 的资源利用率（当前仅为 CPU 利用率） 模拟的 VM CPU 利用率根据实际的 VM 工作负载读数而变化 MARO 还将根据每个 PM 中的实时 VM 定期更新实时资源利用率 实时能耗 不同的 VM 分配会导致 PM 集群的能耗不同，MARO 还根据 CPU 利用率模拟（计算）能耗\n能耗曲线\n这个非线性曲线反映了 CPU 利用率 与 能耗 的关系，用于模拟（计算）能耗 Overload 由于 VM 的 CPU 使用率随时间而变化，因此在启用超额订阅时，VM 的 CPU 使用率之和可能会超过物理资源的容量，这种情况称为过载\n目前对于过载的情况，MARO 只支持静默（杀死）所有虚拟机 或 仅记录过载时间，在 config.yml 里面设置\nKILL_ALL_VMS_IF_OVERLOAD\n如果启用此操作，则一旦发生重载，将解除分配位于重载 PM 的所有 VM 考虑到过载的影响，MARO 仍然会计算高利用率的能耗，静默行动对 PM 利用率的影响将反映在下一次 tick 中 无论是否启用终止所有 VM，过载 PM 的数量和过载 VM 的数量都会被计算 这两个指标是累积值，将被记录为环境指标 VM 解除分配 MARO 模拟器会定期检查每次 tick 中完成任务的虚拟机 完成的 VM 意味着它经历了一个完整的生命周期，已准备好终止，它所占用的资源最终将再次可用 然后，模拟器将释放已完成的 VM 的资源，并最终从 PM 中删除 VM Quick Start 准备两个 csv 文件 vm_table 和 cpu_readings_file\nvm_table\nvm_id: int, 每个 vm 的id\nsub_id: int, subscription id（每个 vm 的订阅 id）\ndeploy_id: int, 每个 vm 的部署 id\ntimestamp: int, 每个 vm 的创建时间\nvm_deleted: int. 每个 vm 的删除时间\nvm_lifetime: int, 每个 vm 的生存时间，Lifetime = deletion time - creation time (timestamp) + 1\nvm_category: int, 目前有三种类型\nDelay-Insensitive\n可能延迟的 VM 工作负荷，例如批处理任务或测试工作负荷 可以将此类 VM 分配给可过度订阅的 PM Interactive\n交互式 VM 工作负荷，需要用户及时响应 此类 VM 只能分配给不可超额订阅的 PM Unknown\n未知类型 为避免过载，此类 VM 被视为交互式 VM，只能分配给不可超额订阅的 PM cpu_readings_file\ntimestamp: int, 与 vm_table 中的 timestamp 匹配 vm_id: int, 与 vm_table 中的 vm_id 匹配 cpu_utilization: float, VM CPU 的利用率，以百分比单位 （%）存储 构建命令 将 CSV 数据集构建为 MARO 模拟器可以使用的二进制文件\n1 2 # maro data build --meta $PATH_TO_META_FILE --file $PATH_TO_CSV_FILE --output $PATH_TO_OUTPUT_FILE maro data build --meta ~/.maro/data/vm_scheduling/meta/vmtable.yml --file ~/.maro/data/vm_scheduling/.build/azure.2019.10k/vmtable.bin --output $PWD/vmtable.bin \u0026ndash;meta：必需，用于指定 meta file 的路径。默认情况下，meta file 位于\n1 ~/.maro/data/vm_scheduling/meta/ \u0026ndash;file：必需，用于指定源 CSV 数据文件的路径，如果需要多个源 CSV 数据文件，则可以在特定文件中列出源文件的所有完整路径，并使用 @ 符号指定这个特定文件\n\u0026ndash;output：必需，用于指定目标二进制文件的路径\n生成二进制文件之后，在 topologies 目录下的 config.yml 中指定 VM_TABLE 和 CPU_READINGS 的直接路径\nEnvironment Interface DecisionPayload\n一旦环境需要代理的响应来促进模拟，它就会抛出一个带有 DecisionPayload 的 PendingDecision 事件\nDecisionPayload 包含以下信息\nvalid_pms (List[int]) ：被视为有效的 PM ID 列表（其 CPU 和内存资源足以满足传入的 VM 请求） vm_id (int) ：传入的 VM Request（正在等待分配的 VM Request）的 vm_id ， vm_cpu_cores_requirement (int) ：传入的 VM Request 的 CPU 内核数量 vm_memory_requirement (int) ：传入的 VM Request 请求的内存资源大小 remaining_buffer_time（int） ：当使用 remaining_buffer_time 时，VM Request 将被视为失败，可以在 config.yml 里面设置 Action\n从环境中获取 PendingDecisionAction 事件后，代理应使用 Action 进行响应，以下是有效的 Action\nNone：除了忽略此 VM Request 之外什么都不执行\nAllocateAction：VM 的创建时间将固定在它收到这个 Request 的 tick 处，模拟器将更新目标 PM 的工作负载（CPU 核心数量，内存和能耗），这个 Action 包括:\nvm_id(int)：等待分配资源的 VM 的 ID pm_id(int)：计划将 VM 分配到的 PM 的 ID PostponeAction：计算 remaining buffer time，这个 Action 包括：\nvm_id (int) ：等待分配的 VM 的 ID postpone_step（int）：分配要推迟的次数，单位是 DELAY_DURATION ，1 表示延迟 1 DELAY_DURATION ，可以在 config.yml 中设置 如果时间仍然足够，模拟器将重新生成一个新的请求事件，新需求事件的 仅在剩余缓冲时间上与旧事件不同 如果时间用完，模拟器会将其记录为失败的分配 Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import random from maro.simulator import Env from maro.simulator.scenarios.vm_scheduling import AllocateAction, DecisionPayload, PostponeAction # Initialize an Env for vm_scheduling scenario # 初始化环境 env = Env( scenario=\u0026#34;vm_scheduling\u0026#34;, topology=\u0026#34;azure.2019.10k\u0026#34;, start_tick=0, durations=8638, snapshot_resolution=1 ) # 初始化变量，声明类型，\u0026#34;:\u0026#34;用于声明类型 metrics: object = None decision_event: DecisionPayload = None is_done: bool = False action: AllocateAction = None # Start the env with a None Action # 开始模拟 metrics, decision_event, is_done = env.step(None) while not is_done: valid_pm_num: int = len(decision_event.valid_pms) # 作出决策 if valid_pm_num \u0026lt;= 0: # No valid PM now, postpone. # 没有可用的 PM ，推迟分配 action: PostponeAction = PostponeAction( vm_id=decision_event.vm_id, postpone_step=1 ) else: # Randomly choose an available PM. # 有可用的 PM ，随机选一个 PM 与 VM 绑定 random_idx = random.randint(0, valid_pm_num - 1) pm_id = decision_event.valid_pms[random_idx] action: AllocateAction = AllocateAction( vm_id=decision_event.vm_id, pm_id=pm_id ) # 采取行动 metrics, decision_event, is_done = env.step(action) print(f\u0026#34;[Random] Topology: azure.2019.10k. Total ticks: 8638. Start tick: 0\u0026#34;) print(metrics) ","permalink":"https://hcy-asleep.github.io/MARO-VM-%E8%B0%83%E5%BA%A6/","summary":"\u003ch3 id=\"背景\"\u003e背景\u003c/h3\u003e","title":"MARO VM 调度"},{"content":" 深信服 Go 后端笔试(实习) 2022.9.29\n牛客，要求录屏 Go 语言基本语法（非常细节） 算法 编辑距离 字节飞书搜索后端一面(实习) 2022.10.11\n飞书浏览器或者客户端面试 自我介绍 简历内容（项目过程里面遇到什么问题，如何解决) 为什么选择字节 为什么选择 Go 语言 Python 为什么比 Go 效率低下 Go 语言 sync 包的数据结构以及函数用过哪些 Go 语言逃逸分析 Go 内存管理 什么是线程安全 redis 如何实现线程安全 你写的 redis 是线程安全的吗 redis 实现原理 算法 对称二叉树（感觉有点羞辱） C++ 现在最新标准，有什么新特性 海能达 Go 后端笔试一面(实习) 2022.10.18\n腾讯会议 自我介绍 Go 的切片数组区别 为什么大三就来面试 简历内容（项目过程里面遇到什么问题，如何解决) 软件工程 软件开发流程 软件设计模式 影响数据库查询速率的因素 腾讯游戏技术运营一面(实习) 2022.10.25\n腾讯会议面试，要求录屏\n先来做几条题目，很简单，主要看思路，但是基本语法不能错误，任意语言\n使用 js/php/python 自行实现函数方法 去掉一个数组的重复元素，例如：let arr = [1 ,1 ,2, 3, 3, 2, 1] (若是百亿数据，要求时间O(n)，空间O(1)，有什么思路) 使用 js/php/python 实现一个函数，将字符串 “hello_world” 转换成 \u0026ldquo;HelloWorld\u0026rdquo; , \u0026ldquo;hello_hang_zhou\u0026rdquo; 转换成 “HelloHangZhou” (注意：通用性) 使用 js/php/python 实现一个函数方法，参数为输入一个整数，然后输出这个数所有的因数以及总的个数，比如参数传 48 ，此时输出 1、2、3、4、6、8、12、16、24、48 共 10 个数字，比如参数传 21 ，此时输出 1、3、7、21 共 4 个数字 使用 js/php/python 函数遍历以下 json 数据，输出指定格式结果（考虑 children 层次会无限嵌套） 数据库操作，建一个表学生 student (id,name,sex,birth) (编号、姓名、性别、出生年月) 写下建表语句： student 表新增一个字段“班级编号”（class_no），写出对应的执行 sql 语句 统计每个班级有多少个学生，根据班级编号统计，写下统计 sql 自我介绍\n问简历的内容\nredis 五种数据类型\n平时喜欢看什么书（简历有写）\nbash 基本知识\n面向对象三大特性\n数据库三大范式深入理解\nsql 备份主从一致\n","permalink":"https://hcy-asleep.github.io/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/","summary":"深信服 Go 后端笔试(实习) 2022.9.29\n牛客，要求录屏 Go 语言基本语法（非常细节） 算法 编辑距离 字节飞书搜索后端一面(实习) 2022.10.11\n飞书浏览器或者客户端面试 自我介绍 简历内容（项目过程里面遇到什么问题，如何解决) 为什么选择字节 为什么选择 Go 语言 Python 为什么比 Go 效率低下 Go 语言 sync 包的数据结构以及函数用过哪些 Go 语言逃逸分析 Go 内存管理 什么是线程安全 redis 如何实现线程安全 你写的 redis 是线程安全的吗 redis 实现原理 算法 对称二叉树（感觉有点羞辱） C++ 现在最新标准，有什么新特性 海能达 Go 后端笔试一面(实习) 2022.10.18\n腾讯会议 自我介绍 Go 的切片数组区别 为什么大三就来面试 简历内容（项目过程里面遇到什么问题，如何解决) 软件工程 软件开发流程 软件设计模式 影响数据库查询速率的因素 腾讯游戏技术运营一面(实习) 2022.10.25\n腾讯会议面试，要求录屏\n先来做几条题目，很简单，主要看思路，但是基本语法不能错误，任意语言\n使用 js/php/python 自行实现函数方法 去掉一个数组的重复元素，例如：let arr = [1 ,1 ,2, 3, 3, 2, 1] (若是百亿数据，要求时间O(n)，空间O(1)，有什么思路) 使用 js/php/python 实现一个函数，将字符串 “hello_world” 转换成 \u0026ldquo;HelloWorld\u0026rdquo; , \u0026ldquo;hello_hang_zhou\u0026rdquo; 转换成 “HelloHangZhou” (注意：通用性) 使用 js/php/python 实现一个函数方法，参数为输入一个整数，然后输出这个数所有的因数以及总的个数，比如参数传 48 ，此时输出 1、2、3、4、6、8、12、16、24、48 共 10 个数字，比如参数传 21 ，此时输出 1、3、7、21 共 4 个数字 使用 js/php/python 函数遍历以下 json 数据，输出指定格式结果（考虑 children 层次会无限嵌套） 数据库操作，建一个表学生 student (id,name,sex,birth) (编号、姓名、性别、出生年月) 写下建表语句： student 表新增一个字段“班级编号”（class_no），写出对应的执行 sql 语句 统计每个班级有多少个学生，根据班级编号统计，写下统计 sql 自我介绍","title":"工作面试"},{"content":" Hexo-Next 主题 hexo-theme-next 应该是目前最广泛使用的hexo主题\n安装 Hexo-Next 主题 切换到你的博客顶级工程目录，npm 安装\n1 npm install hexo-theme-next 切换到 Next 主题 在你的博客顶层工程目录下打开 \u0026ldquo;_config.yml\u0026rdquo;\n搜索themes，将里面的值改为next\n1 theme: next 配置 Next 主题 将 node_modules/hexo-theme-next/_config.yml 复制到博客顶层文件目录，重命名为 \u0026ldquo;_config.next.yml\u0026rdquo;\n1 2 cd your_site_dir cp node_modules/hexo-theme-next/_config.yml _config.next.yml 选择 Schemes 打开 \u0026ldquo;_config.next.yml\u0026rdquo; ，首先可以看到 Scheme Settings ，里面提供了四种模式，本站使用 Mist 主题\n1 2 3 4 5 # Schemes #scheme: Muse scheme: Mist #scheme: Pisces #scheme: Gemini 设置站点 icon 在 favicon 中，可以设置侧边栏头像以及站点 icon ，需要把你的 icon 放在主题目录的 source/img/ 目录下\n1 2 3 4 5 favicon: small: /img/avatar.jfif medium: /img/avatar.jfif apple_touch_icon: /img/avatar.jfif safari_pinned_tab: /images/logo.svg 还有其余的很多配置，可以参考 \u0026ldquo;_config.next.yml\u0026rdquo; 里面的提示来配置\n","permalink":"https://hcy-asleep.github.io/Hexo-%E5%8A%A0%E5%BC%BA-Next-Theme-%E7%BE%8E%E5%8C%96/","summary":"Hexo-Next 主题 hexo-theme-next 应该是目前最广泛使用的hexo主题\n安装 Hexo-Next 主题 切换到你的博客顶级工程目录，npm 安装\n1 npm install hexo-theme-next 切换到 Next 主题 在你的博客顶层工程目录下打开 \u0026ldquo;_config.yml\u0026rdquo;\n搜索themes，将里面的值改为next\n1 theme: next 配置 Next 主题 将 node_modules/hexo-theme-next/_config.yml 复制到博客顶层文件目录，重命名为 \u0026ldquo;_config.next.yml\u0026rdquo;\n1 2 cd your_site_dir cp node_modules/hexo-theme-next/_config.yml _config.next.yml 选择 Schemes 打开 \u0026ldquo;_config.next.yml\u0026rdquo; ，首先可以看到 Scheme Settings ，里面提供了四种模式，本站使用 Mist 主题\n1 2 3 4 5 # Schemes #scheme: Muse scheme: Mist #scheme: Pisces #scheme: Gemini 设置站点 icon 在 favicon 中，可以设置侧边栏头像以及站点 icon ，需要把你的 icon 放在主题目录的 source/img/ 目录下","title":"Hexo 加强 Next Theme 美化"},{"content":"MARO ，“Multi-Agent-Resource Optimization” ，中文是“多代理资源优化” ，使用强化学习来解决资源调度的一个平台 可以应用 MARO 的实际例子：\nCIM,\u0026ldquo;Container Inventory Management\u0026rdquo;,中文是“集装箱库存管理”。全球贸易里面会有很多港口，但是每个港口需要的空集装箱都不一样，有的港口可能空集装箱是剩余的（比如进口向港口），有的港口可能空集装箱不够（比如出口向港口） 而使用 MARO 可以解决这个问题，使得每个港口尽可能分配到恰当的空集装箱资源，不多不少。 在这个场景里面，空集装箱是中心资源，导致资源数量改变的事件有两个： 第一个是 Order ，即订单，订单会导致货物从 source port 运到 destination port ， 这个时候 source port 出货，empty container 会减少，destination port 进货，empty container 会增加 第二个是 repositioning，使用 MARO 重定位空集装箱，平衡全球空集装箱分布。 对上面这个流程图的解释 托运人（shipper）生成订单（send order）后，相应源端口（source port）的空容器将被释放（release empty）给托运人（shipper） 托运人（shipper）将用货物装满集装箱，将其变成满载货物，然后在将满载货物的集装箱运回到（return laden）源港口（source port） 船（vessel）到港口（source port）之后被装载满载货物的集装箱（load laden） 船航行到进口港（source port），卸货（discharge laden） 满载货物将被释放（release laden）给收货人（consignee），收货人将取出其中的货物，集装箱再次变空返回港口（return empty） 这个时候我们发现，整个过程我们还有五个部分没有提到，分别是 agent ，operate empty ，load/discharge empty 为了为了重新平衡集装箱分布，每个港口（port）的代理商（agent）将决定每次船舶（vessel）到达港口时如何重新分配（repostioning）空集装箱 船只（vessel）到达港口时，是往船上装载空集装箱（load empty），还是消费船上原有的空集装箱（discharge empty） 分配 load/discharge empty 的数量 MARO 就是帮助 agent 调整 load/discharge empty 的数量，决策目标不仅要考虑自身未来的供需情况，还要考虑上下游港口的需求和情况 出口导向型港口（例如中国的港口）显示出明显的高需求特征，通常需要额外的空集装箱供应，这些港口将倾向于从船上卸载空集装箱 虽然以进口为导向的港口具有显著的盈余特征，但通常从收货人那里收到许多空集装箱，因此，如果存在空闲容量，面向进口的港口将倾向于将多余的空集装箱装入船舶 简单拓扑结构: 这里要特别注意上面这个图里面，这里的 S 和 D 并不是 source 和 destination，而是 empty containers 的 supplier 和 demander，这里 order 也并不是货物订单，而是 empty containers 的订单 上图实线表示货物流向，虚线表示订单流向，S 与 D 由订单（Order）决定，订单发起方为 D，订单收到方为 S 拓扑（1） 有四个 port ，D1 和 D2 是简单的需求者（需要额外 empty container 的端口），而 S2 是简单的供应商（具有剩余空容器的端口），尽管 S1 是一个简单的目标端口，但它位于两个服务路由的交点，这使其成为此拓扑中的特殊端口，为了实现全局最优，S1 必须学会区分服务路由并执行特定于服务路由的重新定位操作 拓扑（2） 中有五个端口，根据订单，D1 和 D2 是简单的需求者，而 S1 和 S2 是简单的供应商，作为服务航线交汇处的港口，T1港口虽然可以达到自平衡状态，但仍对全局最优起着重要作用，T1 的最佳重新定位策略是将多余的空容器从左侧服务路由转移到右侧服务路由，此外，D1 和 D2 应该学会只卸载它们需要的 empty 数量，并将多余的 empty 留给其他端口 拓扑（3） 中有六个端口，简单的需求者 D1 和 D2 ，简单的供应商 S1 和 S2 ，以及自平衡端口 T1 和 T2 ，比拓扑（2）更困难的是，应该采取更多的转移来将多余的空集装箱从最左边的服务路线重新定位到最右边的航线，这意味着需要一个涉及更多港口的多步骤解决方案 这是基于真实世界数据设计的拓扑,大多数港口不再具有简单的供需功能。港口之间的合作要复杂得多，很难手动找到有效的重新定位策略 入门: 安装 1 pip install pymaro MARO 算法有两个关键步骤 算法决策事件 DecisionEventDecisionEvent tick (int)：相应的刻度 port_idx（int）：需要响应环境的端口/代理的 ID vessel_idx（int）：港口/代理人的船舶/操作对象的 ID action_scope（操作范围）：操作范围有两个属性，load表示可以从船舶港口装载的最大数量，discharge表示从船舶到港口可以卸货的最大数量 early_discharge（int）：当船上的可用容量不足以装载满载物时，船上的一些空容器将被提前卸货以释放空间，由于满载而提前卸货的空容器数量记录在该字段中 行动 Action none，这意味着什么都不做 a valid instance，有效实例： vessel_idx（int）：港口/代理人的船舶/操作对象的 ID port_idx（int）：执行此操作的端口/代理的 ID action_type（操作类型）：在此操作中是装载还是卸载空容器 数量（int）：要装载/卸载的空容器的（非负）数量 上图是 MARO 框架图 Simulation toolkit：它提供了一些预定义的场景，以及用于构建新场景的可重用轮子 RL toolkit：它为 RL 提供了全栈抽象，例如代理管理器、代理、RL 算法、学习器、参与者和各种塑造者 Distributed toolkit：提供分布式通信组件、消息自动处理、集群配置、作业编排等用户定义功能的接口 ","permalink":"https://hcy-asleep.github.io/%E5%88%9D%E8%AF%86-MARO/","summary":"\u003ch3 id=\"maro-multi-agent-resource-optimization-httpsgithubcommicrosoftmaro\"\u003e\u003ca href=\"https://github.com/microsoft/maro\"\u003eMARO ，“Multi-Agent-Resource Optimization” \u003c/a\u003e\u003c/h3\u003e","title":"初识 MARO"},{"content":"建立分类\n输入 hexo new page \u0026lsquo;categories\u0026rsquo;\n在顶层工程目录的 source 目录中會看到 categories 文件夹\n修改 categories 中的 index.md 开头，增加一些东西使得变成如下内容\n1 2 3 4 5 --- title: categories date: 2022-10-23 13:30:15 type: \u0026#34;categories\u0026#34; --- 若要把 \u0026ldquo;_post\u0026rdquo; 內的其中一份文档添加到 \u0026ldquo;Hexo-Usage\u0026rdquo; categories 里面，在这个文档头部插入 categories: Hexo-Usage\n1 2 3 4 5 --- title: Hexo 基本美化 date: 2022-10-23 16:08:56 categories: Hexo-Usage --- 重新生成静态网页，可以看到导航栏多了一个分类选项\n建立标签\n和建立分类一样，只不过内容改变一点\n输入 hexo new page \u0026rsquo;tags'\n在顶层工程目录的 source 目录中會看到 tags 文件夹\n修改 tags 中的 index.md 开头，增加一些东西使得变成如下内容\n1 2 3 4 5 --- title: tags date: 2022-10-23 13:35:49 type: \u0026#34;tags\u0026#34; --- 若要把 \u0026ldquo;_post\u0026rdquo; 內的其中一份文档添加到 \u0026ldquo;Hexo\u0026rdquo; tag 里面，在这个文档头部插入 tags: Hexo\n1 2 3 4 5 6 --- title: Hexo 文档分类 图片存储 date: 2022-10-23 19:16:39 categories: Hexo-Usage tags: Hexo --- 插入多个 tags ，记得 tab 缩进\n1 2 3 4 5 6 7 8 --- title: Hexo 文档分类 图片存储 date: 2022-10-23 19:16:39 categories: Hexo-Usage tags: - Hexo - Github --- 重新生成静态网页，可以看到导航栏多了一个标签选项\n文档里面插入图片\n使用Hexo创建文件搭建博客时，会遇到图片插图，以及插入的图片无法显示的问题\n在 Hexo 的目录（也就是顶层工程目录） source 中创建一个图片文件夹，例如 pictures\n把要插入的图片文件放到该目录下面，在文档中正常使用 markdown 的语法插入图片即可，例如\n1 ![img](ictures/xxx.png) 当然，你还可以在 pictures 再创建目录以区分不同文章的图片\n这个时候在文章里面引用的方式就是\n1 ![img](ictures/hexo-文档分类-图片存储/xxx.png) 记住在 \u0026ldquo;pictures\u0026rdquo; 前面有一个 \u0026ldquo;/\u0026rdquo; ，表示根目录的意思，因为对于 hexo 来说它的资源文件的根目录就是 source ，当然也可以修改 \u0026ldquo;_config.yml\u0026rdquo; 改变这个配置，下图是 hexo 框架文件夹描述\n","permalink":"https://hcy-asleep.github.io/Hexo-%E6%96%87%E6%A1%A3%E5%88%86%E7%B1%BB-%E5%9B%BE%E7%89%87%E5%AD%98%E5%82%A8/","summary":"\u003cp\u003e\u003cstrong\u003e建立分类\u003c/strong\u003e\u003c/p\u003e","title":"Hexo 文档分类 图片存储"},{"content":"首先是顶部背景，下面是原背景\n在 blogs 文件夹（顶层工程文件目录）里面搜索 banner.jpg\n把这两个 banner.jpg 替换成自己图片，替换之后名字还得是 banner.jpg\n定义自己的信息，定义在顶层工程目录的 \u0026ldquo;_config.yml\u0026rdquo; 里面\n美化代码块，原本的代码块没有 margin-left 和 margin-right ，不好看 在顶层工程文件目录里面，搜索 highlight.styl\n这两个 css 文件是一样的，要修改的地方也一样\n注释掉原来的 margin ，换成 \u0026ldquo;margin:1px\u0026rdquo; 就可以\n效果很 nice\n最终效果\n","permalink":"https://hcy-asleep.github.io/Hexo-%E5%9F%BA%E6%9C%AC%E7%BE%8E%E5%8C%96/","summary":"\u003cp\u003e\u003cstrong\u003e首先是顶部背景\u003c/strong\u003e，下面是原背景\u003c/p\u003e","title":"Hexo 基本美化"},{"content":" 1 https://github.com/b-ryan/powerline-shell#bash 留意 README.md 里面的内容，留意如何安装 powerline 字体\n","permalink":"https://hcy-asleep.github.io/Bash-Powerline-Fonts-%E7%BE%8E%E5%8C%96/","summary":"1 https://github.com/b-ryan/powerline-shell#bash 留意 README.md 里面的内容，留意如何安装 powerline 字体","title":"Bash Powerline Fonts 美化"},{"content":"需要修改 bashrc 的时候，修改 /etc/bash.bashrc，而不是 ~/.bashrc 前者是全局的，下面这一句话就是 /etc/bash.bashrc 末尾的\n1 source /etc/profile.d/path.sh ","permalink":"https://hcy-asleep.github.io/Debian-Bashrc/","summary":"需要修改 bashrc 的时候，修改 /etc/bash.bashrc，而不是 ~/.bashrc 前者是全局的，下面这一句话就是 /etc/bash.bashrc 末尾的\n1 source /etc/profile.d/path.sh ","title":"Debian Bashrc"},{"content":"不是中文环境需要进行切换中文环境\n可以通过以下命令切换:\n1 sudo dpkg-reconfigure locales 至少选择zh_CN.UTF-8\n更新\n1 sudo apt update 安装 fcitx\n1 sudo apt install fcitx 安装 google-pinyin\n1 sudo apt install fcitx-googlepinyin 重启\n命令行输入 im-config 选中fcitx\n","permalink":"https://hcy-asleep.github.io/Debian-Fcitx-%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95/","summary":"\u003cp\u003e不是中文环境需要进行切换中文环境\u003c/p\u003e","title":"Debian Fcitx 中文输入法"},{"content":"可以参考里面的指引来设置默认浏览器\n1 https://wiki.debian.org/DefaultWebBrowser ","permalink":"https://hcy-asleep.github.io/Debian-Gnome-%E9%BB%98%E8%AE%A4%E6%B5%8F%E8%A7%88%E5%99%A8/","summary":"可以参考里面的指引来设置默认浏览器\n1 https://wiki.debian.org/DefaultWebBrowser ","title":"Debian Gnome 默认浏览器"},{"content":"最重要的一点，去 bios 那里关闭 secure boot 先！\n更新\n1 sudo apt install nvidia-driver 重启\n1 sudo reboot 验证是否安装成功\n1 nvidia-smi ","permalink":"https://hcy-asleep.github.io/Debian-Nvidia-%E9%A9%B1%E5%8A%A8/","summary":"\u003cp\u003e最重要的一点，去 bios 那里关闭 secure boot 先！\u003c/p\u003e","title":"Debian Nvidia 驱动"},{"content":"Github Pages 可以为个人博客提供支持，Hexo 可以让 Github Pages 更加美观和提供本地预览，而不需要上传到 Github Pages 之后再看到效果\n安装准备（本地）：\ngit npm 配置 Git\n1 2 git config --global user.name \u0026#34;github 用户名\u0026#34; git config --global user.email \u0026#34;github 注册邮箱\u0026#34; Github 已经不支持密码登录，需要复杂一点的步骤去验证\n到个人中心-设置-setting 选 classic 的 token 而不是 beta 的，因为 classic 可以永久 点击 generate token按钮 然后 生成了token 一定要复制，不然刷新浏览器就没了\n拿到token以后再去git push/clone ，password就是输入刚才复制的token\nHexo 安装（本地全局）\n1 npm i hexo-cli -g 新建一个文件夹（我的是blogs）用于存放你的博客，然后进入该文件夹，并用如下命令进行初始化并安装必备组件\n1 2 git init hexo init . 初始化后，目录结构如下\n1 2 3 4 5 6 7 8 . ├── _config.yml # 网站配置信息 ├── package.json # 应用程序信息 ├── scaffolds\t# 模板文件夹 ├── source # 存放用户资源 | ├── _drafts | └── _posts\t# 存放个人博客 └── themes # 主题文件夹 然后输入如下命令，然后在浏览器中打开 http://localhost:4000 ，就可以预览原始网站\n1 2 3 hexo new \u0026#39;博客名\u0026#39; # 新建博客 hexo g # 生成静态网页 hexo s # 打开本地服务器 然后就可以看到如下的界面 发布到 Github Pages 上面\n注册 Github 帐号，有帐号了不用注册\n新建一个空仓库，暂时不要创建 README.md ，而且得确保你的仓库是 public 同时，仓库名一定要是 用户名.github.io\n在上文提到的 blogs 文件夹下面安装 hexo-deployer-git\n1 npm install --save hexo-deployer-git 在刚才的博客根目录中的站点配置文件 \u0026ldquo;_config.yml\u0026rdquo; ，设置为你的个人仓库名，branch 与你的 git 主分支对应\n开始推送内容到 Github 上去\n1 2 3 4 5 hexo clean # 清理缓存 hexo g # 将 md 生成 html git add -A # 添加到 git 缓冲区 git commit -m \u0026#34;first time\u0026#34;\t# 提交所有更改 hexo d # 推送到远程 稍等片刻，就可以访问 https://用户名.github.io 了\n","permalink":"https://hcy-asleep.github.io/Github-Pages--Hexo/","summary":"Github Pages 可以为个人博客提供支持，Hexo 可以让 Github Pages 更加美观和提供本地预览，而不需要上传到 Github Pages 之后再看到效果\n安装准备（本地）：\ngit npm 配置 Git\n1 2 git config --global user.name \u0026#34;github 用户名\u0026#34; git config --global user.email \u0026#34;github 注册邮箱\u0026#34; Github 已经不支持密码登录，需要复杂一点的步骤去验证\n到个人中心-设置-setting 选 classic 的 token 而不是 beta 的，因为 classic 可以永久 点击 generate token按钮 然后 生成了token 一定要复制，不然刷新浏览器就没了\n拿到token以后再去git push/clone ，password就是输入刚才复制的token\nHexo 安装（本地全局）\n1 npm i hexo-cli -g 新建一个文件夹（我的是blogs）用于存放你的博客，然后进入该文件夹，并用如下命令进行初始化并安装必备组件\n1 2 git init hexo init . 初始化后，目录结构如下\n1 2 3 4 5 6 7 8 .","title":"Github Pages + Hexo"},{"content":"eg:\n1 2 3 4 5 6 7 8 9 10 11 [Desktop Entry] Encoding=UTF-8 Name=Tabby Comment=Tabby Exec=/home/asleep/softwares/tabby/tabby/tabby %U Icon=/home/asleep/softwares/tabby/tabby/tabby.svg Terminal=false StartupNotify=true Type=Application Categories=Application;Development; StartupWMClass=tabby 需要改变的是 name，common，exec，icon，startupwmclass\n.desktop 文件位于 /usr/share/application/ 下面\nStartupWMClass\n1 xprop | grep CLASS ","permalink":"https://hcy-asleep.github.io/Gnome-Desktop-File-%E5%8F%82%E8%80%83/","summary":"\u003cp\u003eeg:\u003c/p\u003e","title":"Gnome Desktop File 参考"},{"content":" 1 https://github.com/tonsky/FiraCode ","permalink":"https://hcy-asleep.github.io/Linux-VScode-%E5%AD%97%E4%BD%93/","summary":" 1 https://github.com/tonsky/FiraCode ","title":"Linux VScode 字体"},{"content":"/etc/profile.d/path.sh\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 export PATH=$PATH:/home/asleep/softwares/conda/conda/bin export PATH=$PATH:/home/asleep/softwares/qrcp/qrcp export PATH=$PATH:/home/asleep/softwares/nodejs/nodejs/bin export PATH=$PATH:/home/asleep/softwares/baidunetdisk/baidunetdisk/opt/baidunetdisk export PATH=$PATH:/home/asleep/softwares/adb/adb export PATH=$PATH:/home/asleep/softwares/wine/wine export PATH=$PATH:/home/asleep/softwares/neovim/neovim export PATH=$PATH:/home/asleep/softwares/go/go_path/bin export PATH=$PATH:/home/asleep/softwares/autossh/autossh export GOROOT=\u0026#39;/home/asleep/softwares/go/go_base/go\u0026#39; export GOPATH=\u0026#39;/home/asleep/softwares/go/go_path\u0026#39; export GOCACHE=\u0026#39;/home/asleep/softwares/go/go_cache\u0026#39; export GOENV=\u0026#39;/home/asleep/softwares/go/go_env\u0026#39; # export GOMOD=\u0026#39;/home/asleep/softwares/go/go_mod\u0026#39; export GO111MODULE=\u0026#39;auto\u0026#39; # export GOWORK=\u0026#39;/home/asleep/softwares/go/go_work\u0026#39; export GOPROXY=\u0026#39;https://goproxy.cn/,direct\u0026#39; export PATH=$PATH:/home/asleep/softwares/go/go_base/go/bin # alias vim=\u0026#39;vim.tiny\u0026#39; # alias sudo=\u0026#39;sudo \u0026#39; 这里只能存 path 和 alias，其他的能在 /etc/bash.bashrc 里面解决就在那里解决，原则！\n","permalink":"https://hcy-asleep.github.io/Linux-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/","summary":"\u003cp\u003e/etc/profile.d/path.sh\u003c/p\u003e","title":"Linux 环境变量配置"},{"content":"Linux 环境变量配置出错后，提示command not found\n处理方法：\n1 export PATH=$PATH:/usr/bin:/usr/sbin:/bin:/sbin 这样处理后，临时生效环境变量，然后修改配置错误的文件例如.bash_profile /etc/profile .bashrc 等，修改后，执行source生效正确的环境变量\n1 source /etc/profile --根据实际情况修改后面的文件路径 ","permalink":"https://hcy-asleep.github.io/Linux-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/","summary":"\u003cp\u003eLinux 环境变量配置出错后，提示command not found\u003c/p\u003e","title":"Linux 环境变量配置错误处理"},{"content":"由于 Node 的官方模块仓库网速太慢，模块仓库需要切换到阿里的源\n1 npm config set registry https://registry.npm.taobao.org/ 执行下面的命令，确认是否切换成功\n1 npm config get registry ","permalink":"https://hcy-asleep.github.io/Nodejs-%E6%8D%A2%E6%BA%90/","summary":"\u003cp\u003e由于 Node 的官方模块仓库网速太慢，模块仓库需要切换到阿里的源\u003c/p\u003e","title":"Nodejs 换源"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 当前行进行替换 :s/XXX/YYY/g # XXX是需要替换的字符串,YYY是替换后的字符串 # 全局替换 :% s/XXX/YYY/g # 对指定部分进行替换用V进入visual模式,再进行 :s/XXX/YYY/g # 或指定行范围 替换 :100,102s/XXX/YYY/g # 模糊查找不区分大小写，在要查找的内容后面加上 \\c 就行 :/xxx\\c :s/XXX\\c/YYY/g ","permalink":"https://hcy-asleep.github.io/VIM-%E6%89%B9%E9%87%8F%E6%9F%A5%E6%89%BE%E6%9B%BF%E6%8D%A2/","summary":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 当前行进行替换 :s/XXX/YYY/g # XXX是需要替换的字符串,YYY是替换后的字符串 # 全局替换 :% s/XXX/YYY/g # 对指定部分进行替换用V进入visual模式,再进行 :s/XXX/YYY/g # 或指定行范围 替换 :100,102s/XXX/YYY/g # 模糊查找不区分大小写，在要查找的内容后面加上 \\c 就行 :/xxx\\c :s/XXX\\c/YYY/g ","title":"VIM 批量查找替换"},{"content":"\u0026ldquo;开始记录进步与欢乐！\u0026rdquo;\n","permalink":"https://hcy-asleep.github.io/The-First-Blog/","summary":"\u003cp\u003e\u0026ldquo;开始记录进步与欢乐！\u0026rdquo;\u003c/p\u003e","title":"The First Blog"},{"content":" 先查看是否有中文语言环境\n1 locale -a 安装语言环境（root权限）记得选 zh_CN-utf8\n1 dpkg-reconfigure locales 安装中文字体\n1 apt-get install *wqy* ","permalink":"https://hcy-asleep.github.io/Debian-%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/","summary":" 先查看是否有中文语言环境\n1 locale -a 安装语言环境（root权限）记得选 zh_CN-utf8\n1 dpkg-reconfigure locales 安装中文字体\n1 apt-get install *wqy* ","title":"Debian 安装中文环境"},{"content":" 对MySQL InnoDB引擎的索引了解吗？ 嗯啊，使用索引可以加快查询速度，其实就是将无序的数据变成有序（有序就能加快检索速度） 在InnoDB引擎中，索引的底层数据结构是B+树 那为什么不使用红黑树或者B树呢？ MySQL的数据是存储在硬盘的，在查询时一般是不能「一次性」把全部数据加载到内存中 红黑树是「二叉查找树」的变种，一个Node节点只能存储一个Key和一个Value B和B+树跟红黑树不一样，它们算是「多路搜索树」，相较于「二叉搜索树」而言，一个Node节点可以存储的信息会更多，「多路搜索树」的高度会比「二叉搜索树」更低 了解了区别之后，其实就很容易发现，在数据不能一次加载至内存的场景下，数据需要被检索出来，选择B或B+树的理由就很充分了（一个Node节点存储信息更多（相较于二叉搜索树），树的高度更低，树的高度影响检索的速度） B+树相对于B树而言，它又有两种特性 一、B+树非叶子节点不存储数据，在相同的数据量下，B+树更加矮壮。（这个应该不用多解释了，数据都存储在叶子节点上，非叶子节点的存储能存储更多的索引，所以整棵树就更加矮壮） 二、B+树叶子节点之间组成一个链表，方便于遍历查询（遍历操作在MySQL中比较常见） 我稍微解释一下吧，你可以脑补下画面 我们在MySQL InnoDB引擎下，每创建一个索引，相当于生成了一颗B+树 如果该索引是「聚集(聚簇)索引」，那当前B+树的叶子节点存储着「主键和当前行的数据」 如果该索引是「非聚簇索引」，那当前B+树的叶子节点存储着「主键和当前索引列值」 比如写了一句sql：select * from user where id \u003e=10，那只要定位到id为10的记录，然后在叶子节点之间通过遍历链表(叶子节点组成的链表)，即可以找到往后的记录了 由于B树是会在非叶子节点也存储数据，要遍历的时候可能就得跨层检索，相对麻烦些 基于树的层级以及业务使用场景的特性，所以MySQL选择了B+树作为索引的底层数据结构 对于哈希结构，其实InnoDB引擎是「自适应」哈希索引的（hash索引的创建由InnoDB存储引擎引擎自动优化创建，我们是干预不了） 嗯…那我了解了，顺便想问下，你知道什么叫做回表吗？ 所谓的回表其实就是，当我们使用索引查询数据时，检索出来的数据可能包含其他列，但走的索引树叶子节点只能查到当前列值以及主键ID，所以需要根据主键ID再去查一遍数据，得到SQL 所需的列 举个例子，我这边建了给订单号ID建了个索引，但我的SQL 是：select orderId,orderName from orderdetail where orderId = 123 SQL都订单ID索引，但在订单ID的索引树的叶子节点只有orderId和Id，而我们还想检索出orderName，所以MySQL 会拿到ID再去查出orderName给我们返回，这种操作就叫回表 想要避免回表，也可以使用覆盖索引（能使用就使用，因为避免了回表操作） 所谓的覆盖索引，实际上就是你想要查出的列刚好在叶子节点上都存在，比如我建了orderId和orderName联合索引，刚好我需要查询也是orderId和orderName，这些数据都存在索引树的叶子节点上，就不需要回表操作了 既然你也提到了联合索引，我想问下你了解最左匹配原则吗？ 嗯，说明这个概念，还是举例子比较容易说明 如有索引 (a,b,c,d)，查询条件 a=1 and b=2 and c\u003e3 and d=4，则会在每个节点依次命中a、b、c，无法命中d 先匹配最左边的，索引只能用于查找key是否存在（相等），遇到范围查询 (\u003e、\u003c、between、like左匹配)等就不能进一步匹配了，后续退化为线性查找 这就是最左匹配原则 嗯嗯，我还想问下你们主键是怎么生成的？ 主键就自增的 那假设我不用MySQL自增的主键，你觉得会有什么问题呢？ 首先主键得保证它的唯一性和空间尽可能短吧，这两块是需要考虑的 另外，由于索引的特性（有序），如果生成像uuid类似的主键，那插入的的性能是比自增的要差的 因为生成的uuid，在插入时有可能需要移动磁盘块（比如，块内的空间在当前时刻已经存储满了，但新生成的uuid需要插入已满的块内，就需要移动块的数据） OK… Summary\n为什么B+树？\n数据无法一次load到内存，B+树是多路搜索树，只有叶子节点才存储数据，叶子节点之间链表进行关联。（树矮，易遍历） 什么是回表？\n非聚簇索引在叶子节点只存储列值以及主键ID，有条件下尽可能用覆盖索引避免回表操作，提高查询速度 什么是最左匹配原则？\n从最左边为起点开始连续匹配，遇到范围查询终止 主键非自增会有什么问题？\n插入效率下降，存在移动块的数据问题 ","permalink":"https://hcy-asleep.github.io/MySQL-%E9%97%B2%E8%B0%88-1/","summary":"\u003cdiv align=\"left\"\u003e\u003cdiv style=\"width: 60%; border-style: solid; border-width: 1px; border-radius: 16px; position: relative; padding:30px; text-align:center\"\u003e \n对MySQL InnoDB引擎的索引了解吗？\n\u003c/div\u003e\u003c/div\u003e\u003cbr/\u003e","title":"MySQL 闲谈 1"},{"content":"podman 运行 GUI 应用\n首先 host 的环境，也就是宿主机的桌面环境得是 X11 ，Wayland 是不行的\n允许 podman 访问 xserver\n在 host 上运行\n1 xhost +\u0026#34;local:podman@\u0026#34; 如果不行，那就加 sudo 试一下\n创建并且启动 podman 容器\n这个建议在 rootless 下执行，在 Arch Linux 下测试是可以 rootless 运行这条命令的\n1 podman run --privileged -it -e DISPLAY=$DISPLAY -v /tmp/.X11-unix/:/tmp/.X11-unix:rw -v /home/hcy/Share/:/share ubuntu 老规矩，不行就加上 sudo\n\u0026ldquo;-v\u0026rdquo; 选项是 verbose ，也就是映射，上面第二个要根据自己的情况而定，这个映射是为了宿主与容器共享文件夹\nubuntu 是你需要的 image 名称，可以换成其他的名称\n安装 X11 应用并测试\n完成第三步之后，就已经自动进入到容器交互界面里面了\n以 ubunut 为例子，先更新 apt\n1 apt update 1 apt upgrade 安装文字编辑器（非GUI）\n1 apt install neovim 安装 sudo\n1 apt install sudo 安装文字编辑器（GUI）\n1 apt install mousepad 启动 mousepad ，不出意外应该可以跑起来\n1 mousepad 因为有时候并不想在容器的 root 用户下开发，所以有必要创建一个普通用户\n1 useradd -m hcy 为 root 重设密码\n1 passwd root 为 hcy 重设密码\n1 passwd hcy 指定 hcy 的 shell 为 bash 而非 sh\n1 usermod -s /bin/bash hcy 将 hcy 添加到 sudo 组里面\n1 sudo visudo 找到 \u0026ldquo;root ALL=(ALL:ALL) ALL\u0026rdquo;，在这一行下面添加这一行，保存退出\n1 hcy ALL=(ALL:ALL) ALL 切换到 hcy 用户\n1 su hcy 不出意料，会出现如下报错打不开 GUI 应用\n1 2 3 Authorization required, but no authorization protocol specified (org.gnome.Nautilus:4410): Gtk-WARNING **: 23:12:51.995: cannot open display: :10.0 如何解决？这时候需要一条神奇的命令\n1 xhost + local: 提示没有 xhost 怎么办？在 ubuntu 下面安装如下组件之后再试一次（老规矩：不行就 sudo ）\n1 sudo apt install x11-xserver-utils 不出意外，现在在 hcy 用户下也可以启动 mousepad GUI 了\n如果提示 \u0026quot; Failed to execute child process \u0026ldquo;dbus-lauch\u0026rdquo; \u0026quot; 报错\n1 sudo apt-get install dbus-x11 ","permalink":"https://hcy-asleep.github.io/Podman--X11-%E7%8E%AF%E5%A2%83%E8%BF%90%E8%A1%8C-GUI-%E7%A8%8B%E5%BA%8F/","summary":"podman 运行 GUI 应用\n首先 host 的环境，也就是宿主机的桌面环境得是 X11 ，Wayland 是不行的\n允许 podman 访问 xserver\n在 host 上运行\n1 xhost +\u0026#34;local:podman@\u0026#34; 如果不行，那就加 sudo 试一下\n创建并且启动 podman 容器\n这个建议在 rootless 下执行，在 Arch Linux 下测试是可以 rootless 运行这条命令的\n1 podman run --privileged -it -e DISPLAY=$DISPLAY -v /tmp/.X11-unix/:/tmp/.X11-unix:rw -v /home/hcy/Share/:/share ubuntu 老规矩，不行就加上 sudo\n\u0026ldquo;-v\u0026rdquo; 选项是 verbose ，也就是映射，上面第二个要根据自己的情况而定，这个映射是为了宿主与容器共享文件夹\nubuntu 是你需要的 image 名称，可以换成其他的名称\n安装 X11 应用并测试\n完成第三步之后，就已经自动进入到容器交互界面里面了\n以 ubunut 为例子，先更新 apt\n1 apt update 1 apt upgrade 安装文字编辑器（非GUI）","title":"Podman + X11 环境运行 GUI 程序"}]